from typing import *
import enum
from _typeshed import Incomplete
from typing import Any, Callable, ClassVar

CUDA_ARRAY3D_2DARRAY: int
CUDA_ARRAY3D_COLOR_ATTACHMENT: int
CUDA_ARRAY3D_CUBEMAP: int
CUDA_ARRAY3D_DEFERRED_MAPPING: int
CUDA_ARRAY3D_DEPTH_TEXTURE: int
CUDA_ARRAY3D_LAYERED: int
CUDA_ARRAY3D_SPARSE: int
CUDA_ARRAY3D_SURFACE_LDST: int
CUDA_ARRAY3D_TEXTURE_GATHER: int
CUDA_ARRAY3D_VIDEO_ENCODE_DECODE: int
CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC: int
CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC: int
CUDA_EGL_INFINITE_TIMEOUT: int
CUDA_EXTERNAL_MEMORY_DEDICATED: int
CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC: int
CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC: int
CUDA_NVSCISYNC_ATTR_SIGNAL: int
CUDA_NVSCISYNC_ATTR_WAIT: int
CUDA_VERSION: int
CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL: int
CU_COMPUTE_ACCELERATED_TARGET_BASE: int
CU_DEVICE_CPU: int
CU_DEVICE_INVALID: int
CU_GRAPH_COND_ASSIGN_DEFAULT: int
CU_GRAPH_KERNEL_NODE_PORT_DEFAULT: int
CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER: int
CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC: int
CU_IPC_HANDLE_SIZE: int
CU_KERNEL_NODE_ATTRIBUTE_ACCESS_POLICY_WINDOW: int
CU_KERNEL_NODE_ATTRIBUTE_CLUSTER_DIMENSION: int
CU_KERNEL_NODE_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE: int
CU_KERNEL_NODE_ATTRIBUTE_COOPERATIVE: int
CU_KERNEL_NODE_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE: int
CU_KERNEL_NODE_ATTRIBUTE_MEM_SYNC_DOMAIN: int
CU_KERNEL_NODE_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP: int
CU_KERNEL_NODE_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION: int
CU_KERNEL_NODE_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: int
CU_KERNEL_NODE_ATTRIBUTE_PRIORITY: int
CU_LAUNCH_PARAM_BUFFER_POINTER: int
CU_LAUNCH_PARAM_BUFFER_POINTER_AS_INT: int
CU_LAUNCH_PARAM_BUFFER_SIZE: int
CU_LAUNCH_PARAM_BUFFER_SIZE_AS_INT: int
CU_LAUNCH_PARAM_END: int
CU_LAUNCH_PARAM_END_AS_INT: int
CU_MEMHOSTALLOC_DEVICEMAP: int
CU_MEMHOSTALLOC_PORTABLE: int
CU_MEMHOSTALLOC_WRITECOMBINED: int
CU_MEMHOSTREGISTER_DEVICEMAP: int
CU_MEMHOSTREGISTER_IOMEMORY: int
CU_MEMHOSTREGISTER_PORTABLE: int
CU_MEMHOSTREGISTER_READ_ONLY: int
CU_MEM_CREATE_USAGE_HW_DECOMPRESS: int
CU_MEM_CREATE_USAGE_TILE_POOL: int
CU_MEM_POOL_CREATE_USAGE_HW_DECOMPRESS: int
CU_PARAM_TR_DEFAULT: int
CU_STREAM_ATTRIBUTE_ACCESS_POLICY_WINDOW: int
CU_STREAM_ATTRIBUTE_MEM_SYNC_DOMAIN: int
CU_STREAM_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP: int
CU_STREAM_ATTRIBUTE_PRIORITY: int
CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY: int
CU_STREAM_LEGACY: int
CU_STREAM_PER_THREAD: int
CU_TENSOR_MAP_NUM_QWORDS: int
CU_TRSA_OVERRIDE_FORMAT: int
CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION: int
CU_TRSF_NORMALIZED_COORDINATES: int
CU_TRSF_READ_AS_INTEGER: int
CU_TRSF_SEAMLESS_CUBEMAP: int
CU_TRSF_SRGB: int
MAX_PLANES: int
RESOURCE_ABI_EXTERNAL_BYTES: int
RESOURCE_ABI_VERSION: int

def __reduce_cython__(self):
    """
    VdpOutputSurface.__reduce_cython__(self)
    """


def __setstate_cython__(self, __pyx_state):
    """
    VdpOutputSurface.__setstate_cython__(self, __pyx_state)
    """

__test__: dict

def cuArray3DCreate(pAllocateArray: 'Optional[CUDA_ARRAY3D_DESCRIPTOR]'):
    """
    cuArray3DCreate(CUDA_ARRAY3D_DESCRIPTOR pAllocateArray: Optional[CUDA_ARRAY3D_DESCRIPTOR])
     Creates a 3D CUDA array.

        Creates a CUDA array according to the
        :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` structure `pAllocateArray` and
        returns a handle to the new CUDA array in `*pHandle`. The
        :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - `Width`, `Height`, and `Depth` are the width, height, and depth of
          the CUDA array (in elements); the following types of CUDA arrays can
          be allocated:

          - A 1D array is allocated if `Height` and `Depth` extents are both
            zero.

          - A 2D array is allocated if only `Depth` extent is zero.

          - A 3D array is allocated if all three extents are non-zero.

          - A 1D layered CUDA array is allocated if only `Height` is zero and
            the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set. Each layer is a
            1D array. The number of layers is determined by the depth extent.

          - A 2D layered CUDA array is allocated if all three extents are non-
            zero and the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set. Each
            layer is a 2D array. The number of layers is determined by the
            depth extent.

          - A cubemap CUDA array is allocated if all three extents are non-zero
            and the :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` flag is set. `Width` must
            be equal to `Height`, and `Depth` must be six. A cubemap is a
            special type of 2D layered CUDA array, where the six layers
            represent the six faces of a cube. The order of the six layers in
            memory is the same as that listed in
            :py:obj:`~.CUarray_cubemap_face`.

          - A cubemap layered CUDA array is allocated if all three extents are
            non-zero, and both, :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` and
            :py:obj:`~.CUDA_ARRAY3D_LAYERED` flags are set. `Width` must be
            equal to `Height`, and `Depth` must be a multiple of six. A cubemap
            layered CUDA array is a special type of 2D layered CUDA array that
            consists of a collection of cubemaps. The first six layers
            represent the first cubemap, the next six layers form the second
            cubemap, and so on.

        - :py:obj:`~.Format` specifies the format of the elements;
          :py:obj:`~.CUarray_format` is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - `NumChannels` specifies the number of packed components per CUDA
          array element; it may be 1, 2, or 4;

        - :py:obj:`~.Flags` may be set to

          - :py:obj:`~.CUDA_ARRAY3D_LAYERED` to enable creation of layered CUDA
            arrays. If this flag is set, `Depth` specifies the number of
            layers, not the depth of a 3D array.

          - :py:obj:`~.CUDA_ARRAY3D_SURFACE_LDST` to enable surface references
            to be bound to the CUDA array. If this flag is not set,
            :py:obj:`~.cuSurfRefSetArray` will fail when attempting to bind the
            CUDA array to a surface reference.

          - :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` to enable creation of cubemaps. If
            this flag is set, `Width` must be equal to `Height`, and `Depth`
            must be six. If the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is also
            set, then `Depth` must be a multiple of six.

          - :py:obj:`~.CUDA_ARRAY3D_TEXTURE_GATHER` to indicate that the CUDA
            array will be used for texture gather. Texture gather can only be
            performed on 2D CUDA arrays.

        `Width`, `Height` and `Depth` must meet certain size requirements as
        listed in the following table. All values are specified in elements.
        Note that for brevity's sake, the full name of the device attribute is
        not specified. For ex., TEXTURE1D_WIDTH refers to the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH`.

        Note that 2D CUDA arrays have different size requirements if the
        :py:obj:`~.CUDA_ARRAY3D_TEXTURE_GATHER` flag is set. `Width` and
        `Height` must not be greater than
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH` and
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT`
        respectively, in that case.

        **View CUDA Toolkit Documentation for a table example**

        Here are examples of CUDA array descriptions:

        Description for a CUDA array of 2048 floats:

        **View CUDA Toolkit Documentation for a C++ code example**

        Description for a 64 x 64 CUDA array of floats:

        **View CUDA Toolkit Documentation for a C++ code example**

        Description for a `width` x `height` x `depth` CUDA array of 64-bit,
        4x16-bit float16's:

        **View CUDA Toolkit Documentation for a C++ code example**

        Parameters
        ----------
        pAllocateArray : :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR`
            3D array descriptor

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        pHandle : :py:obj:`~.CUarray`
            Returned array

        See Also
        --------
        :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMalloc3DArray`
    """


def cuArray3DGetDescriptor(hArray):
    """
    cuArray3DGetDescriptor(hArray)
     Get a 3D CUDA array descriptor.

        Returns in `*pArrayDescriptor` a descriptor containing information on
        the format and dimensions of the CUDA array `hArray`. It is useful for
        subroutines that have been passed a CUDA array, but need to know the
        CUDA array parameters for validation or other purposes.

        This function may be called on 1D and 2D arrays, in which case the
        `Height` and/or `Depth` members of the descriptor struct will be set to
        0.

        Parameters
        ----------
        hArray : :py:obj:`~.CUarray`
            3D array to get descriptor of

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`
        pArrayDescriptor : :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR`
            Returned 3D array descriptor

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaArrayGetInfo`
    """


def cuArrayCreate(pAllocateArray: 'Optional[CUDA_ARRAY_DESCRIPTOR]'):
    """
    cuArrayCreate(CUDA_ARRAY_DESCRIPTOR pAllocateArray: Optional[CUDA_ARRAY_DESCRIPTOR])
     Creates a 1D or 2D CUDA array.

        Creates a CUDA array according to the :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
        structure `pAllocateArray` and returns a handle to the new CUDA array
        in `*pHandle`. The :py:obj:`~.CUDA_ARRAY_DESCRIPTOR` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - `Width`, and `Height` are the width, and height of the CUDA array (in
          elements); the CUDA array is one-dimensional if height is 0, two-
          dimensional otherwise;

        - :py:obj:`~.Format` specifies the format of the elements;
          :py:obj:`~.CUarray_format` is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - `NumChannels` specifies the number of packed components per CUDA
          array element; it may be 1, 2, or 4;

        Here are examples of CUDA array descriptions:

        Description for a CUDA array of 2048 floats:

        **View CUDA Toolkit Documentation for a C++ code example**

        Description for a 64 x 64 CUDA array of floats:

        **View CUDA Toolkit Documentation for a C++ code example**

        Description for a `width` x `height` CUDA array of 64-bit, 4x16-bit
        float16's:

        **View CUDA Toolkit Documentation for a C++ code example**

        Description for a `width` x `height` CUDA array of 16-bit elements,
        each of which is two 8-bit unsigned chars:

        **View CUDA Toolkit Documentation for a C++ code example**

        Parameters
        ----------
        pAllocateArray : :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
            Array descriptor

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        pHandle : :py:obj:`~.CUarray`
            Returned array

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMallocArray`
    """


def cuArrayDestroy(hArray):
    """
    cuArrayDestroy(hArray)
     Destroys a CUDA array.

        Destroys the CUDA array `hArray`.

        Parameters
        ----------
        hArray : :py:obj:`~.CUarray`
            Array to destroy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ARRAY_IS_MAPPED`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaFreeArray`
    """


def cuArrayGetDescriptor(hArray):
    """
    cuArrayGetDescriptor(hArray)
     Get a 1D or 2D CUDA array descriptor.

        Returns in `*pArrayDescriptor` a descriptor containing information on
        the format and dimensions of the CUDA array `hArray`. It is useful for
        subroutines that have been passed a CUDA array, but need to know the
        CUDA array parameters for validation or other purposes.

        Parameters
        ----------
        hArray : :py:obj:`~.CUarray`
            Array to get descriptor of

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
        pArrayDescriptor : :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
            Returned array descriptor

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaArrayGetInfo`
    """


def cuArrayGetMemoryRequirements(array, device):
    """
    cuArrayGetMemoryRequirements(array, device)
     Returns the memory requirements of a CUDA array.

        Returns the memory requirements of a CUDA array in `memoryRequirements`
        If the CUDA array is not allocated with flag
        :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned.

        The returned value in :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.size`
        represents the total size of the CUDA array. The returned value in
        :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.alignment` represents the
        alignment necessary for mapping the CUDA array.

        Parameters
        ----------
        array : :py:obj:`~.CUarray`
            CUDA array to get the memory requirements of
        device : :py:obj:`~.CUdevice`
            Device to get the memory requirements for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        memoryRequirements : :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`
            Pointer to :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`

        See Also
        --------
        :py:obj:`~.cuMipmappedArrayGetMemoryRequirements`, :py:obj:`~.cuMemMapArrayAsync`
    """


def cuArrayGetPlane(hArray, planeIdx):
    """
    cuArrayGetPlane(hArray, unsigned int planeIdx)
     Gets a CUDA array plane from a CUDA array.

        Returns in `pPlaneArray` a CUDA array that represents a single format
        plane of the CUDA array `hArray`.

        If `planeIdx` is greater than the maximum number of planes in this
        array or if the array does not have a multi-planar format e.g:
        :py:obj:`~.CU_AD_FORMAT_NV12`, then
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

        Note that if the `hArray` has format :py:obj:`~.CU_AD_FORMAT_NV12`,
        then passing in 0 for `planeIdx` returns a CUDA array of the same size
        as `hArray` but with one channel and
        :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT8` as its format. If 1 is passed
        for `planeIdx`, then the returned CUDA array has half the height and
        width of `hArray` with two channels and
        :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT8` as its format.

        Parameters
        ----------
        hArray : :py:obj:`~.CUarray`
            Multiplanar CUDA array
        planeIdx : unsigned int
            Plane index

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
        pPlaneArray : :py:obj:`~.CUarray`
            Returned CUDA array referenced by the `planeIdx`

        See Also
        --------
        :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaArrayGetPlane`
    """


def cuArrayGetSparseProperties(array):
    """
    cuArrayGetSparseProperties(array)
     Returns the layout properties of a sparse CUDA array.

        Returns the layout properties of a sparse CUDA array in
        `sparseProperties` If the CUDA array is not allocated with flag
        :py:obj:`~.CUDA_ARRAY3D_SPARSE` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        will be returned.

        If the returned value in :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.flags`
        contains :py:obj:`~.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL`, then
        :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` represents the
        total size of the array. Otherwise, it will be zero. Also, the returned
        value in :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailFirstLevel` is
        always zero. Note that the `array` must have been allocated using
        :py:obj:`~.cuArrayCreate` or :py:obj:`~.cuArray3DCreate`. For CUDA
        arrays obtained using :py:obj:`~.cuMipmappedArrayGetLevel`,
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned. Instead,
        :py:obj:`~.cuMipmappedArrayGetSparseProperties` must be used to obtain
        the sparse properties of the entire CUDA mipmapped array to which
        `array` belongs to.

        Parameters
        ----------
        array : :py:obj:`~.CUarray`
            CUDA array to get the sparse properties of

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        sparseProperties : :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`
            Pointer to :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`

        See Also
        --------
        :py:obj:`~.cuMipmappedArrayGetSparseProperties`, :py:obj:`~.cuMemMapArrayAsync`
    """


def cuCheckpointProcessCheckpoint(pid, args: 'Optional[CUcheckpointCheckpointArgs]'):
    """
    cuCheckpointProcessCheckpoint(int pid, CUcheckpointCheckpointArgs args: Optional[CUcheckpointCheckpointArgs])
     Checkpoint a CUDA process's GPU memory contents.

        Checkpoints a CUDA process specified by `pid` that is in the LOCKED
        state. The GPU memory contents will be brought into host memory and all
        underlying references will be released. Process must be in the LOCKED
        state to checkpoint.

        Upon successful return the process will be in the CHECKPOINTED state.

        Parameters
        ----------
        pid : int
            The process ID of the CUDA process
        args : :py:obj:`~.CUcheckpointCheckpointArgs`
            Optional checkpoint operation arguments

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    """


def cuCheckpointProcessGetRestoreThreadId(pid):
    """
    cuCheckpointProcessGetRestoreThreadId(int pid)
     Returns the restore thread ID for a CUDA process.

        Returns in `*tid` the thread ID of the CUDA restore thread for the
        process specified by `pid`.

        Parameters
        ----------
        pid : int
            The process ID of the CUDA process

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        tid : int
            Returned restore thread ID
    """


def cuCheckpointProcessGetState(pid):
    """
    cuCheckpointProcessGetState(int pid)
     Returns the process state of a CUDA process.

        Returns in `*state` the current state of the CUDA process specified by
        `pid`.

        Parameters
        ----------
        pid : int
            The process ID of the CUDA process

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        state : :py:obj:`~.CUprocessState`
            Returned CUDA process state
    """


def cuCheckpointProcessLock(pid, args: 'Optional[CUcheckpointLockArgs]'):
    """
    cuCheckpointProcessLock(int pid, CUcheckpointLockArgs args: Optional[CUcheckpointLockArgs])
     Lock a running CUDA process.

        Lock the CUDA process specified by `pid` which will block further CUDA
        API calls. Process must be in the RUNNING state in order to lock.

        Upon successful return the process will be in the LOCKED state.

        If timeoutMs is specified and the timeout is reached the process will
        be left in the RUNNING state upon return.

        Parameters
        ----------
        pid : int
            The process ID of the CUDA process
        args : :py:obj:`~.CUcheckpointLockArgs`
            Optional lock operation arguments

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` :py:obj:`~.CUDA_ERROR_NOT_READY`
    """


def cuCheckpointProcessRestore(pid, args: 'Optional[CUcheckpointRestoreArgs]'):
    """
    cuCheckpointProcessRestore(int pid, CUcheckpointRestoreArgs args: Optional[CUcheckpointRestoreArgs])
     Restore a CUDA process's GPU memory contents from its last checkpoint.

        Restores a CUDA process specified by `pid` from its last checkpoint.
        Process must be in the CHECKPOINTED state to restore.

        Upon successful return the process will be in the LOCKED state.

        CUDA process restore requires persistence mode to be enabled or
        :py:obj:`~.cuInit` to have been called before execution.

        Parameters
        ----------
        pid : int
            The process ID of the CUDA process
        args : :py:obj:`~.CUcheckpointRestoreArgs`
            Optional restore operation arguments

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuInit`
    """


def cuCheckpointProcessUnlock(pid, args: 'Optional[CUcheckpointUnlockArgs]'):
    """
    cuCheckpointProcessUnlock(int pid, CUcheckpointUnlockArgs args: Optional[CUcheckpointUnlockArgs])
     Unlock a CUDA process to allow CUDA API calls.

        Unlocks a process specified by `pid` allowing it to resume making CUDA
        API calls. Process must be in the LOCKED state.

        Upon successful return the process will be in the RUNNING state.

        Parameters
        ----------
        pid : int
            The process ID of the CUDA process
        args : :py:obj:`~.CUcheckpointUnlockArgs`
            Optional unlock operation arguments

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    """


def cuCoredumpGetAttribute(attrib: 'CUcoredumpSettings'):
    """
    cuCoredumpGetAttribute(attrib: CUcoredumpSettings)
     Allows caller to fetch a coredump attribute value for the current context.

        Returns in `*value` the requested value specified by `attrib`. It is up
        to the caller to ensure that the data type and size of `*value` matches
        the request.

        If the caller calls this function with `*value` equal to NULL, the size
        of the memory region (in bytes) expected for `attrib` will be placed in
        `size`.

        The supported attributes are:

        - :py:obj:`~.CU_COREDUMP_ENABLE_ON_EXCEPTION`: Bool where
          :py:obj:`~.true` means that GPU exceptions from this context will
          create a coredump at the location specified by
          :py:obj:`~.CU_COREDUMP_FILE`. The default value is :py:obj:`~.false`
          unless set to :py:obj:`~.true` globally or locally, or the
          CU_CTX_USER_COREDUMP_ENABLE flag was set during context creation.

        - :py:obj:`~.CU_COREDUMP_TRIGGER_HOST`: Bool where :py:obj:`~.true`
          means that the host CPU will also create a coredump. The default
          value is :py:obj:`~.true` unless set to :py:obj:`~.false` globally or
          or locally. This value is deprecated as of CUDA 12.5 - raise the
          :py:obj:`~.CU_COREDUMP_SKIP_ABORT` flag to disable host device
          abort() if needed.

        - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT`: Bool where :py:obj:`~.true`
          means that any resulting coredumps will not have a dump of GPU memory
          or non-reloc ELF images. The default value is :py:obj:`~.false`
          unless set to :py:obj:`~.true` globally or locally. This attribute is
          deprecated as of CUDA 12.5, please use
          :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS` instead.

        - :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER`: Bool where
          :py:obj:`~.true` means that a coredump can be created by writing to
          the system pipe specified by :py:obj:`~.CU_COREDUMP_PIPE`. The
          default value is :py:obj:`~.false` unless set to :py:obj:`~.true`
          globally or locally.

        - :py:obj:`~.CU_COREDUMP_FILE`: String of up to 1023 characters that
          defines the location where any coredumps generated by this context
          will be written. The default value is
          :py:obj:`~.core`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is the
          host name of the machine running the CUDA applications and
          :py:obj:`~.PID` is the process ID of the CUDA application.

        - :py:obj:`~.CU_COREDUMP_PIPE`: String of up to 1023 characters that
          defines the name of the pipe that will be monitored if user-triggered
          coredumps are enabled. The default value is
          :py:obj:`~.corepipe`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is
          the host name of the machine running the CUDA application and
          :py:obj:`~.PID` is the process ID of the CUDA application.

        - :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS`: An integer with values to
          allow granular control the data contained in a coredump specified as
          a bitwise OR combination of the following values:

          - :py:obj:`~.CU_COREDUMP_DEFAULT_FLAGS` - if set by itself, coredump
            generation returns to its default settings of including all memory
            regions that it is able to access

          - :py:obj:`~.CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES` - Coredump
            will not include the data from CUDA source modules that are not
            relocated at runtime.

          - :py:obj:`~.CU_COREDUMP_SKIP_GLOBAL_MEMORY` - Coredump will not
            include device-side global data that does not belong to any
            context.

          - :py:obj:`~.CU_COREDUMP_SKIP_SHARED_MEMORY` - Coredump will not
            include grid-scale shared memory for the warp that the dumped
            kernel belonged to.

          - :py:obj:`~.CU_COREDUMP_SKIP_LOCAL_MEMORY` - Coredump will not
            include local memory from the kernel.

          - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT_FLAGS` - Enables all of the
            above options. Equiavlent to setting the
            :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT` attribute to :py:obj:`~.true`.

          - :py:obj:`~.CU_COREDUMP_SKIP_ABORT` - If set, GPU exceptions will
            not raise an abort() in the host CPU process. Same functional goal
            as :py:obj:`~.CU_COREDUMP_TRIGGER_HOST` but better reflects the
            default behavior.

        Parameters
        ----------
        attrib : :py:obj:`~.CUcoredumpSettings`
            The enum defining which value to fetch.
        size : int
            The size of the memory region `value` points to.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`
        value : Any
            void* containing the requested data.
        size : int
            The size of the memory region `value` points to.

        See Also
        --------
        :py:obj:`~.cuCoredumpGetAttributeGlobal`, :py:obj:`~.cuCoredumpSetAttribute`, :py:obj:`~.cuCoredumpSetAttributeGlobal`
    """


def cuCoredumpGetAttributeGlobal(attrib: 'CUcoredumpSettings'):
    """
    cuCoredumpGetAttributeGlobal(attrib: CUcoredumpSettings)
     Allows caller to fetch a coredump attribute value for the entire application.

        Returns in `*value` the requested value specified by `attrib`. It is up
        to the caller to ensure that the data type and size of `*value` matches
        the request.

        If the caller calls this function with `*value` equal to NULL, the size
        of the memory region (in bytes) expected for `attrib` will be placed in
        `size`.

        The supported attributes are:

        - :py:obj:`~.CU_COREDUMP_ENABLE_ON_EXCEPTION`: Bool where
          :py:obj:`~.true` means that GPU exceptions from this context will
          create a coredump at the location specified by
          :py:obj:`~.CU_COREDUMP_FILE`. The default value is :py:obj:`~.false`.

        - :py:obj:`~.CU_COREDUMP_TRIGGER_HOST`: Bool where :py:obj:`~.true`
          means that the host CPU will also create a coredump. The default
          value is :py:obj:`~.true` unless set to :py:obj:`~.false` globally or
          or locally. This value is deprecated as of CUDA 12.5 - raise the
          :py:obj:`~.CU_COREDUMP_SKIP_ABORT` flag to disable host device
          abort() if needed.

        - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT`: Bool where :py:obj:`~.true`
          means that any resulting coredumps will not have a dump of GPU memory
          or non-reloc ELF images. The default value is :py:obj:`~.false`. This
          attribute is deprecated as of CUDA 12.5, please use
          :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS` instead.

        - :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER`: Bool where
          :py:obj:`~.true` means that a coredump can be created by writing to
          the system pipe specified by :py:obj:`~.CU_COREDUMP_PIPE`. The
          default value is :py:obj:`~.false`.

        - :py:obj:`~.CU_COREDUMP_FILE`: String of up to 1023 characters that
          defines the location where any coredumps generated by this context
          will be written. The default value is
          :py:obj:`~.core`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is the
          host name of the machine running the CUDA applications and
          :py:obj:`~.PID` is the process ID of the CUDA application.

        - :py:obj:`~.CU_COREDUMP_PIPE`: String of up to 1023 characters that
          defines the name of the pipe that will be monitored if user-triggered
          coredumps are enabled. The default value is
          :py:obj:`~.corepipe`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is
          the host name of the machine running the CUDA application and
          :py:obj:`~.PID` is the process ID of the CUDA application.

        - :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS`: An integer with values to
          allow granular control the data contained in a coredump specified as
          a bitwise OR combination of the following values:

          - :py:obj:`~.CU_COREDUMP_DEFAULT_FLAGS` - if set by itself, coredump
            generation returns to its default settings of including all memory
            regions that it is able to access

          - :py:obj:`~.CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES` - Coredump
            will not include the data from CUDA source modules that are not
            relocated at runtime.

          - :py:obj:`~.CU_COREDUMP_SKIP_GLOBAL_MEMORY` - Coredump will not
            include device-side global data that does not belong to any
            context.

          - :py:obj:`~.CU_COREDUMP_SKIP_SHARED_MEMORY` - Coredump will not
            include grid-scale shared memory for the warp that the dumped
            kernel belonged to.

          - :py:obj:`~.CU_COREDUMP_SKIP_LOCAL_MEMORY` - Coredump will not
            include local memory from the kernel.

          - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT_FLAGS` - Enables all of the
            above options. Equiavlent to setting the
            :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT` attribute to :py:obj:`~.true`.

          - :py:obj:`~.CU_COREDUMP_SKIP_ABORT` - If set, GPU exceptions will
            not raise an abort() in the host CPU process. Same functional goal
            as :py:obj:`~.CU_COREDUMP_TRIGGER_HOST` but better reflects the
            default behavior.

        Parameters
        ----------
        attrib : :py:obj:`~.CUcoredumpSettings`
            The enum defining which value to fetch.
        size : int
            The size of the memory region `value` points to.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        value : Any
            void* containing the requested data.
        size : int
            The size of the memory region `value` points to.

        See Also
        --------
        :py:obj:`~.cuCoredumpGetAttribute`, :py:obj:`~.cuCoredumpSetAttribute`, :py:obj:`~.cuCoredumpSetAttributeGlobal`
    """


def cuCoredumpSetAttribute(attrib: 'CUcoredumpSettings', value):
    """
    cuCoredumpSetAttribute(attrib: CUcoredumpSettings, value)
     Allows caller to set a coredump attribute value for the current context.

        This function should be considered an alternate interface to the CUDA-
        GDB environment variables defined in this document:
        https://docs.nvidia.com/cuda/cuda-gdb/index.html#gpu-coredump

        An important design decision to note is that any coredump environment
        variable values set before CUDA initializes will take permanent
        precedence over any values set with this function. This decision was
        made to ensure no change in behavior for any users that may be
        currently using these variables to get coredumps.

        `*value` shall contain the requested value specified by `set`. It is up
        to the caller to ensure that the data type and size of `*value` matches
        the request.

        If the caller calls this function with `*value` equal to NULL, the size
        of the memory region (in bytes) expected for `set` will be placed in
        `size`.

        /note This function will return :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` if
        the caller attempts to set :py:obj:`~.CU_COREDUMP_ENABLE_ON_EXCEPTION`
        on a GPU of with Compute Capability < 6.0.
        :py:obj:`~.cuCoredumpSetAttributeGlobal` works on those platforms as an
        alternative.

        /note :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER` and
        :py:obj:`~.CU_COREDUMP_PIPE` cannot be set on a per-context basis.

        The supported attributes are:

        - :py:obj:`~.CU_COREDUMP_ENABLE_ON_EXCEPTION`: Bool where
          :py:obj:`~.true` means that GPU exceptions from this context will
          create a coredump at the location specified by
          :py:obj:`~.CU_COREDUMP_FILE`. The default value is :py:obj:`~.false`.

        - :py:obj:`~.CU_COREDUMP_TRIGGER_HOST`: Bool where :py:obj:`~.true`
          means that the host CPU will also create a coredump. The default
          value is :py:obj:`~.true` unless set to :py:obj:`~.false` globally or
          or locally. This value is deprecated as of CUDA 12.5 - raise the
          :py:obj:`~.CU_COREDUMP_SKIP_ABORT` flag to disable host device
          abort() if needed.

        - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT`: Bool where :py:obj:`~.true`
          means that any resulting coredumps will not have a dump of GPU memory
          or non-reloc ELF images. The default value is :py:obj:`~.false`. This
          attribute is deprecated as of CUDA 12.5, please use
          :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS` instead.

        - :py:obj:`~.CU_COREDUMP_FILE`: String of up to 1023 characters that
          defines the location where any coredumps generated by this context
          will be written. The default value is
          :py:obj:`~.core`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is the
          host name of the machine running the CUDA applications and
          :py:obj:`~.PID` is the process ID of the CUDA application.

        - :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS`: An integer with values to
          allow granular control the data contained in a coredump specified as
          a bitwise OR combination of the following values:

          - :py:obj:`~.CU_COREDUMP_DEFAULT_FLAGS` - if set by itself, coredump
            generation returns to its default settings of including all memory
            regions that it is able to access

          - :py:obj:`~.CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES` - Coredump
            will not include the data from CUDA source modules that are not
            relocated at runtime.

          - :py:obj:`~.CU_COREDUMP_SKIP_GLOBAL_MEMORY` - Coredump will not
            include device-side global data that does not belong to any
            context.

          - :py:obj:`~.CU_COREDUMP_SKIP_SHARED_MEMORY` - Coredump will not
            include grid-scale shared memory for the warp that the dumped
            kernel belonged to.

          - :py:obj:`~.CU_COREDUMP_SKIP_LOCAL_MEMORY` - Coredump will not
            include local memory from the kernel.

          - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT_FLAGS` - Enables all of the
            above options. Equiavlent to setting the
            :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT` attribute to :py:obj:`~.true`.

          - :py:obj:`~.CU_COREDUMP_SKIP_ABORT` - If set, GPU exceptions will
            not raise an abort() in the host CPU process. Same functional goal
            as :py:obj:`~.CU_COREDUMP_TRIGGER_HOST` but better reflects the
            default behavior.

        Parameters
        ----------
        attrib : :py:obj:`~.CUcoredumpSettings`
            The enum defining which value to set.
        value : Any
            void* containing the requested data.
        size : int
            The size of the memory region `value` points to.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        size : int
            The size of the memory region `value` points to.

        See Also
        --------
        :py:obj:`~.cuCoredumpGetAttributeGlobal`, :py:obj:`~.cuCoredumpGetAttribute`, :py:obj:`~.cuCoredumpSetAttributeGlobal`
    """


def cuCoredumpSetAttributeGlobal(attrib: 'CUcoredumpSettings', value):
    """
    cuCoredumpSetAttributeGlobal(attrib: CUcoredumpSettings, value)
     Allows caller to set a coredump attribute value globally.

        This function should be considered an alternate interface to the CUDA-
        GDB environment variables defined in this document:
        https://docs.nvidia.com/cuda/cuda-gdb/index.html#gpu-coredump

        An important design decision to note is that any coredump environment
        variable values set before CUDA initializes will take permanent
        precedence over any values set with this function. This decision was
        made to ensure no change in behavior for any users that may be
        currently using these variables to get coredumps.

        `*value` shall contain the requested value specified by `set`. It is up
        to the caller to ensure that the data type and size of `*value` matches
        the request.

        If the caller calls this function with `*value` equal to NULL, the size
        of the memory region (in bytes) expected for `set` will be placed in
        `size`.

        The supported attributes are:

        - :py:obj:`~.CU_COREDUMP_ENABLE_ON_EXCEPTION`: Bool where
          :py:obj:`~.true` means that GPU exceptions from this context will
          create a coredump at the location specified by
          :py:obj:`~.CU_COREDUMP_FILE`. The default value is :py:obj:`~.false`.

        - :py:obj:`~.CU_COREDUMP_TRIGGER_HOST`: Bool where :py:obj:`~.true`
          means that the host CPU will also create a coredump. The default
          value is :py:obj:`~.true` unless set to :py:obj:`~.false` globally or
          or locally. This value is deprecated as of CUDA 12.5 - raise the
          :py:obj:`~.CU_COREDUMP_SKIP_ABORT` flag to disable host device
          abort() if needed.

        - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT`: Bool where :py:obj:`~.true`
          means that any resulting coredumps will not have a dump of GPU memory
          or non-reloc ELF images. The default value is :py:obj:`~.false`. This
          attribute is deprecated as of CUDA 12.5, please use
          :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS` instead.

        - :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER`: Bool where
          :py:obj:`~.true` means that a coredump can be created by writing to
          the system pipe specified by :py:obj:`~.CU_COREDUMP_PIPE`. The
          default value is :py:obj:`~.false`.

        - :py:obj:`~.CU_COREDUMP_FILE`: String of up to 1023 characters that
          defines the location where any coredumps generated by this context
          will be written. The default value is
          :py:obj:`~.core`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is the
          host name of the machine running the CUDA applications and
          :py:obj:`~.PID` is the process ID of the CUDA application.

        - :py:obj:`~.CU_COREDUMP_PIPE`: String of up to 1023 characters that
          defines the name of the pipe that will be monitored if user-triggered
          coredumps are enabled. This value may not be changed after
          :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER` is set to
          :py:obj:`~.true`. The default value is
          :py:obj:`~.corepipe`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is
          the host name of the machine running the CUDA application and
          :py:obj:`~.PID` is the process ID of the CUDA application.

        - :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS`: An integer with values to
          allow granular control the data contained in a coredump specified as
          a bitwise OR combination of the following values:

          - :py:obj:`~.CU_COREDUMP_DEFAULT_FLAGS` - if set by itself, coredump
            generation returns to its default settings of including all memory
            regions that it is able to access

          - :py:obj:`~.CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES` - Coredump
            will not include the data from CUDA source modules that are not
            relocated at runtime.

          - :py:obj:`~.CU_COREDUMP_SKIP_GLOBAL_MEMORY` - Coredump will not
            include device-side global data that does not belong to any
            context.

          - :py:obj:`~.CU_COREDUMP_SKIP_SHARED_MEMORY` - Coredump will not
            include grid-scale shared memory for the warp that the dumped
            kernel belonged to.

          - :py:obj:`~.CU_COREDUMP_SKIP_LOCAL_MEMORY` - Coredump will not
            include local memory from the kernel.

          - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT_FLAGS` - Enables all of the
            above options. Equiavlent to setting the
            :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT` attribute to :py:obj:`~.true`.

          - :py:obj:`~.CU_COREDUMP_SKIP_ABORT` - If set, GPU exceptions will
            not raise an abort() in the host CPU process. Same functional goal
            as :py:obj:`~.CU_COREDUMP_TRIGGER_HOST` but better reflects the
            default behavior.

        Parameters
        ----------
        attrib : :py:obj:`~.CUcoredumpSettings`
            The enum defining which value to set.
        value : Any
            void* containing the requested data.
        size : int
            The size of the memory region `value` points to.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`
        size : int
            The size of the memory region `value` points to.

        See Also
        --------
        :py:obj:`~.cuCoredumpGetAttribute`, :py:obj:`~.cuCoredumpGetAttributeGlobal`, :py:obj:`~.cuCoredumpSetAttribute`
    """


def cuCtxAttach(flags):
    """
    cuCtxAttach(unsigned int flags)
     Increment a context's usage-count.

        [Deprecated]

        Note that this function is deprecated and should not be used.

        Increments the usage count of the context and passes back a context
        handle in `*pctx` that must be passed to :py:obj:`~.cuCtxDetach()` when
        the application is done with the context. :py:obj:`~.cuCtxAttach()`
        fails if there is no context current to the thread.

        Currently, the `flags` parameter must be 0.

        Parameters
        ----------
        flags : unsigned int
            Context attach flags (must be 0)

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pctx : :py:obj:`~.CUcontext`
            Returned context handle of the current context

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxDetach`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """


def cuCtxCreate(flags, dev):
    """
    cuCtxCreate(unsigned int flags, dev)
     Create a CUDA context.

        Creates a new CUDA context and associates it with the calling thread.
        The `flags` parameter is described below. The context is created with a
        usage count of 1 and the caller of :py:obj:`~.cuCtxCreate()` must call
        :py:obj:`~.cuCtxDestroy()` when done using the context. If a context is
        already current to the thread, it is supplanted by the newly created
        context and may be restored by a subsequent call to
        :py:obj:`~.cuCtxPopCurrent()`.

        The three LSBs of the `flags` parameter can be used to control how the
        OS thread, which owns the CUDA context at the time of an API call,
        interacts with the OS scheduler when waiting for results from the GPU.
        Only one of the scheduling flags can be set when creating a context.

        - :py:obj:`~.CU_CTX_SCHED_SPIN`: Instruct CUDA to actively spin when
          waiting for results from the GPU. This can decrease latency when
          waiting for the GPU, but may lower the performance of CPU threads if
          they are performing work in parallel with the CUDA thread.

        - :py:obj:`~.CU_CTX_SCHED_YIELD`: Instruct CUDA to yield its thread
          when waiting for results from the GPU. This can increase latency when
          waiting for the GPU, but can increase the performance of CPU threads
          performing work in parallel with the GPU.

        - :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`: Instruct CUDA to block the
          CPU thread on a synchronization primitive when waiting for the GPU to
          finish work.

        - :py:obj:`~.CU_CTX_BLOCKING_SYNC`: Instruct CUDA to block the CPU
          thread on a synchronization primitive when waiting for the GPU to
          finish work.   Deprecated: This flag was deprecated as of CUDA 4.0
          and was replaced with :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`.

        - :py:obj:`~.CU_CTX_SCHED_AUTO`: The default value if the `flags`
          parameter is zero, uses a heuristic based on the number of active
          CUDA contexts in the process `C` and the number of logical processors
          in the system `P`. If `C` > `P`, then CUDA will yield to other OS
          threads when waiting for the GPU (:py:obj:`~.CU_CTX_SCHED_YIELD`),
          otherwise CUDA will not yield while waiting for results and actively
          spin on the processor (:py:obj:`~.CU_CTX_SCHED_SPIN`). Additionally,
          on Tegra devices, :py:obj:`~.CU_CTX_SCHED_AUTO` uses a heuristic
          based on the power profile of the platform and may choose
          :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` for low-powered devices.

        - :py:obj:`~.CU_CTX_MAP_HOST`: Instruct CUDA to support mapped pinned
          allocations. This flag must be set in order to allocate pinned host
          memory that is accessible to the GPU.

        - :py:obj:`~.CU_CTX_LMEM_RESIZE_TO_MAX`: Instruct CUDA to not reduce
          local memory after resizing local memory for a kernel. This can
          prevent thrashing by local memory allocations when launching many
          kernels with high local memory usage at the cost of potentially
          increased memory usage.   Deprecated: This flag is deprecated and the
          behavior enabled by this flag is now the default and cannot be
          disabled. Instead, the per-thread stack size can be controlled with
          :py:obj:`~.cuCtxSetLimit()`.

        - :py:obj:`~.CU_CTX_COREDUMP_ENABLE`: If GPU coredumps have not been
          enabled globally with :py:obj:`~.cuCoredumpSetAttributeGlobal` or
          environment variables, this flag can be set during context creation
          to instruct CUDA to create a coredump if this context raises an
          exception during execution. These environment variables are described
          in the CUDA-GDB user guide under the "GPU core dump support" section.
          The initial attributes will be taken from the global attributes at
          the time of context creation. The other attributes that control
          coredump output can be modified by calling
          :py:obj:`~.cuCoredumpSetAttribute` from the created context after it
          becomes current.

        - :py:obj:`~.CU_CTX_USER_COREDUMP_ENABLE`: If user-triggered GPU
          coredumps have not been enabled globally with
          :py:obj:`~.cuCoredumpSetAttributeGlobal` or environment variables,
          this flag can be set during context creation to instruct CUDA to
          create a coredump if data is written to a certain pipe that is
          present in the OS space. These environment variables are described in
          the CUDA-GDB user guide under the "GPU core dump support" section. It
          is important to note that the pipe name `must` be set with
          :py:obj:`~.cuCoredumpSetAttributeGlobal` before creating the context
          if this flag is used. Setting this flag implies that
          :py:obj:`~.CU_CTX_COREDUMP_ENABLE` is set. The initial attributes
          will be taken from the global attributes at the time of context
          creation. The other attributes that control coredump output can be
          modified by calling :py:obj:`~.cuCoredumpSetAttribute` from the
          created context after it becomes current. Setting this flag on any
          context creation is equivalent to setting the
          :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER` attribute to `true`
          globally.

        - :py:obj:`~.CU_CTX_SYNC_MEMOPS`: Ensures that synchronous memory
          operations initiated on this context will always synchronize. See
          further documentation in the section titled "API Synchronization
          behavior" to learn more about cases when synchronous memory
          operations can exhibit asynchronous behavior.

        Context creation will fail with :py:obj:`~.CUDA_ERROR_UNKNOWN` if the
        compute mode of the device is :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`.
        The function :py:obj:`~.cuDeviceGetAttribute()` can be used with
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE` to determine the compute
        mode of the device. The `nvidia-smi` tool can be used to set the
        compute mode for * devices. Documentation for `nvidia-smi` can be
        obtained by passing a -h option to it.

        Parameters
        ----------
        flags : unsigned int
            Context creation flags
        dev : :py:obj:`~.CUdevice`
            Device to create context on

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        pctx : :py:obj:`~.CUcontext`
            Returned context handle of the new context

        See Also
        --------
        :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCoredumpSetAttributeGlobal`, :py:obj:`~.cuCoredumpSetAttribute`, :py:obj:`~.cuCtxSynchronize`

        Notes
        -----
        In most cases it is recommended to use :py:obj:`~.cuDevicePrimaryCtxRetain`.
    """


def cuCtxCreate_v3(paramsArray: 'Optional[Tuple[CUexecAffinityParam] | List[CUexecAffinityParam]]', numParams, flags, dev):
    """
    cuCtxCreate_v3(paramsArray: Optional[Tuple[CUexecAffinityParam] | List[CUexecAffinityParam]], int numParams, unsigned int flags, dev)
     Create a CUDA context with execution affinity.

        Creates a new CUDA context with execution affinity and associates it
        with the calling thread. The `paramsArray` and `flags` parameter are
        described below. The context is created with a usage count of 1 and the
        caller of :py:obj:`~.cuCtxCreate()` must call
        :py:obj:`~.cuCtxDestroy()` when done using the context. If a context is
        already current to the thread, it is supplanted by the newly created
        context and may be restored by a subsequent call to
        :py:obj:`~.cuCtxPopCurrent()`.

        The type and the amount of execution resource the context can use is
        limited by `paramsArray` and `numParams`. The `paramsArray` is an array
        of `CUexecAffinityParam` and the `numParams` describes the size of the
        array. If two `CUexecAffinityParam` in the array have the same type,
        the latter execution affinity parameter overrides the former execution
        affinity parameter. The supported execution affinity types are:

        - :py:obj:`~.CU_EXEC_AFFINITY_TYPE_SM_COUNT` limits the portion of SMs
          that the context can use. The portion of SMs is specified as the
          number of SMs via `CUexecAffinitySmCount`. This limit will be
          internally rounded up to the next hardware-supported amount. Hence,
          it is imperative to query the actual execution affinity of the
          context via `cuCtxGetExecAffinity` after context creation. Currently,
          this attribute is only supported under Volta+ MPS.

        The three LSBs of the `flags` parameter can be used to control how the
        OS thread, which owns the CUDA context at the time of an API call,
        interacts with the OS scheduler when waiting for results from the GPU.
        Only one of the scheduling flags can be set when creating a context.

        - :py:obj:`~.CU_CTX_SCHED_SPIN`: Instruct CUDA to actively spin when
          waiting for results from the GPU. This can decrease latency when
          waiting for the GPU, but may lower the performance of CPU threads if
          they are performing work in parallel with the CUDA thread.

        - :py:obj:`~.CU_CTX_SCHED_YIELD`: Instruct CUDA to yield its thread
          when waiting for results from the GPU. This can increase latency when
          waiting for the GPU, but can increase the performance of CPU threads
          performing work in parallel with the GPU.

        - :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`: Instruct CUDA to block the
          CPU thread on a synchronization primitive when waiting for the GPU to
          finish work.

        - :py:obj:`~.CU_CTX_BLOCKING_SYNC`: Instruct CUDA to block the CPU
          thread on a synchronization primitive when waiting for the GPU to
          finish work.   Deprecated: This flag was deprecated as of CUDA 4.0
          and was replaced with :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`.

        - :py:obj:`~.CU_CTX_SCHED_AUTO`: The default value if the `flags`
          parameter is zero, uses a heuristic based on the number of active
          CUDA contexts in the process `C` and the number of logical processors
          in the system `P`. If `C` > `P`, then CUDA will yield to other OS
          threads when waiting for the GPU (:py:obj:`~.CU_CTX_SCHED_YIELD`),
          otherwise CUDA will not yield while waiting for results and actively
          spin on the processor (:py:obj:`~.CU_CTX_SCHED_SPIN`). Additionally,
          on Tegra devices, :py:obj:`~.CU_CTX_SCHED_AUTO` uses a heuristic
          based on the power profile of the platform and may choose
          :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` for low-powered devices.

        - :py:obj:`~.CU_CTX_MAP_HOST`: Instruct CUDA to support mapped pinned
          allocations. This flag must be set in order to allocate pinned host
          memory that is accessible to the GPU.

        - :py:obj:`~.CU_CTX_LMEM_RESIZE_TO_MAX`: Instruct CUDA to not reduce
          local memory after resizing local memory for a kernel. This can
          prevent thrashing by local memory allocations when launching many
          kernels with high local memory usage at the cost of potentially
          increased memory usage.   Deprecated: This flag is deprecated and the
          behavior enabled by this flag is now the default and cannot be
          disabled. Instead, the per-thread stack size can be controlled with
          :py:obj:`~.cuCtxSetLimit()`.

        - :py:obj:`~.CU_CTX_COREDUMP_ENABLE`: If GPU coredumps have not been
          enabled globally with :py:obj:`~.cuCoredumpSetAttributeGlobal` or
          environment variables, this flag can be set during context creation
          to instruct CUDA to create a coredump if this context raises an
          exception during execution. These environment variables are described
          in the CUDA-GDB user guide under the "GPU core dump support" section.
          The initial attributes will be taken from the global attributes at
          the time of context creation. The other attributes that control
          coredump output can be modified by calling
          :py:obj:`~.cuCoredumpSetAttribute` from the created context after it
          becomes current.

        - :py:obj:`~.CU_CTX_USER_COREDUMP_ENABLE`: If user-triggered GPU
          coredumps have not been enabled globally with
          :py:obj:`~.cuCoredumpSetAttributeGlobal` or environment variables,
          this flag can be set during context creation to instruct CUDA to
          create a coredump if data is written to a certain pipe that is
          present in the OS space. These environment variables are described in
          the CUDA-GDB user guide under the "GPU core dump support" section. It
          is important to note that the pipe name `must` be set with
          :py:obj:`~.cuCoredumpSetAttributeGlobal` before creating the context
          if this flag is used. Setting this flag implies that
          :py:obj:`~.CU_CTX_COREDUMP_ENABLE` is set. The initial attributes
          will be taken from the global attributes at the time of context
          creation. The other attributes that control coredump output can be
          modified by calling :py:obj:`~.cuCoredumpSetAttribute` from the
          created context after it becomes current. Setting this flag on any
          context creation is equivalent to setting the
          :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER` attribute to `true`
          globally.

        Context creation will fail with :py:obj:`~.CUDA_ERROR_UNKNOWN` if the
        compute mode of the device is :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`.
        The function :py:obj:`~.cuDeviceGetAttribute()` can be used with
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE` to determine the compute
        mode of the device. The `nvidia-smi` tool can be used to set the
        compute mode for * devices. Documentation for `nvidia-smi` can be
        obtained by passing a -h option to it.

        Parameters
        ----------
        paramsArray : List[:py:obj:`~.CUexecAffinityParam`]
            Execution affinity parameters
        numParams : int
            Number of execution affinity parameters
        flags : unsigned int
            Context creation flags
        dev : :py:obj:`~.CUdevice`
            Device to create context on

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        pctx : :py:obj:`~.CUcontext`
            Returned context handle of the new context

        See Also
        --------
        :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuCoredumpSetAttributeGlobal`, :py:obj:`~.cuCoredumpSetAttribute`, :py:obj:`~.CUexecAffinityParam`
    """


def cuCtxCreate_v4(ctxCreateParams: 'Optional[CUctxCreateParams]', flags, dev):
    """
    cuCtxCreate_v4(CUctxCreateParams ctxCreateParams: Optional[CUctxCreateParams], unsigned int flags, dev)
     Create a CUDA context.

        Creates a new CUDA context and associates it with the calling thread.
        The `flags` parameter is described below. The context is created with a
        usage count of 1 and the caller of :py:obj:`~.cuCtxCreate()` must call
        :py:obj:`~.cuCtxDestroy()` when done using the context. If a context is
        already current to the thread, it is supplanted by the newly created
        context and may be restored by a subsequent call to
        :py:obj:`~.cuCtxPopCurrent()`.

        CUDA context can be created with execution affinity. The type and the
        amount of execution resource the context can use is limited by
        `paramsArray` and `numExecAffinityParams` in `execAffinity`. The
        `paramsArray` is an array of `CUexecAffinityParam` and the
        `numExecAffinityParams` describes the size of the paramsArray. If two
        `CUexecAffinityParam` in the array have the same type, the latter
        execution affinity parameter overrides the former execution affinity
        parameter. The supported execution affinity types are:

        - :py:obj:`~.CU_EXEC_AFFINITY_TYPE_SM_COUNT` limits the portion of SMs
          that the context can use. The portion of SMs is specified as the
          number of SMs via `CUexecAffinitySmCount`. This limit will be
          internally rounded up to the next hardware-supported amount. Hence,
          it is imperative to query the actual execution affinity of the
          context via `cuCtxGetExecAffinity` after context creation. Currently,
          this attribute is only supported under Volta+ MPS.

        CUDA context can be created in CIG(CUDA in Graphics) mode by setting
        `cigParams`. Data from graphics client is shared with CUDA via the
        `sharedData` in `cigParams`. Support for D3D12 graphics client can be
        determined using :py:obj:`~.cuDeviceGetAttribute()` with
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED`. `sharedData` is a
        ID3D12CommandQueue handle. Either `execAffinityParams` or `cigParams`
        can be set to a non-null value. Setting both to a non-null value will
        result in an undefined behavior.

        The three LSBs of the `flags` parameter can be used to control how the
        OS thread, which owns the CUDA context at the time of an API call,
        interacts with the OS scheduler when waiting for results from the GPU.
        Only one of the scheduling flags can be set when creating a context.

        - :py:obj:`~.CU_CTX_SCHED_SPIN`: Instruct CUDA to actively spin when
          waiting for results from the GPU. This can decrease latency when
          waiting for the GPU, but may lower the performance of CPU threads if
          they are performing work in parallel with the CUDA thread.

        - :py:obj:`~.CU_CTX_SCHED_YIELD`: Instruct CUDA to yield its thread
          when waiting for results from the GPU. This can increase latency when
          waiting for the GPU, but can increase the performance of CPU threads
          performing work in parallel with the GPU.

        - :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`: Instruct CUDA to block the
          CPU thread on a synchronization primitive when waiting for the GPU to
          finish work.

        - :py:obj:`~.CU_CTX_BLOCKING_SYNC`: Instruct CUDA to block the CPU
          thread on a synchronization primitive when waiting for the GPU to
          finish work.   Deprecated: This flag was deprecated as of CUDA 4.0
          and was replaced with :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`.

        - :py:obj:`~.CU_CTX_SCHED_AUTO`: The default value if the `flags`
          parameter is zero, uses a heuristic based on the number of active
          CUDA contexts in the process `C` and the number of logical processors
          in the system `P`. If `C` > `P`, then CUDA will yield to other OS
          threads when waiting for the GPU (:py:obj:`~.CU_CTX_SCHED_YIELD`),
          otherwise CUDA will not yield while waiting for results and actively
          spin on the processor (:py:obj:`~.CU_CTX_SCHED_SPIN`). Additionally,
          on Tegra devices, :py:obj:`~.CU_CTX_SCHED_AUTO` uses a heuristic
          based on the power profile of the platform and may choose
          :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` for low-powered devices.

        - :py:obj:`~.CU_CTX_MAP_HOST`: Instruct CUDA to support mapped pinned
          allocations. This flag must be set in order to allocate pinned host
          memory that is accessible to the GPU.

        - :py:obj:`~.CU_CTX_LMEM_RESIZE_TO_MAX`: Instruct CUDA to not reduce
          local memory after resizing local memory for a kernel. This can
          prevent thrashing by local memory allocations when launching many
          kernels with high local memory usage at the cost of potentially
          increased memory usage.   Deprecated: This flag is deprecated and the
          behavior enabled by this flag is now the default and cannot be
          disabled. Instead, the per-thread stack size can be controlled with
          :py:obj:`~.cuCtxSetLimit()`.

        - :py:obj:`~.CU_CTX_COREDUMP_ENABLE`: If GPU coredumps have not been
          enabled globally with :py:obj:`~.cuCoredumpSetAttributeGlobal` or
          environment variables, this flag can be set during context creation
          to instruct CUDA to create a coredump if this context raises an
          exception during execution. These environment variables are described
          in the CUDA-GDB user guide under the "GPU core dump support" section.
          The initial attributes will be taken from the global attributes at
          the time of context creation. The other attributes that control
          coredump output can be modified by calling
          :py:obj:`~.cuCoredumpSetAttribute` from the created context after it
          becomes current. This flag is not supported when CUDA context is
          created in CIG(CUDA in Graphics) mode.

        - :py:obj:`~.CU_CTX_USER_COREDUMP_ENABLE`: If user-triggered GPU
          coredumps have not been enabled globally with
          :py:obj:`~.cuCoredumpSetAttributeGlobal` or environment variables,
          this flag can be set during context creation to instruct CUDA to
          create a coredump if data is written to a certain pipe that is
          present in the OS space. These environment variables are described in
          the CUDA-GDB user guide under the "GPU core dump support" section. It
          is important to note that the pipe name `must` be set with
          :py:obj:`~.cuCoredumpSetAttributeGlobal` before creating the context
          if this flag is used. Setting this flag implies that
          :py:obj:`~.CU_CTX_COREDUMP_ENABLE` is set. The initial attributes
          will be taken from the global attributes at the time of context
          creation. The other attributes that control coredump output can be
          modified by calling :py:obj:`~.cuCoredumpSetAttribute` from the
          created context after it becomes current. Setting this flag on any
          context creation is equivalent to setting the
          :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER` attribute to `true`
          globally. This flag is not supported when CUDA context is created in
          CIG(CUDA in Graphics) mode.

        - :py:obj:`~.CU_CTX_SYNC_MEMOPS`: Ensures that synchronous memory
          operations initiated on this context will always synchronize. See
          further documentation in the section titled "API Synchronization
          behavior" to learn more about cases when synchronous memory
          operations can exhibit asynchronous behavior.

        Context creation will fail with :py:obj:`~.CUDA_ERROR_UNKNOWN` if the
        compute mode of the device is :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`.
        The function :py:obj:`~.cuDeviceGetAttribute()` can be used with
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE` to determine the compute
        mode of the device. The `nvidia-smi` tool can be used to set the
        compute mode for * devices. Documentation for `nvidia-smi` can be
        obtained by passing a -h option to it.

        Context creation will fail with :: CUDA_ERROR_INVALID_VALUE if invalid
        parameter was passed by client to create the CUDA context.

        Context creation in CIG mode will fail with
        :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` if CIG is not supported by the
        device or the driver.

        Parameters
        ----------
        ctxCreateParams : :py:obj:`~.CUctxCreateParams`
            Context creation parameters
        flags : unsigned int
            Context creation flags
        dev : :py:obj:`~.CUdevice`
            Device to create context on

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        pctx : :py:obj:`~.CUcontext`
            Returned context handle of the new context

        See Also
        --------
        :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCoredumpSetAttributeGlobal`, :py:obj:`~.cuCoredumpSetAttribute`, :py:obj:`~.cuCtxSynchronize`
    """


def cuCtxDestroy(ctx):
    """
    cuCtxDestroy(ctx)
     Destroy a CUDA context.

        Destroys the CUDA context specified by `ctx`. The context `ctx` will be
        destroyed regardless of how many threads it is current to. It is the
        responsibility of the calling function to ensure that no API call
        issues using `ctx` while :py:obj:`~.cuCtxDestroy()` is executing.

        Destroys and cleans up all resources associated with the context. It is
        the caller's responsibility to ensure that the context or its resources
        are not accessed or passed in subsequent API calls and doing so will
        result in undefined behavior. These resources include CUDA types
        :py:obj:`~.CUmodule`, :py:obj:`~.CUfunction`, :py:obj:`~.CUstream`,
        :py:obj:`~.CUevent`, :py:obj:`~.CUarray`, :py:obj:`~.CUmipmappedArray`,
        :py:obj:`~.CUtexObject`, :py:obj:`~.CUsurfObject`,
        :py:obj:`~.CUtexref`, :py:obj:`~.CUsurfref`,
        :py:obj:`~.CUgraphicsResource`, :py:obj:`~.CUlinkState`,
        :py:obj:`~.CUexternalMemory` and :py:obj:`~.CUexternalSemaphore`. These
        resources also include memory allocations by :py:obj:`~.cuMemAlloc()`,
        :py:obj:`~.cuMemAllocHost()`, :py:obj:`~.cuMemAllocManaged()` and
        :py:obj:`~.cuMemAllocPitch()`.

        If `ctx` is current to the calling thread then `ctx` will also be
        popped from the current thread's context stack (as though
        :py:obj:`~.cuCtxPopCurrent()` were called). If `ctx` is current to
        other threads, then `ctx` will remain current to those threads, and
        attempting to access `ctx` from those threads will result in the error
        :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`.

        Parameters
        ----------
        ctx : :py:obj:`~.CUcontext`
            Context to destroy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`

        Notes
        -----
        :py:obj:`~.cuCtxDestroy()` will not destroy memory allocations by :py:obj:`~.cuMemCreate()`, :py:obj:`~.cuMemAllocAsync()` and :py:obj:`~.cuMemAllocFromPoolAsync()`. These memory allocations are not associated with any CUDA context and need to be destroyed explicitly.
    """


def cuCtxDetach(ctx):
    """
    cuCtxDetach(ctx)
     Decrement a context's usage-count.

        [Deprecated]

        Note that this function is deprecated and should not be used.

        Decrements the usage count of the context `ctx`, and destroys the
        context if the usage count goes to 0. The context must be a handle that
        was passed back by :py:obj:`~.cuCtxCreate()` or
        :py:obj:`~.cuCtxAttach()`, and must be current to the calling thread.

        Parameters
        ----------
        ctx : :py:obj:`~.CUcontext`
            Context to destroy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """


def cuCtxDisablePeerAccess(peerContext):
    """
    cuCtxDisablePeerAccess(peerContext)
     Disables direct access to memory allocations in a peer context and unregisters any registered allocations.

        Returns :py:obj:`~.CUDA_ERROR_PEER_ACCESS_NOT_ENABLED` if direct peer
        access has not yet been enabled from `peerContext` to the current
        context.

        Returns :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` if there is no current
        context, or if `peerContext` is not a valid context.

        Parameters
        ----------
        peerContext : :py:obj:`~.CUcontext`
            Peer context to disable direct access to

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_NOT_ENABLED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,

        See Also
        --------
        :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cudaDeviceDisablePeerAccess`
    """


def cuCtxEnablePeerAccess(peerContext, Flags):
    """
    cuCtxEnablePeerAccess(peerContext, unsigned int Flags)
     Enables direct access to memory allocations in a peer context.

        If both the current context and `peerContext` are on devices which
        support unified addressing (as may be queried using
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING`) and same major
        compute capability, then on success all allocations from `peerContext`
        will immediately be accessible by the current context. See
        :py:obj:`~.Unified Addressing` for additional details.

        Note that access granted by this call is unidirectional and that in
        order to access memory from the current context in `peerContext`, a
        separate symmetric call to :py:obj:`~.cuCtxEnablePeerAccess()` is
        required.

        Note that there are both device-wide and system-wide limitations per
        system configuration, as noted in the CUDA Programming Guide under the
        section "Peer-to-Peer Memory Access".

        Returns :py:obj:`~.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED` if
        :py:obj:`~.cuDeviceCanAccessPeer()` indicates that the
        :py:obj:`~.CUdevice` of the current context cannot directly access
        memory from the :py:obj:`~.CUdevice` of `peerContext`.

        Returns :py:obj:`~.CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED` if direct
        access of `peerContext` from the current context has already been
        enabled.

        Returns :py:obj:`~.CUDA_ERROR_TOO_MANY_PEERS` if direct peer access is
        not possible because hardware resources required for peer access have
        been exhausted.

        Returns :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` if there is no current
        context, `peerContext` is not a valid context, or if the current
        context is `peerContext`.

        Returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if `Flags` is not 0.

        Parameters
        ----------
        peerContext : :py:obj:`~.CUcontext`
            Peer context to enable direct access to from the current context
        Flags : unsigned int
            Reserved for future use and must be set to 0

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED`, :py:obj:`~.CUDA_ERROR_TOO_MANY_PEERS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cuCtxDisablePeerAccess`, :py:obj:`~.cudaDeviceEnablePeerAccess`
    """


def cuCtxFromGreenCtx(hCtx):
    """
    cuCtxFromGreenCtx(hCtx)
     Converts a green context into the primary context.

        The API converts a green context into the primary context returned in
        `pContext`. It is important to note that the converted context
        `pContext` is a normal primary context but with the resources of the
        specified green context `hCtx`. Once converted, it can then be used to
        set the context current with :py:obj:`~.cuCtxSetCurrent` or with any of
        the CUDA APIs that accept a CUcontext parameter.

        Users are expected to call this API before calling any CUDA APIs that
        accept a CUcontext. Failing to do so will result in the APIs returning
        :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`.

        Parameters
        ----------
        hCtx : :py:obj:`~.CUgreenCtx`
            Green context to convert

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pContext : :py:obj:`~.CUcontext`
            Returned primary context with green context resources

        See Also
        --------
        :py:obj:`~.cuGreenCtxCreate`
    """


def cuCtxGetApiVersion(ctx):
    """
    cuCtxGetApiVersion(ctx)
     Gets the context's API version.

        Returns a version number in `version` corresponding to the capabilities
        of the context (e.g. 3010 or 3020), which library developers can use to
        direct callers to a specific API version. If `ctx` is NULL, returns the
        API version used to create the currently bound context.

        Note that new API versions are only introduced when context
        capabilities are changed that break binary compatibility, so the API
        version and driver version may be different. For example, it is valid
        for the API version to be 3020 while the driver version is 4020.

        Parameters
        ----------
        ctx : :py:obj:`~.CUcontext`
            Context to check

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        version : unsigned int
            Pointer to version

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """


def cuCtxGetCacheConfig():
    """
    cuCtxGetCacheConfig()
     Returns the preferred cache configuration for the current context.

        On devices where the L1 cache and shared memory use the same hardware
        resources, this function returns through `pconfig` the preferred cache
        configuration for the current context. This is only a preference. The
        driver will use the requested configuration if possible, but it is free
        to choose a different configuration if required to execute functions.

        This will return a `pconfig` of :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`
        on devices where the size of the L1 cache and shared memory are fixed.

        The supported cache configurations are:

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`: no preference for shared
          memory or L1 (default)

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_SHARED`: prefer larger shared memory
          and smaller L1 cache

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_L1`: prefer larger L1 cache and
          smaller shared memory

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_EQUAL`: prefer equal sized L1 cache
          and shared memory

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pconfig : :py:obj:`~.CUfunc_cache`
            Returned cache configuration

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceGetCacheConfig`
    """


def cuCtxGetCurrent():
    """
    cuCtxGetCurrent()
     Returns the CUDA context bound to the calling CPU thread.

        Returns in `*pctx` the CUDA context bound to the calling CPU thread. If
        no context is bound to the calling CPU thread then `*pctx` is set to
        NULL and :py:obj:`~.CUDA_SUCCESS` is returned.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`,
        pctx : :py:obj:`~.CUcontext`
            Returned context handle

        See Also
        --------
        :py:obj:`~.cuCtxSetCurrent`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cudaGetDevice`
    """


def cuCtxGetDevResource(hCtx, typename: 'CUdevResourceType'):
    """
    cuCtxGetDevResource(hCtx, typename: CUdevResourceType)
     Get context resources.

        Get the `typename` resources available to the context represented by
        `hCtx`  Note: The API is not supported on 32-bit platforms.

        Parameters
        ----------
        hCtx : :py:obj:`~.CUcontext`
            Context to get resource for
        typename : :py:obj:`~.CUdevResourceType`
            Type of resource to retrieve

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_TYPE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`
        resource : :py:obj:`~.CUdevResource`
            Output pointer to a :py:obj:`~.CUdevResource` structure

        See Also
        --------
        :py:obj:`~.cuDevResourceGenerateDesc`
    """


def cuCtxGetDevice():
    """
    cuCtxGetDevice()
     Returns the device handle for the current context.

        Returns in `*device` the handle of the current context's device.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        device : :py:obj:`~.CUdevice`
            Returned device handle for the current context

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaGetDevice`
    """


def cuCtxGetExecAffinity(typename: 'CUexecAffinityType'):
    """
    cuCtxGetExecAffinity(typename: CUexecAffinityType)
     Returns the execution affinity setting for the current context.

        Returns in `*pExecAffinity` the current value of `typename`. The
        supported :py:obj:`~.CUexecAffinityType` values are:

        - :py:obj:`~.CU_EXEC_AFFINITY_TYPE_SM_COUNT`: number of SMs the context
          is limited to use.

        Parameters
        ----------
        typename : :py:obj:`~.CUexecAffinityType`
            Execution affinity type to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY`
        pExecAffinity : :py:obj:`~.CUexecAffinityParam`
            Returned execution affinity

        See Also
        --------
        :py:obj:`~.CUexecAffinityParam`
    """


def cuCtxGetFlags():
    """
    cuCtxGetFlags()
     Returns the flags for the current context.

        Returns in `*flags` the flags of the current context. See
        :py:obj:`~.cuCtxCreate` for flag values.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        flags : unsigned int
            Pointer to store flags of current context

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetCurrent`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuCtxSetFlags`, :py:obj:`~.cudaGetDeviceFlags`
    """


def cuCtxGetId(ctx):
    """
    cuCtxGetId(ctx)
     Returns the unique Id associated with the context supplied.

        Returns in `ctxId` the unique Id which is associated with a given
        context. The Id is unique for the life of the program for this instance
        of CUDA. If context is supplied as NULL and there is one current, the
        Id of the current context is returned.

        Parameters
        ----------
        ctx : :py:obj:`~.CUcontext`
            Context for which to obtain the Id

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        ctxId : unsigned long long
            Pointer to store the Id of the context

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPushCurrent`
    """


def cuCtxGetLimit(limit: 'CUlimit'):
    """
    cuCtxGetLimit(limit: CUlimit)
     Returns resource limits.

        Returns in `*pvalue` the current size of `limit`. The supported
        :py:obj:`~.CUlimit` values are:

        - :py:obj:`~.CU_LIMIT_STACK_SIZE`: stack size in bytes of each GPU
          thread.

        - :py:obj:`~.CU_LIMIT_PRINTF_FIFO_SIZE`: size in bytes of the FIFO used
          by the :py:obj:`~.printf()` device system call.

        - :py:obj:`~.CU_LIMIT_MALLOC_HEAP_SIZE`: size in bytes of the heap used
          by the :py:obj:`~.malloc()` and :py:obj:`~.free()` device system
          calls.

        - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH`: maximum grid depth at
          which a thread can issue the device runtime call
          :py:obj:`~.cudaDeviceSynchronize()` to wait on child grid launches to
          complete.

        - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT`: maximum number
          of outstanding device runtime launches that can be made from this
          context.

        - :py:obj:`~.CU_LIMIT_MAX_L2_FETCH_GRANULARITY`: L2 cache fetch
          granularity.

        - :py:obj:`~.CU_LIMIT_PERSISTING_L2_CACHE_SIZE`: Persisting L2 cache
          size in bytes

        Parameters
        ----------
        limit : :py:obj:`~.CUlimit`
            Limit to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT`
        pvalue : int
            Returned size of limit

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceGetLimit`
    """


def cuCtxGetSharedMemConfig():
    """
    cuCtxGetSharedMemConfig()
     Returns the current shared memory configuration for the current context.

        [Deprecated]

        This function will return in `pConfig` the current size of shared
        memory banks in the current context. On devices with configurable
        shared memory banks, :py:obj:`~.cuCtxSetSharedMemConfig` can be used to
        change this setting, so that all subsequent kernel launches will by
        default use the new bank size. When :py:obj:`~.cuCtxGetSharedMemConfig`
        is called on devices without configurable shared memory, it will return
        the fixed bank size of the hardware.

        The returned bank configurations can be either:

        - :py:obj:`~.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE`: shared memory
          bank width is four bytes.

        - :py:obj:`~.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE`: shared memory
          bank width will eight bytes.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pConfig : :py:obj:`~.CUsharedconfig`
            returned shared memory configuration

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceGetSharedMemConfig`
    """


def cuCtxGetStreamPriorityRange():
    """
    cuCtxGetStreamPriorityRange()
     Returns numerical values that correspond to the least and greatest stream priorities.

        Returns in `*leastPriority` and `*greatestPriority` the numerical
        values that correspond to the least and greatest stream priorities
        respectively. Stream priorities follow a convention where lower numbers
        imply greater priorities. The range of meaningful stream priorities is
        given by [`*greatestPriority`, `*leastPriority`]. If the user attempts
        to create a stream with a priority value that is outside the meaningful
        range as specified by this API, the priority is automatically clamped
        down or up to either `*leastPriority` or `*greatestPriority`
        respectively. See :py:obj:`~.cuStreamCreateWithPriority` for details on
        creating a priority stream. A NULL may be passed in for
        `*leastPriority` or `*greatestPriority` if the value is not desired.

        This function will return '0' in both `*leastPriority` and
        `*greatestPriority` if the current context's device does not support
        stream priorities (see :py:obj:`~.cuDeviceGetAttribute`).

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        leastPriority : int
            Pointer to an int in which the numerical value for least stream
            priority is returned
        greatestPriority : int
            Pointer to an int in which the numerical value for greatest stream
            priority is returned

        See Also
        --------
        :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceGetStreamPriorityRange`
    """


def cuCtxPopCurrent():
    """
    cuCtxPopCurrent()
     Pops the current CUDA context from the current CPU thread.

        Pops the current CUDA context from the CPU thread and passes back the
        old context handle in `*pctx`. That context may then be made current to
        a different CPU thread by calling :py:obj:`~.cuCtxPushCurrent()`.

        If a context was current to the CPU thread before
        :py:obj:`~.cuCtxCreate()` or :py:obj:`~.cuCtxPushCurrent()` was called,
        this function makes that context current to the CPU thread again.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`
        pctx : :py:obj:`~.CUcontext`
            Returned popped context handle

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """


def cuCtxPushCurrent(ctx):
    """
    cuCtxPushCurrent(ctx)
     Pushes a context on the current CPU thread.

        Pushes the given context `ctx` onto the CPU thread's stack of current
        contexts. The specified context becomes the CPU thread's current
        context, so all CUDA functions that operate on the current context are
        affected.

        The previous current context may be made current again by calling
        :py:obj:`~.cuCtxDestroy()` or :py:obj:`~.cuCtxPopCurrent()`.

        Parameters
        ----------
        ctx : :py:obj:`~.CUcontext`
            Context to push

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """


def cuCtxRecordEvent(hCtx, hEvent):
    """
    cuCtxRecordEvent(hCtx, hEvent)
     Records an event.

        Captures in `hEvent` all the activities of the context `hCtx` at the
        time of this call. `hEvent` and `hCtx` must be from the same CUDA
        context, otherwise :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` will be
        returned. Calls such as :py:obj:`~.cuEventQuery()` or
        :py:obj:`~.cuCtxWaitEvent()` will then examine or wait for completion
        of the work that was captured. Uses of `hCtx` after this call do not
        modify `hEvent`. If the context passed to `hCtx` is the primary
        context, `hEvent` will capture all the activities of the primary
        context and its green contexts. If the context passed to `hCtx` is a
        context converted from green context via
        :py:obj:`~.cuCtxFromGreenCtx()`, `hEvent` will capture only the
        activities of the green context.

        Parameters
        ----------
        hCtx : :py:obj:`~.CUcontext`
            Context to record event for
        hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to record

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED`

        See Also
        --------
        :py:obj:`~.cuCtxWaitEvent`, :py:obj:`~.cuGreenCtxRecordEvent`, :py:obj:`~.cuGreenCtxWaitEvent`, :py:obj:`~.cuEventRecord`

        Notes
        -----
        The API will return :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED` if the specified context `hCtx` has a stream in the capture mode. In such a case, the call will invalidate all the conflicting captures.
    """


def cuCtxResetPersistingL2Cache():
    """
    cuCtxResetPersistingL2Cache()
     Resets all persisting lines in cache to normal status.

        :py:obj:`~.cuCtxResetPersistingL2Cache` Resets all persisting lines in
        cache to normal status. Takes effect on function return.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.CUaccessPolicyWindow`
    """


def cuCtxSetCacheConfig(config: 'CUfunc_cache'):
    """
    cuCtxSetCacheConfig(config: CUfunc_cache)
     Sets the preferred cache configuration for the current context.

        On devices where the L1 cache and shared memory use the same hardware
        resources, this sets through `config` the preferred cache configuration
        for the current context. This is only a preference. The driver will use
        the requested configuration if possible, but it is free to choose a
        different configuration if required to execute the function. Any
        function preference set via :py:obj:`~.cuFuncSetCacheConfig()` or
        :py:obj:`~.cuKernelSetCacheConfig()` will be preferred over this
        context-wide setting. Setting the context-wide cache configuration to
        :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE` will cause subsequent kernel
        launches to prefer to not change the cache configuration unless
        required to launch the kernel.

        This setting does nothing on devices where the size of the L1 cache and
        shared memory are fixed.

        Launching a kernel with a different preference than the most recent
        preference setting may insert a device-side synchronization point.

        The supported cache configurations are:

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`: no preference for shared
          memory or L1 (default)

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_SHARED`: prefer larger shared memory
          and smaller L1 cache

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_L1`: prefer larger L1 cache and
          smaller shared memory

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_EQUAL`: prefer equal sized L1 cache
          and shared memory

        Parameters
        ----------
        config : :py:obj:`~.CUfunc_cache`
            Requested cache configuration

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceSetCacheConfig`, :py:obj:`~.cuKernelSetCacheConfig`
    """


def cuCtxSetCurrent(ctx):
    """
    cuCtxSetCurrent(ctx)
     Binds the specified CUDA context to the calling CPU thread.

        Binds the specified CUDA context to the calling CPU thread. If `ctx` is
        NULL then the CUDA context previously bound to the calling CPU thread
        is unbound and :py:obj:`~.CUDA_SUCCESS` is returned.

        If there exists a CUDA context stack on the calling CPU thread, this
        will replace the top of that stack with `ctx`. If `ctx` is NULL then
        this will be equivalent to popping the top of the calling CPU thread's
        CUDA context stack (or a no-op if the calling CPU thread's CUDA context
        stack is empty).

        Parameters
        ----------
        ctx : :py:obj:`~.CUcontext`
            Context to bind to the calling CPU thread

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

        See Also
        --------
        :py:obj:`~.cuCtxGetCurrent`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cudaSetDevice`
    """


def cuCtxSetFlags(flags):
    """
    cuCtxSetFlags(unsigned int flags)
     Sets the flags for the current context.

        Sets the flags for the current context overwriting previously set ones.
        See :py:obj:`~.cuDevicePrimaryCtxSetFlags` for flag values.

        Parameters
        ----------
        flags : unsigned int
            Flags to set on the current context

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetCurrent`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cudaGetDeviceFlags`, :py:obj:`~.cuDevicePrimaryCtxSetFlags`,
    """


def cuCtxSetLimit(limit: 'CUlimit', value):
    """
    cuCtxSetLimit(limit: CUlimit, size_t value)
     Set resource limits.

        Setting `limit` to `value` is a request by the application to update
        the current limit maintained by the context. The driver is free to
        modify the requested value to meet h/w requirements (this could be
        clamping to minimum or maximum values, rounding up to nearest element
        size, etc). The application can use :py:obj:`~.cuCtxGetLimit()` to find
        out exactly what the limit has been set to.

        Setting each :py:obj:`~.CUlimit` has its own specific restrictions, so
        each is discussed here.

        - :py:obj:`~.CU_LIMIT_STACK_SIZE` controls the stack size in bytes of
          each GPU thread. The driver automatically increases the per-thread
          stack size for each kernel launch as needed. This size isn't reset
          back to the original value after each launch. Setting this value will
          take effect immediately, and if necessary, the device will block
          until all preceding requested tasks are complete.

        - :py:obj:`~.CU_LIMIT_PRINTF_FIFO_SIZE` controls the size in bytes of
          the FIFO used by the :py:obj:`~.printf()` device system call. Setting
          :py:obj:`~.CU_LIMIT_PRINTF_FIFO_SIZE` must be performed before
          launching any kernel that uses the :py:obj:`~.printf()` device system
          call, otherwise :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be
          returned.

        - :py:obj:`~.CU_LIMIT_MALLOC_HEAP_SIZE` controls the size in bytes of
          the heap used by the :py:obj:`~.malloc()` and :py:obj:`~.free()`
          device system calls. Setting :py:obj:`~.CU_LIMIT_MALLOC_HEAP_SIZE`
          must be performed before launching any kernel that uses the
          :py:obj:`~.malloc()` or :py:obj:`~.free()` device system calls,
          otherwise :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned.

        - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH` controls the maximum
          nesting depth of a grid at which a thread can safely call
          :py:obj:`~.cudaDeviceSynchronize()`. Setting this limit must be
          performed before any launch of a kernel that uses the device runtime
          and calls :py:obj:`~.cudaDeviceSynchronize()` above the default sync
          depth, two levels of grids. Calls to
          :py:obj:`~.cudaDeviceSynchronize()` will fail with error code
          :py:obj:`~.cudaErrorSyncDepthExceeded` if the limitation is violated.
          This limit can be set smaller than the default or up the maximum
          launch depth of 24. When setting this limit, keep in mind that
          additional levels of sync depth require the driver to reserve large
          amounts of device memory which can no longer be used for user
          allocations. If these reservations of device memory fail,
          :py:obj:`~.cuCtxSetLimit()` will return
          :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, and the limit can be reset to a
          lower value. This limit is only applicable to devices of compute
          capability < 9.0. Attempting to set this limit on devices of other
          compute capability versions will result in the error
          :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT` being returned.

        - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT` controls the
          maximum number of outstanding device runtime launches that can be
          made from the current context. A grid is outstanding from the point
          of launch up until the grid is known to have been completed. Device
          runtime launches which violate this limitation fail and return
          :py:obj:`~.cudaErrorLaunchPendingCountExceeded` when
          :py:obj:`~.cudaGetLastError()` is called after launch. If more
          pending launches than the default (2048 launches) are needed for a
          module using the device runtime, this limit can be increased. Keep in
          mind that being able to sustain additional pending launches will
          require the driver to reserve larger amounts of device memory upfront
          which can no longer be used for allocations. If these reservations
          fail, :py:obj:`~.cuCtxSetLimit()` will return
          :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, and the limit can be reset to a
          lower value. This limit is only applicable to devices of compute
          capability 3.5 and higher. Attempting to set this limit on devices of
          compute capability less than 3.5 will result in the error
          :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT` being returned.

        - :py:obj:`~.CU_LIMIT_MAX_L2_FETCH_GRANULARITY` controls the L2 cache
          fetch granularity. Values can range from 0B to 128B. This is purely a
          performance hint and it can be ignored or clamped depending on the
          platform.

        - :py:obj:`~.CU_LIMIT_PERSISTING_L2_CACHE_SIZE` controls size in bytes
          available for persisting L2 cache. This is purely a performance hint
          and it can be ignored or clamped depending on the platform.

        Parameters
        ----------
        limit : :py:obj:`~.CUlimit`
            Limit to set
        value : size_t
            Size of limit

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceSetLimit`
    """


def cuCtxSetSharedMemConfig(config: 'CUsharedconfig'):
    """
    cuCtxSetSharedMemConfig(config: CUsharedconfig)
     Sets the shared memory configuration for the current context.

        [Deprecated]

        On devices with configurable shared memory banks, this function will
        set the context's shared memory bank size which is used for subsequent
        kernel launches.

        Changed the shared memory configuration between launches may insert a
        device side synchronization point between those launches.

        Changing the shared memory bank size will not increase shared memory
        usage or affect occupancy of kernels, but may have major effects on
        performance. Larger bank sizes will allow for greater potential
        bandwidth to shared memory, but will change what kinds of accesses to
        shared memory will result in bank conflicts.

        This function will do nothing on devices with fixed shared memory bank
        size.

        The supported bank configurations are:

        - :py:obj:`~.CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE`: set bank width to
          the default initial setting (currently, four bytes).

        - :py:obj:`~.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE`: set shared
          memory bank width to be natively four bytes.

        - :py:obj:`~.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE`: set shared
          memory bank width to be natively eight bytes.

        Parameters
        ----------
        config : :py:obj:`~.CUsharedconfig`
            requested shared memory configuration

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceSetSharedMemConfig`
    """


def cuCtxSynchronize():
    """
    cuCtxSynchronize()
     Block for the current context's tasks to complete.

        Blocks until the current context has completed all preceding requested
        tasks. If the current context is the primary context, green contexts
        that have been created will also be synchronized.
        :py:obj:`~.cuCtxSynchronize()` returns an error if one of the preceding
        tasks failed. If the context was created with the
        :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` flag, the CPU thread will block
        until the GPU context has finished its work.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cudaDeviceSynchronize`
    """


def cuCtxWaitEvent(hCtx, hEvent):
    """
    cuCtxWaitEvent(hCtx, hEvent)
     Make a context wait on an event.

        Makes all future work submitted to context `hCtx` wait for all work
        captured in `hEvent`. The synchronization will be performed on the
        device and will not block the calling CPU thread. See
        :py:obj:`~.cuCtxRecordEvent()` for details on what is captured by an
        event. If the context passed to `hCtx` is the primary context, the
        primary context and its green contexts will wait for `hEvent`. If the
        context passed to `hCtx` is a context converted from green context via
        :py:obj:`~.cuCtxFromGreenCtx()`, the green context will wait for
        `hEvent`.

        Parameters
        ----------
        hCtx : :py:obj:`~.CUcontext`
            Context to wait
        hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to wait on

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED`

        See Also
        --------
        :py:obj:`~.cuCtxRecordEvent`, :py:obj:`~.cuGreenCtxRecordEvent`, :py:obj:`~.cuGreenCtxWaitEvent`, :py:obj:`~.cuStreamWaitEvent`

        Notes
        -----
        `hEvent` may be from a different context or device than `hCtx`.

        The API will return :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED` and invalidate the capture if the specified event `hEvent` is part of an ongoing capture sequence or if the specified context `hCtx` has a stream in the capture mode.
    """


def cuDestroyExternalMemory(extMem):
    """
    cuDestroyExternalMemory(extMem)
     Destroys an external memory object.

        Destroys the specified external memory object. Any existing buffers and
        CUDA mipmapped arrays mapped onto this object must no longer be used
        and must be explicitly freed using :py:obj:`~.cuMemFree` and
        :py:obj:`~.cuMipmappedArrayDestroy` respectively.

        Parameters
        ----------
        extMem : :py:obj:`~.CUexternalMemory`
            External memory object to be destroyed

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuImportExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedBuffer`, :py:obj:`~.cuExternalMemoryGetMappedMipmappedArray`
    """


def cuDestroyExternalSemaphore(extSem):
    """
    cuDestroyExternalSemaphore(extSem)
     Destroys an external semaphore.

        Destroys an external semaphore object and releases any references to
        the underlying resource. Any outstanding signals or waits must have
        completed before the semaphore is destroyed.

        Parameters
        ----------
        extSem : :py:obj:`~.CUexternalSemaphore`
            External semaphore to be destroyed

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """


def cuDevResourceGenerateDesc(resources: 'Optional[Tuple[CUdevResource] | List[CUdevResource]]', nbResources):
    """
    cuDevResourceGenerateDesc(resources: Optional[Tuple[CUdevResource] | List[CUdevResource]], unsigned int nbResources)
     Generate a resource descriptor.

        Generates a single resource descriptor with the set of resources
        specified in `resources`. The generated resource descriptor is
        necessary for the creation of green contexts via the
        :py:obj:`~.cuGreenCtxCreate` API. Resources of the same type can be
        passed in, provided they meet the requirements as noted below.

        A successful API call must have:

        - A valid output pointer for the `phDesc` descriptor as well as a valid
          array of `resources` pointers, with the array size passed in
          `nbResources`. If multiple resources are provided in `resources`, the
          device they came from must be the same, otherwise
          CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION is returned. If multiple
          resources are provided in `resources` and they are of type
          :py:obj:`~.CU_DEV_RESOURCE_TYPE_SM`, they must be outputs (whether
          `result` or `remaining`) from the same split API instance, otherwise
          CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION is returned.

        Note: The API is not supported on 32-bit platforms.

        Parameters
        ----------
        resources : List[:py:obj:`~.CUdevResource`]
            Array of resources to be included in the descriptor
        nbResources : unsigned int
            Number of resources passed in `resources`

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_TYPE`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION`
        phDesc : :py:obj:`~.CUdevResourceDesc`
            Output descriptor

        See Also
        --------
        :py:obj:`~.cuDevSmResourceSplitByCount`
    """


def cuDevSmResourceSplitByCount(nbGroups, input_: 'Optional[CUdevResource]', useFlags, minCount):
    """
    cuDevSmResourceSplitByCount(unsigned int nbGroups, CUdevResource input_: Optional[CUdevResource], unsigned int useFlags, unsigned int minCount)
     Splits `CU_DEV_RESOURCE_TYPE_SM` resources.

        Splits `CU_DEV_RESOURCE_TYPE_SM` resources into `nbGroups`, adhering to
        the minimum SM count specified in `minCount` and the usage flags in
        `useFlags`. If `result` is NULL, the API simulates a split and provides
        the amount of groups that would be created in `nbGroups`. Otherwise,
        `nbGroups` must point to the amount of elements in `result` and on
        return, the API will overwrite `nbGroups` with the amount actually
        created. The groups are written to the array in `result`. `nbGroups`
        can be less than the total amount if a smaller number of groups is
        needed.

        This API is used to spatially partition the input resource. The input
        resource needs to come from one of :py:obj:`~.cuDeviceGetDevResource`,
        :py:obj:`~.cuCtxGetDevResource`, or
        :py:obj:`~.cuGreenCtxGetDevResource`. A limitation of the API is that
        the output results cannot be split again without first creating a
        descriptor and a green context with that descriptor.

        When creating the groups, the API will take into account the
        performance and functional characteristics of the input resource, and
        guarantee a split that will create a disjoint set of symmetrical
        partitions. This may lead to fewer groups created than purely dividing
        the total SM count by the `minCount` due to cluster requirements or
        alignment and granularity requirements for the minCount.

        The `remainder` set does not have the same functional or performance
        guarantees as the groups in `result`. Its use should be carefully
        planned and future partitions of the `remainder` set are discouraged.

        The following flags are supported:

        - `CU_DEV_SM_RESOURCE_SPLIT_IGNORE_SM_COSCHEDULING` : Lower the minimum
          SM count and alignment, and treat each SM independent of its
          hierarchy. This allows more fine grained partitions but at the cost
          of advanced features (such as large clusters on compute capability
          9.0+).

        - `CU_DEV_SM_RESOURCE_SPLIT_MAX_POTENTIAL_CLUSTER_SIZE` : Compute
          Capability 9.0+ only. Attempt to create groups that may allow for
          maximally sized thread clusters. This can be queried post green
          context creation using
          :py:obj:`~.cuOccupancyMaxPotentialClusterSize`.

        A successful API call must either have:

        - A valid array of `result` pointers of size passed in `nbGroups`, with
          `input` of type `CU_DEV_RESOURCE_TYPE_SM`. Value of `minCount` must
          be between 0 and the SM count specified in `input`. `remaining` may
          be NULL.

        - NULL passed in for `result`, with a valid integer pointer in
          `nbGroups` and `input` of type `CU_DEV_RESOURCE_TYPE_SM`. Value of
          `minCount` must be between 0 and the SM count specified in `input`.
          `remaining` may be NULL. This queries the number of groups that would
          be created by the API.

        Note: The API is not supported on 32-bit platforms.

        Parameters
        ----------
        nbGroups : unsigned int
            This is a pointer, specifying the number of groups that would be or
            should be created as described below.
        input : :py:obj:`~.CUdevResource`
            Input SM resource to be split. Must be a valid
            `CU_DEV_RESOURCE_TYPE_SM` resource.
        useFlags : unsigned int
            Flags specifying how these partitions are used or which constraints
            to abide by when splitting the input. Zero is valid for default
            behavior.
        minCount : unsigned int
            Minimum number of SMs required

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_TYPE`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION`
        result : List[:py:obj:`~.CUdevResource`]
            Output array of `None` resources. Can be NULL to query the number
            of groups.
        nbGroups : unsigned int
            This is a pointer, specifying the number of groups that would be or
            should be created as described below.
        remaining : :py:obj:`~.CUdevResource`
            If the input resource cannot be cleanly split among `nbGroups`, the
            remaining is placed in here. Can be ommitted (NULL) if the user
            does not need the remaining set.

        See Also
        --------
        :py:obj:`~.cuGreenCtxGetDevResource`, :py:obj:`~.cuCtxGetDevResource`, :py:obj:`~.cuDeviceGetDevResource`
    """


def cuDeviceCanAccessPeer(dev, peerDev):
    """
    cuDeviceCanAccessPeer(dev, peerDev)
     Queries if a device may directly access a peer device's memory.

        Returns in `*canAccessPeer` a value of 1 if contexts on `dev` are
        capable of directly accessing memory from contexts on `peerDev` and 0
        otherwise. If direct access of `peerDev` from `dev` is possible, then
        access may be enabled on two specific contexts by calling
        :py:obj:`~.cuCtxEnablePeerAccess()`.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device from which allocations on `peerDev` are to be directly
            accessed.
        peerDev : :py:obj:`~.CUdevice`
            Device on which the allocations to be directly accessed by `dev`
            reside.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        canAccessPeer : int
            Returned access capability

        See Also
        --------
        :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cuCtxDisablePeerAccess`, :py:obj:`~.cudaDeviceCanAccessPeer`
    """


def cuDeviceComputeCapability(dev):
    """
    cuDeviceComputeCapability(dev)
     Returns the compute capability of the device.

        [Deprecated]

        This function was deprecated as of CUDA 5.0 and its functionality
        superseded by :py:obj:`~.cuDeviceGetAttribute()`.

        Returns in `*major` and `*minor` the major and minor revision numbers
        that define the compute capability of the device `dev`.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device handle

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        major : int
            Major revision number
        minor : int
            Minor revision number

        See Also
        --------
        :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`
    """


def cuDeviceGet(ordinal):
    """
    cuDeviceGet(int ordinal)
     Returns a handle to a compute device.

        Returns in `*device` a device handle given an ordinal in the range [0,
        :py:obj:`~.cuDeviceGetCount()`-1].

        Parameters
        ----------
        ordinal : int
            Device number to get handle for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        device : :py:obj:`~.CUdevice`
            Returned device handle

        See Also
        --------
        :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`
    """


def cuDeviceGetAttribute(attrib: 'CUdevice_attribute', dev):
    """
    cuDeviceGetAttribute(attrib: CUdevice_attribute, dev)
     Returns information about the device.

        Returns in `*pi` the integer value of the attribute `attrib` on device
        `dev`. The supported attributes are:

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK`: Maximum number
          of threads per block;

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X`: Maximum x-dimension
          of a block

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y`: Maximum y-dimension
          of a block

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z`: Maximum z-dimension
          of a block

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X`: Maximum x-dimension
          of a grid

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y`: Maximum y-dimension
          of a grid

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z`: Maximum z-dimension
          of a grid

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK`: Maximum
          amount of shared memory available to a thread block in bytes

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY`: Memory
          available on device for constant variables in a CUDA C kernel in
          bytes

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_WARP_SIZE`: Warp size in threads

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`: Maximum pitch in bytes
          allowed by the memory copy functions that involve memory regions
          allocated through :py:obj:`~.cuMemAllocPitch()`

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH`: Maximum 1D
          texture width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH`:
          Maximum width for a 1D texture bound to linear memory

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH`:
          Maximum mipmapped 1D texture width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH`: Maximum 2D
          texture width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT`: Maximum 2D
          texture height

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH`:
          Maximum width for a 2D texture bound to linear memory

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT`:
          Maximum height for a 2D texture bound to linear memory

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH`:
          Maximum pitch in bytes for a 2D texture bound to linear memory

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH`:
          Maximum mipmapped 2D texture width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT`:
          Maximum mipmapped 2D texture height

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH`: Maximum 3D
          texture width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT`: Maximum 3D
          texture height

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH`: Maximum 3D
          texture depth

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE`:
          Alternate maximum 3D texture width, 0 if no alternate maximum 3D
          texture size is supported

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE`:
          Alternate maximum 3D texture height, 0 if no alternate maximum 3D
          texture size is supported

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE`:
          Alternate maximum 3D texture depth, 0 if no alternate maximum 3D
          texture size is supported

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH`: Maximum
          cubemap texture width or height

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH`:
          Maximum 1D layered texture width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS`:
          Maximum layers in a 1D layered texture

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH`:
          Maximum 2D layered texture width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT`:
          Maximum 2D layered texture height

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS`:
          Maximum layers in a 2D layered texture

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH`:
          Maximum cubemap layered texture width or height

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS`:
          Maximum layers in a cubemap layered texture

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH`: Maximum 1D
          surface width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH`: Maximum 2D
          surface width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT`: Maximum 2D
          surface height

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH`: Maximum 3D
          surface width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT`: Maximum 3D
          surface height

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH`: Maximum 3D
          surface depth

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH`:
          Maximum 1D layered surface width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS`:
          Maximum layers in a 1D layered surface

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH`:
          Maximum 2D layered surface width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT`:
          Maximum 2D layered surface height

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS`:
          Maximum layers in a 2D layered surface

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH`: Maximum
          cubemap surface width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH`:
          Maximum cubemap layered surface width

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS`:
          Maximum layers in a cubemap layered surface

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK`: Maximum
          number of 32-bit registers available to a thread block

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_CLOCK_RATE`: The typical clock
          frequency in kilohertz

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT`: Alignment
          requirement; texture base addresses aligned to
          :py:obj:`~.textureAlign` bytes do not need an offset applied to
          texture fetches

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT`: Pitch
          alignment requirement for 2D texture references bound to pitched
          memory

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_OVERLAP`: 1 if the device can
          concurrently copy memory between host and device while executing a
          kernel, or 0 if not

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT`: Number of
          multiprocessors on the device

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT`: 1 if there is a
          run time limit for kernels executed on the device, or 0 if not

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_INTEGRATED`: 1 if the device is
          integrated with the memory subsystem, or 0 if not

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY`: 1 if the device
          can map host memory into the CUDA address space, or 0 if not

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE`: Compute mode that
          device is currently in. Available modes are as follows:

          - :py:obj:`~.CU_COMPUTEMODE_DEFAULT`: Default mode - Device is not
            restricted and can have multiple CUDA contexts present at a single
            time.

          - :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`: Compute-prohibited mode -
            Device is prohibited from creating new CUDA contexts.

          - :py:obj:`~.CU_COMPUTEMODE_EXCLUSIVE_PROCESS`: Compute-exclusive-
            process mode - Device can have only one context used by a single
            process at a time.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS`: 1 if the device
          supports executing multiple kernels within the same context
          simultaneously, or 0 if not. It is not guaranteed that multiple
          kernels will be resident on the device concurrently so this feature
          should not be relied upon for correctness.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_ECC_ENABLED`: 1 if error correction is
          enabled on the device, 0 if error correction is disabled or not
          supported by the device

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_PCI_BUS_ID`: PCI bus identifier of the
          device

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID`: PCI device (also known
          as slot) identifier of the device

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID`: PCI domain identifier
          of the device

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_TCC_DRIVER`: 1 if the device is using
          a TCC driver. TCC is only available on Tesla hardware running Windows
          Vista or later

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE`: Peak memory clock
          frequency in kilohertz

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH`: Global
          memory bus width in bits

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE`: Size of L2 cache in
          bytes. 0 if the device doesn't have L2 cache

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR`:
          Maximum resident threads per multiprocessor

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING`: 1 if the device
          shares a unified address space with the host, or 0 if not

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR`: Major
          compute capability version number

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR`: Minor
          compute capability version number

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED`: 1 if
          device supports caching globals in L1 cache, 0 if caching globals in
          L1 cache is not supported by the device

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED`: 1 if device
          supports caching locals in L1 cache, 0 if caching locals in L1 cache
          is not supported by the device

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR`:
          Maximum amount of shared memory available to a multiprocessor in
          bytes; this amount is shared by all thread blocks simultaneously
          resident on a multiprocessor

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR`:
          Maximum number of 32-bit registers available to a multiprocessor;
          this number is shared by all thread blocks simultaneously resident on
          a multiprocessor

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY`: 1 if device supports
          allocating managed memory on this system, 0 if allocating managed
          memory is not supported by the device on this system.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD`: 1 if device is on a
          multi-GPU board, 0 if not.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID`: Unique
          identifier for a group of devices associated with the same board.
          Devices on the same multi-GPU board will share the same identifier.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED`: 1 if
          Link between the device and the host supports native atomic
          operations.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO`:
          Ratio of single precision performance (in floating-point operations
          per second) to double precision performance.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`: Device
          supports coherently accessing pageable memory without calling
          cudaHostRegister on it.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`: Device can
          coherently access managed memory concurrently with the CPU.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED`: Device
          supports Compute Preemption.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM`:
          Device can access host registered memory at the same virtual address
          as the CPU.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN`:
          The maximum per block shared memory size supported on this device.
          This is the maximum value that can be opted into when using the
          :py:obj:`~.cuFuncSetAttribute()` or
          :py:obj:`~.cuKernelSetAttribute()` call. For more details see
          :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`:
          Device accesses pageable memory via the host's page tables.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST`:
          The host can directly access managed memory on the device without
          migration.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED`:
          Device supports virtual memory management APIs like
          :py:obj:`~.cuMemAddressReserve`, :py:obj:`~.cuMemCreate`,
          :py:obj:`~.cuMemMap` and related APIs

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED`:
          Device supports exporting memory to a posix file descriptor with
          :py:obj:`~.cuMemExportToShareableHandle`, if requested via
          :py:obj:`~.cuMemCreate`

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED`:
          Device supports exporting memory to a Win32 NT handle with
          :py:obj:`~.cuMemExportToShareableHandle`, if requested via
          :py:obj:`~.cuMemCreate`

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED`:
          Device supports exporting memory to a Win32 KMT handle with
          :py:obj:`~.cuMemExportToShareableHandle`, if requested via
          :py:obj:`~.cuMemCreate`

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR`:
          Maximum number of thread blocks that can reside on a multiprocessor

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED`: Device
          supports compressible memory allocation via :py:obj:`~.cuMemCreate`

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE`: Maximum
          L2 persisting lines capacity setting in bytes

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE`:
          Maximum value of :py:obj:`~.CUaccessPolicyWindow.num_bytes`

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED`:
          Device supports specifying the GPUDirect RDMA flag with
          :py:obj:`~.cuMemCreate`.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK`:
          Amount of shared memory per block reserved by CUDA driver in bytes

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED`: Device
          supports sparse CUDA arrays and sparse CUDA mipmapped arrays.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED`:
          Device supports using the :py:obj:`~.cuMemHostRegister` flag
          :py:obj:`~.CU_MEMHOSTERGISTER_READ_ONLY` to register memory that must
          be mapped as read-only to the GPU

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED`: Device
          supports using the :py:obj:`~.cuMemAllocAsync` and
          :py:obj:`~.cuMemPool` family of APIs

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED`: Device
          supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see
          https://docs.nvidia.com/cuda/gpudirect-rdma for more information)

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS`:
          The returned attribute shall be interpreted as a bitmask, where the
          individual bits are described by the
          :py:obj:`~.CUflushGPUDirectRDMAWritesOptions` enum

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING`:
          GPUDirect RDMA writes to the device do not need to be flushed for
          consumers within the scope indicated by the returned attribute. See
          :py:obj:`~.CUGPUDirectRDMAWritesOrdering` for the numerical values
          returned here.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES`:
          Bitmask of handle types supported with mempool based IPC

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED`:
          Device supports deferred mapping CUDA arrays and CUDA mipmapped
          arrays.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_NUMA_CONFIG`: NUMA configuration of a
          device: value is of type :py:obj:`~.CUdeviceNumaConfig` enum

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_NUMA_ID`: NUMA node ID of the GPU
          memory

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED`: Device supports
          switch multicast and reduction operations.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_PCI_DEVICE_ID`: The combined
          16-bit PCI device ID and 16-bit PCI vendor ID.

        - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_PCI_SUBSYSTEM_ID`: The combined
          16-bit PCI subsystem ID and 16-bit PCI subsystem vendor ID. ID.

        Parameters
        ----------
        attrib : :py:obj:`~.CUdevice_attribute`
            Device attribute to query
        dev : :py:obj:`~.CUdevice`
            Device handle

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        pi : int
            Returned device attribute value

        See Also
        --------
        :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaDeviceGetAttribute`, :py:obj:`~.cudaGetDeviceProperties`
    """


def cuDeviceGetByPCIBusId(pciBusId):
    """
    cuDeviceGetByPCIBusId(char *pciBusId)
     Returns a handle to a compute device.

        Returns in `*device` a device handle given a PCI bus ID string.

        where `domain`, `bus`, `device`, and `function` are all hexadecimal
        values

        Parameters
        ----------
        pciBusId : bytes
            String in one of the following forms:

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        dev : :py:obj:`~.CUdevice`
            Returned device handle

        See Also
        --------
        :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetPCIBusId`, :py:obj:`~.cudaDeviceGetByPCIBusId`
    """


def cuDeviceGetCount():
    """
    cuDeviceGetCount()
     Returns the number of compute-capable devices.

        Returns in `*count` the number of devices with compute capability
        greater than or equal to 2.0 that are available for execution. If there
        is no such device, :py:obj:`~.cuDeviceGetCount()` returns 0.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        count : int
            Returned number of compute-capable devices

        See Also
        --------
        :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaGetDeviceCount`
    """


def cuDeviceGetDefaultMemPool(dev):
    """
    cuDeviceGetDefaultMemPool(dev)
     Returns the default mempool of a device.

        The default mempool of a device contains device memory from that
        device.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            None

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        pool_out : :py:obj:`~.CUmemoryPool`
            None

        See Also
        --------
        :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemPoolTrimTo`, :py:obj:`~.cuMemPoolGetAttribute`, :py:obj:`~.cuMemPoolSetAttribute`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """


def cuDeviceGetDevResource(device, typename: 'CUdevResourceType'):
    """
    cuDeviceGetDevResource(device, typename: CUdevResourceType)
     Get device resources.

        Get the `typename` resources available to the `device`. This may often
        be the starting point for further partitioning or configuring of
        resources.

        Note: The API is not supported on 32-bit platforms.

        Parameters
        ----------
        device : :py:obj:`~.CUdevice`
            Device to get resource for
        typename : :py:obj:`~.CUdevResourceType`
            Type of resource to retrieve

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_TYPE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        resource : :py:obj:`~.CUdevResource`
            Output pointer to a :py:obj:`~.CUdevResource` structure

        See Also
        --------
        :py:obj:`~.cuDevResourceGenerateDesc`
    """


def cuDeviceGetExecAffinitySupport(typename: 'CUexecAffinityType', dev):
    """
    cuDeviceGetExecAffinitySupport(typename: CUexecAffinityType, dev)
     Returns information about the execution affinity support of the device.

        Returns in `*pi` whether execution affinity type `typename` is
        supported by device `dev`. The supported types are:

        - :py:obj:`~.CU_EXEC_AFFINITY_TYPE_SM_COUNT`: 1 if context with limited
          SMs is supported by the device, or 0 if not;

        Parameters
        ----------
        typename : :py:obj:`~.CUexecAffinityType`
            Execution affinity type to query
        dev : :py:obj:`~.CUdevice`
            Device handle

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        pi : int
            1 if the execution affinity type `typename` is supported by the
            device, or 0 if not

        See Also
        --------
        :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`
    """


def cuDeviceGetGraphMemAttribute(device, attr: 'CUgraphMem_attribute'):
    """
    cuDeviceGetGraphMemAttribute(device, attr: CUgraphMem_attribute)
     Query asynchronous allocation attributes related to graphs.

        Valid attributes are:

        - :py:obj:`~.CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT`: Amount of memory, in
          bytes, currently associated with graphs

        - :py:obj:`~.CU_GRAPH_MEM_ATTR_USED_MEM_HIGH`: High watermark of
          memory, in bytes, associated with graphs since the last time it was
          reset. High watermark can only be reset to zero.

        - :py:obj:`~.CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT`: Amount of memory,
          in bytes, currently allocated for use by the CUDA graphs asynchronous
          allocator.

        - :py:obj:`~.CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH`: High watermark of
          memory, in bytes, currently allocated for use by the CUDA graphs
          asynchronous allocator.

        Parameters
        ----------
        device : :py:obj:`~.CUdevice`
            Specifies the scope of the query
        attr : :py:obj:`~.CUgraphMem_attribute`
            attribute to get

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        value : Any
            retrieved value

        See Also
        --------
        :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphAddMemFreeNode`
    """


def cuDeviceGetLuid(dev):
    """
    cuDeviceGetLuid(dev)
     Return an LUID and device node mask for the device.

        Return identifying information (`luid` and `deviceNodeMask`) to allow
        matching device with graphics APIs.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device to get identifier string for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        luid : bytes
            Returned LUID
        deviceNodeMask : unsigned int
            Returned device node mask

        See Also
        --------
        :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaGetDeviceProperties`
    """


def cuDeviceGetMemPool(dev):
    """
    cuDeviceGetMemPool(dev)
     Gets the current mempool for a device.

        Returns the last pool provided to :py:obj:`~.cuDeviceSetMemPool` for
        this device or the device's default memory pool if
        :py:obj:`~.cuDeviceSetMemPool` has never been called. By default the
        current mempool is the default mempool for a device. Otherwise the
        returned pool must have been set with :py:obj:`~.cuDeviceSetMemPool`.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            None

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pool : :py:obj:`~.CUmemoryPool`
            None

        See Also
        --------
        :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuDeviceSetMemPool`
    """


def cuDeviceGetName(length, dev):
    """
    cuDeviceGetName(int length, dev)
     Returns an identifier string for the device.

        Returns an ASCII string identifying the device `dev` in the NULL-
        terminated string pointed to by `name`. `length` specifies the maximum
        length of the string that may be returned.

        Parameters
        ----------
        length : int
            Maximum length of string to store in `name`
        dev : :py:obj:`~.CUdevice`
            Device to get identifier string for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        name : bytes
            Returned identifier string for the device

        See Also
        --------
        :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaGetDeviceProperties`
    """


def cuDeviceGetNvSciSyncAttributes(nvSciSyncAttrList, dev, flags):
    """
    cuDeviceGetNvSciSyncAttributes(nvSciSyncAttrList, dev, int flags)
     Return NvSciSync attributes that this device can support.

        Returns in `nvSciSyncAttrList`, the properties of NvSciSync that this
        CUDA device, `dev` can support. The returned `nvSciSyncAttrList` can be
        used to create an NvSciSync object that matches this device's
        capabilities.

        If NvSciSyncAttrKey_RequiredPerm field in `nvSciSyncAttrList` is
        already set this API will return :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

        The applications should set `nvSciSyncAttrList` to a valid
        NvSciSyncAttrList failing which this API will return
        :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`.

        The `flags` controls how applications intends to use the NvSciSync
        created from the `nvSciSyncAttrList`. The valid flags are:

        - :py:obj:`~.CUDA_NVSCISYNC_ATTR_SIGNAL`, specifies that the
          applications intends to signal an NvSciSync on this CUDA device.

        - :py:obj:`~.CUDA_NVSCISYNC_ATTR_WAIT`, specifies that the applications
          intends to wait on an NvSciSync on this CUDA device.

        At least one of these flags must be set, failing which the API returns
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE`. Both the flags are orthogonal to
        one another: a developer may set both these flags that allows to set
        both wait and signal specific attributes in the same
        `nvSciSyncAttrList`.

        Note that this API updates the input `nvSciSyncAttrList` with values
        equivalent to the following public attribute key-values:
        NvSciSyncAttrKey_RequiredPerm is set to

        - NvSciSyncAccessPerm_SignalOnly if
          :py:obj:`~.CUDA_NVSCISYNC_ATTR_SIGNAL` is set in `flags`.

        - NvSciSyncAccessPerm_WaitOnly if :py:obj:`~.CUDA_NVSCISYNC_ATTR_WAIT`
          is set in `flags`.

        - NvSciSyncAccessPerm_WaitSignal if both
          :py:obj:`~.CUDA_NVSCISYNC_ATTR_WAIT` and
          :py:obj:`~.CUDA_NVSCISYNC_ATTR_SIGNAL` are set in `flags`.
          NvSciSyncAttrKey_PrimitiveInfo is set to

        - NvSciSyncAttrValPrimitiveType_SysmemSemaphore on any valid `device`.

        - NvSciSyncAttrValPrimitiveType_Syncpoint if `device` is a Tegra
          device.

        - NvSciSyncAttrValPrimitiveType_SysmemSemaphorePayload64b if `device`
          is GA10X+. NvSciSyncAttrKey_GpuId is set to the same UUID that is
          returned for this `device` from :py:obj:`~.cuDeviceGetUuid`.

        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`,
        :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`,
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,
        :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`,
        :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`,
        :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

        Parameters
        ----------
        nvSciSyncAttrList : Any
            Return NvSciSync attributes supported.
        dev : :py:obj:`~.CUdevice`
            Valid Cuda Device to get NvSciSync attributes for.
        flags : int
            flags describing NvSciSync usage.

        Returns
        -------
        CUresult


        See Also
        --------
        :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """


def cuDeviceGetP2PAttribute(attrib: 'CUdevice_P2PAttribute', srcDevice, dstDevice):
    """
    cuDeviceGetP2PAttribute(attrib: CUdevice_P2PAttribute, srcDevice, dstDevice)
     Queries attributes of the link between two devices.

        Returns in `*value` the value of the requested attribute `attrib` of
        the link between `srcDevice` and `dstDevice`. The supported attributes
        are:

        - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK`: A relative
          value indicating the performance of the link between two devices.

        - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED` P2P: 1 if P2P
          Access is enable.

        - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED`: 1 if
          Atomic operations over the link are supported.

        - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED`: 1 if
          cudaArray can be accessed over the link.

        Returns :py:obj:`~.CUDA_ERROR_INVALID_DEVICE` if `srcDevice` or
        `dstDevice` are not valid or if they represent the same device.

        Returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if `attrib` is not valid
        or if `value` is a null pointer.

        Parameters
        ----------
        attrib : :py:obj:`~.CUdevice_P2PAttribute`
            The requested attribute of the link between `srcDevice` and
            `dstDevice`.
        srcDevice : :py:obj:`~.CUdevice`
            The source device of the target link.
        dstDevice : :py:obj:`~.CUdevice`
            The destination device of the target link.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        value : int
            Returned value of the requested attribute

        See Also
        --------
        :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cuCtxDisablePeerAccess`, :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cudaDeviceGetP2PAttribute`
    """


def cuDeviceGetPCIBusId(length, dev):
    """
    cuDeviceGetPCIBusId(int length, dev)
     Returns a PCI Bus Id string for the device.

        Returns an ASCII string identifying the device `dev` in the NULL-
        terminated string pointed to by `pciBusId`. `length` specifies the
        maximum length of the string that may be returned.

        where `domain`, `bus`, `device`, and `function` are all hexadecimal
        values. pciBusId should be large enough to store 13 characters
        including the NULL-terminator.

        Parameters
        ----------
        length : int
            Maximum length of string to store in `name`
        dev : :py:obj:`~.CUdevice`
            Device to get identifier string for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        pciBusId : bytes
            Returned identifier string for the device in the following format

        See Also
        --------
        :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetByPCIBusId`, :py:obj:`~.cudaDeviceGetPCIBusId`
    """


def cuDeviceGetProperties(dev):
    """
    cuDeviceGetProperties(dev)
     Returns properties for a selected device.

        [Deprecated]

        This function was deprecated as of CUDA 5.0 and replaced by
        :py:obj:`~.cuDeviceGetAttribute()`.

        Returns in `*prop` the properties of device `dev`. The
        :py:obj:`~.CUdevprop` structure is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - :py:obj:`~.maxThreadsPerBlock` is the maximum number of threads per
          block;

        - :py:obj:`~.maxThreadsDim`[3] is the maximum sizes of each dimension
          of a block;

        - :py:obj:`~.maxGridSize`[3] is the maximum sizes of each dimension of
          a grid;

        - :py:obj:`~.sharedMemPerBlock` is the total amount of shared memory
          available per block in bytes;

        - :py:obj:`~.totalConstantMemory` is the total amount of constant
          memory available on the device in bytes;

        - :py:obj:`~.SIMDWidth` is the warp size;

        - :py:obj:`~.memPitch` is the maximum pitch allowed by the memory copy
          functions that involve memory regions allocated through
          :py:obj:`~.cuMemAllocPitch()`;

        - :py:obj:`~.regsPerBlock` is the total number of registers available
          per block;

        - :py:obj:`~.clockRate` is the clock frequency in kilohertz;

        - :py:obj:`~.textureAlign` is the alignment requirement; texture base
          addresses that are aligned to :py:obj:`~.textureAlign` bytes do not
          need an offset applied to texture fetches.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device to get properties for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        prop : :py:obj:`~.CUdevprop`
            Returned properties of device

        See Also
        --------
        :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`
    """


def cuDeviceGetTexture1DLinearMaxWidth(pformat: 'CUarray_format', numChannels, dev):
    """
    cuDeviceGetTexture1DLinearMaxWidth(pformat: CUarray_format, unsigned int numChannels, dev)
     Returns the maximum number of elements allocatable in a 1D linear texture for a given texture element size.

        Returns in `maxWidthInElements` the maximum number of texture elements
        allocatable in a 1D linear texture for given `pformat` and
        `numChannels`.

        Parameters
        ----------
        pformat : :py:obj:`~.CUarray_format`
            Texture format.
        numChannels : unsigned
            Number of channels per texture element.
        dev : :py:obj:`~.CUdevice`
            Device handle.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        maxWidthInElements : int
            Returned maximum number of texture elements allocatable for given
            `pformat` and `numChannels`.

        See Also
        --------
        :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cudaMemGetInfo`, :py:obj:`~.cuDeviceTotalMem`
    """


def cuDeviceGetUuid(dev):
    """
    cuDeviceGetUuid(dev)
     Return an UUID for the device.

        Note there is a later version of this API,
        :py:obj:`~.cuDeviceGetUuid_v2`. It will supplant this version in 12.0,
        which is retained for minor version compatibility.

        Returns 16-octets identifying the device `dev` in the structure pointed
        by the `uuid`.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device to get identifier string for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        uuid : :py:obj:`~.CUuuid`
            Returned UUID

        See Also
        --------
        :py:obj:`~.cuDeviceGetUuid_v2` :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaGetDeviceProperties`
    """


def cuDeviceGetUuid_v2(dev):
    """
    cuDeviceGetUuid_v2(dev)
     Return an UUID for the device (11.4+)

        Returns 16-octets identifying the device `dev` in the structure pointed
        by the `uuid`. If the device is in MIG mode, returns its MIG UUID which
        uniquely identifies the subscribed MIG compute instance.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device to get identifier string for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        uuid : :py:obj:`~.CUuuid`
            Returned UUID

        See Also
        --------
        :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cudaGetDeviceProperties`
    """


def cuDeviceGraphMemTrim(device):
    """
    cuDeviceGraphMemTrim(device)
     Free unused memory that was cached on the specified device for use with graphs back to the OS.

        Blocks which are not in use by a graph that is either currently
        executing or scheduled to execute are freed back to the operating
        system.

        Parameters
        ----------
        device : :py:obj:`~.CUdevice`
            The device for which cached memory should be freed.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

        See Also
        --------
        :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphAddMemFreeNode`, :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuDeviceGetGraphMemAttribute`
    """


def cuDevicePrimaryCtxGetState(dev):
    """
    cuDevicePrimaryCtxGetState(dev)
     Get the state of the primary context.

        Returns in `*flags` the flags for the primary context of `dev`, and in
        `*active` whether it is active. See
        :py:obj:`~.cuDevicePrimaryCtxSetFlags` for flag values.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device to get primary context flags for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        flags : unsigned int
            Pointer to store flags
        active : int
            Pointer to store context state; 0 = inactive, 1 = active

        See Also
        --------
        :py:obj:`~.cuDevicePrimaryCtxSetFlags`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxSetFlags`, :py:obj:`~.cudaGetDeviceFlags`
    """


def cuDevicePrimaryCtxRelease(dev):
    """
    cuDevicePrimaryCtxRelease(dev)
     Release the primary context on the GPU.

        Releases the primary context interop on the device. A retained context
        should always be released once the user is done using it. The context
        is automatically reset once the last reference to it is released. This
        behavior is different when the primary context was retained by the CUDA
        runtime from CUDA 4.0 and earlier. In this case, the primary context
        remains always active.

        Releasing a primary context that has not been previously retained will
        fail with :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`.

        Please note that unlike :py:obj:`~.cuCtxDestroy()` this method does not
        pop the context from stack in any circumstances.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device which primary context is released

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

        See Also
        --------
        :py:obj:`~.cuDevicePrimaryCtxRetain`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """


def cuDevicePrimaryCtxReset(dev):
    """
    cuDevicePrimaryCtxReset(dev)
     Destroy all allocations and reset all state on the primary context.

        Explicitly destroys and cleans up all resources associated with the
        current device in the current process.

        Note that it is responsibility of the calling function to ensure that
        no other module in the process is using the device any more. For that
        reason it is recommended to use :py:obj:`~.cuDevicePrimaryCtxRelease()`
        in most cases. However it is safe for other modules to call
        :py:obj:`~.cuDevicePrimaryCtxRelease()` even after resetting the
        device. Resetting the primary context does not release it, an
        application that has retained the primary context should explicitly
        release its usage.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device for which primary context is destroyed

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE`

        See Also
        --------
        :py:obj:`~.cuDevicePrimaryCtxRetain`, :py:obj:`~.cuDevicePrimaryCtxRelease`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceReset`
    """


def cuDevicePrimaryCtxRetain(dev):
    """
    cuDevicePrimaryCtxRetain(dev)
     Retain the primary context on the GPU.

        Retains the primary context on the device. Once the user successfully
        retains the primary context, the primary context will be active and
        available to the user until the user releases it with
        :py:obj:`~.cuDevicePrimaryCtxRelease()` or resets it with
        :py:obj:`~.cuDevicePrimaryCtxReset()`. Unlike :py:obj:`~.cuCtxCreate()`
        the newly retained context is not pushed onto the stack.

        Retaining the primary context for the first time will fail with
        :py:obj:`~.CUDA_ERROR_UNKNOWN` if the compute mode of the device is
        :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`. The function
        :py:obj:`~.cuDeviceGetAttribute()` can be used with
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE` to determine the compute
        mode of the device. The `nvidia-smi` tool can be used to set the
        compute mode for devices. Documentation for `nvidia-smi` can be
        obtained by passing a -h option to it.

        Please note that the primary context always supports pinned
        allocations. Other flags can be specified by
        :py:obj:`~.cuDevicePrimaryCtxSetFlags()`.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device for which primary context is requested

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        pctx : :py:obj:`~.CUcontext`
            Returned context handle of the new context

        See Also
        --------
        :py:obj:`~.cuDevicePrimaryCtxRelease`, :py:obj:`~.cuDevicePrimaryCtxSetFlags`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """


def cuDevicePrimaryCtxSetFlags(dev, flags):
    """
    cuDevicePrimaryCtxSetFlags(dev, unsigned int flags)
     Set flags for the primary context.

        Sets the flags for the primary context on the device overwriting
        perviously set ones.

        The three LSBs of the `flags` parameter can be used to control how the
        OS thread, which owns the CUDA context at the time of an API call,
        interacts with the OS scheduler when waiting for results from the GPU.
        Only one of the scheduling flags can be set when creating a context.

        - :py:obj:`~.CU_CTX_SCHED_SPIN`: Instruct CUDA to actively spin when
          waiting for results from the GPU. This can decrease latency when
          waiting for the GPU, but may lower the performance of CPU threads if
          they are performing work in parallel with the CUDA thread.

        - :py:obj:`~.CU_CTX_SCHED_YIELD`: Instruct CUDA to yield its thread
          when waiting for results from the GPU. This can increase latency when
          waiting for the GPU, but can increase the performance of CPU threads
          performing work in parallel with the GPU.

        - :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`: Instruct CUDA to block the
          CPU thread on a synchronization primitive when waiting for the GPU to
          finish work.

        - :py:obj:`~.CU_CTX_BLOCKING_SYNC`: Instruct CUDA to block the CPU
          thread on a synchronization primitive when waiting for the GPU to
          finish work.   Deprecated: This flag was deprecated as of CUDA 4.0
          and was replaced with :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`.

        - :py:obj:`~.CU_CTX_SCHED_AUTO`: The default value if the `flags`
          parameter is zero, uses a heuristic based on the number of active
          CUDA contexts in the process `C` and the number of logical processors
          in the system `P`. If `C` > `P`, then CUDA will yield to other OS
          threads when waiting for the GPU (:py:obj:`~.CU_CTX_SCHED_YIELD`),
          otherwise CUDA will not yield while waiting for results and actively
          spin on the processor (:py:obj:`~.CU_CTX_SCHED_SPIN`). Additionally,
          on Tegra devices, :py:obj:`~.CU_CTX_SCHED_AUTO` uses a heuristic
          based on the power profile of the platform and may choose
          :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` for low-powered devices.

        - :py:obj:`~.CU_CTX_LMEM_RESIZE_TO_MAX`: Instruct CUDA to not reduce
          local memory after resizing local memory for a kernel. This can
          prevent thrashing by local memory allocations when launching many
          kernels with high local memory usage at the cost of potentially
          increased memory usage.   Deprecated: This flag is deprecated and the
          behavior enabled by this flag is now the default and cannot be
          disabled.

        - :py:obj:`~.CU_CTX_COREDUMP_ENABLE`: If GPU coredumps have not been
          enabled globally with :py:obj:`~.cuCoredumpSetAttributeGlobal` or
          environment variables, this flag can be set during context creation
          to instruct CUDA to create a coredump if this context raises an
          exception during execution. These environment variables are described
          in the CUDA-GDB user guide under the "GPU core dump support" section.
          The initial settings will be taken from the global settings at the
          time of context creation. The other settings that control coredump
          output can be modified by calling :py:obj:`~.cuCoredumpSetAttribute`
          from the created context after it becomes current.

        - :py:obj:`~.CU_CTX_USER_COREDUMP_ENABLE`: If user-triggered GPU
          coredumps have not been enabled globally with
          :py:obj:`~.cuCoredumpSetAttributeGlobal` or environment variables,
          this flag can be set during context creation to instruct CUDA to
          create a coredump if data is written to a certain pipe that is
          present in the OS space. These environment variables are described in
          the CUDA-GDB user guide under the "GPU core dump support" section. It
          is important to note that the pipe name `must` be set with
          :py:obj:`~.cuCoredumpSetAttributeGlobal` before creating the context
          if this flag is used. Setting this flag implies that
          :py:obj:`~.CU_CTX_COREDUMP_ENABLE` is set. The initial settings will
          be taken from the global settings at the time of context creation.
          The other settings that control coredump output can be modified by
          calling :py:obj:`~.cuCoredumpSetAttribute` from the created context
          after it becomes current.

        - :py:obj:`~.CU_CTX_SYNC_MEMOPS`: Ensures that synchronous memory
          operations initiated on this context will always synchronize. See
          further documentation in the section titled "API Synchronization
          behavior" to learn more about cases when synchronous memory
          operations can exhibit asynchronous behavior.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device for which the primary context flags are set
        flags : unsigned int
            New flags for the device

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuDevicePrimaryCtxRetain`, :py:obj:`~.cuDevicePrimaryCtxGetState`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxSetFlags`, :py:obj:`~.cudaSetDeviceFlags`
    """


def cuDeviceRegisterAsyncNotification(device, callbackFunc, userData):
    """
    cuDeviceRegisterAsyncNotification(device, callbackFunc, userData)
     Registers a callback function to receive async notifications.

        Registers `callbackFunc` to receive async notifications.

        The `userData` parameter is passed to the callback function at async
        notification time.   Likewise, `callback` is also passed to the
        callback function to distinguish between multiple registered callbacks.

        The callback function being registered should be designed to return
        quickly (~10ms).   Any long running tasks should be queued for
        execution on an application thread.

        Callbacks may not call cuDeviceRegisterAsyncNotification or
        cuDeviceUnregisterAsyncNotification. Doing so will result in
        :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`. Async notification callbacks
        execute in an undefined order and may be serialized.

        Returns in `*callback` a handle representing the registered callback
        instance.

        Parameters
        ----------
        device : :py:obj:`~.CUdevice`
            The device on which to register the callback
        callbackFunc : :py:obj:`~.CUasyncCallback`
            The function to register as a callback
        userData : Any
            A generic pointer to user data. This is passed into the callback
            function.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` :py:obj:`~.CUDA_ERROR_INVALID_DEVICE` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_PERMITTED` :py:obj:`~.CUDA_ERROR_UNKNOWN`
        callback : :py:obj:`~.CUasyncCallbackHandle`
            A handle representing the registered callback instance

        See Also
        --------
        :py:obj:`~.cuDeviceUnregisterAsyncNotification`
    """


def cuDeviceSetGraphMemAttribute(device, attr: 'CUgraphMem_attribute', value):
    """
    cuDeviceSetGraphMemAttribute(device, attr: CUgraphMem_attribute, value)
     Set asynchronous allocation attributes related to graphs.

        Valid attributes are:

        - :py:obj:`~.CU_GRAPH_MEM_ATTR_USED_MEM_HIGH`: High watermark of
          memory, in bytes, associated with graphs since the last time it was
          reset. High watermark can only be reset to zero.

        - :py:obj:`~.CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH`: High watermark of
          memory, in bytes, currently allocated for use by the CUDA graphs
          asynchronous allocator.

        Parameters
        ----------
        device : :py:obj:`~.CUdevice`
            Specifies the scope of the query
        attr : :py:obj:`~.CUgraphMem_attribute`
            attribute to get
        value : Any
            pointer to value to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

        See Also
        --------
        :py:obj:`~.cuDeviceGetGraphMemAttribute`, :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphAddMemFreeNode`
    """


def cuDeviceSetMemPool(dev, pool):
    """
    cuDeviceSetMemPool(dev, pool)
     Sets the current memory pool of a device.

        The memory pool must be local to the specified device.
        :py:obj:`~.cuMemAllocAsync` allocates from the current mempool of the
        provided stream's device. By default, a device's current memory pool is
        its default memory pool.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            None
        pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
            None

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolDestroy`, :py:obj:`~.cuMemAllocFromPoolAsync`

        Notes
        -----
        Use :py:obj:`~.cuMemAllocFromPoolAsync` to specify asynchronous allocations from a device different than the one the stream runs on.
    """


def cuDeviceTotalMem(dev):
    """
    cuDeviceTotalMem(dev)
     Returns the total amount of memory on the device.

        Returns in `*bytes` the total amount of memory available on the device
        `dev` in bytes.

        Parameters
        ----------
        dev : :py:obj:`~.CUdevice`
            Device handle

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        numbytes : int
            Returned memory available on device in bytes

        See Also
        --------
        :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaMemGetInfo`
    """


def cuDeviceUnregisterAsyncNotification(device, callback):
    """
    cuDeviceUnregisterAsyncNotification(device, callback)
     Unregisters an async notification callback.

        Unregisters `callback` so that the corresponding callback function will
        stop receiving async notifications.

        Parameters
        ----------
        device : :py:obj:`~.CUdevice`
            The device from which to remove `callback`.
        callback : :py:obj:`~.CUasyncCallbackHandle`
            The callback instance to unregister from receiving async
            notifications.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` :py:obj:`~.CUDA_ERROR_INVALID_DEVICE` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_PERMITTED` :py:obj:`~.CUDA_ERROR_UNKNOWN`

        See Also
        --------
        :py:obj:`~.cuDeviceRegisterAsyncNotification`
    """


def cuDriverGetVersion():
    """
    cuDriverGetVersion()
     Returns the latest CUDA version supported by driver.

        Returns in `*driverVersion` the version of CUDA supported by the
        driver. The version is returned as (1000 * major + 10 * minor). For
        example, CUDA 9.2 would be represented by 9020.

        This function automatically returns
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if `driverVersion` is NULL.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        driverVersion : int
            Returns the CUDA driver version

        See Also
        --------
        :py:obj:`~.cudaDriverGetVersion`, :py:obj:`~.cudaRuntimeGetVersion`
    """


def cuEGLStreamConsumerAcquireFrame(conn, pCudaResource, pStream, timeout):
    """
    cuEGLStreamConsumerAcquireFrame(conn, pCudaResource, pStream, unsigned int timeout)
     Acquire an image frame from the EGLStream with CUDA as a consumer.

        Acquire an image frame from EGLStreamKHR. This API can also acquire an
        old frame presented by the producer unless explicitly disabled by
        setting EGL_SUPPORT_REUSE_NV flag to EGL_FALSE during stream
        initialization. By default, EGLStream is created with this flag set to
        EGL_TRUE. :py:obj:`~.cuGraphicsResourceGetMappedEglFrame` can be called
        on `pCudaResource` to get :py:obj:`~.CUeglFrame`.

        Parameters
        ----------
        conn : :py:obj:`~.CUeglStreamConnection`
            Connection on which to acquire
        pCudaResource : :py:obj:`~.CUgraphicsResource`
            CUDA resource on which the stream frame will be mapped for use.
        pStream : :py:obj:`~.CUstream`
            CUDA stream for synchronization and any data migrations implied by
            :py:obj:`~.CUeglResourceLocationFlags`.
        timeout : unsigned int
            Desired timeout in usec for a new frame to be acquired. If set as
            :py:obj:`~.CUDA_EGL_INFINITE_TIMEOUT`, acquire waits infinitely.
            After timeout occurs CUDA consumer tries to acquire an old frame if
            available and EGL_SUPPORT_REUSE_NV flag is set.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`,

        See Also
        --------
        :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerAcquireFrame`
    """


def cuEGLStreamConsumerConnect(stream):
    """
    cuEGLStreamConsumerConnect(stream)
     Connect CUDA to EGLStream as a consumer.

        Connect CUDA as a consumer to EGLStreamKHR specified by `stream`.

        The EGLStreamKHR is an EGL object that transfers a sequence of image
        frames from one API to another.

        Parameters
        ----------
        stream : :py:obj:`~.EGLStreamKHR`
            EGLStreamKHR handle

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
        conn : :py:obj:`~.CUeglStreamConnection`
            Pointer to the returned connection handle

        See Also
        --------
        :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerConnect`
    """


def cuEGLStreamConsumerConnectWithFlags(stream, flags):
    """
    cuEGLStreamConsumerConnectWithFlags(stream, unsigned int flags)
     Connect CUDA to EGLStream as a consumer with given flags.

        Connect CUDA as a consumer to EGLStreamKHR specified by `stream` with
        specified `flags` defined by CUeglResourceLocationFlags.

        The flags specify whether the consumer wants to access frames from
        system memory or video memory. Default is
        :py:obj:`~.CU_EGL_RESOURCE_LOCATION_VIDMEM`.

        Parameters
        ----------
        stream : :py:obj:`~.EGLStreamKHR`
            EGLStreamKHR handle
        flags : unsigned int
            Flags denote intended location - system or video.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
        conn : :py:obj:`~.CUeglStreamConnection`
            Pointer to the returned connection handle

        See Also
        --------
        :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerConnectWithFlags`
    """


def cuEGLStreamConsumerDisconnect(conn):
    """
    cuEGLStreamConsumerDisconnect(conn)
     Disconnect CUDA as a consumer to EGLStream .

        Disconnect CUDA as a consumer to EGLStreamKHR.

        Parameters
        ----------
        conn : :py:obj:`~.CUeglStreamConnection`
            Conection to disconnect.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,

        See Also
        --------
        :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerDisconnect`
    """


def cuEGLStreamConsumerReleaseFrame(conn, pCudaResource, pStream):
    """
    cuEGLStreamConsumerReleaseFrame(conn, pCudaResource, pStream)
     Releases the last frame acquired from the EGLStream.

        Release the acquired image frame specified by `pCudaResource` to
        EGLStreamKHR. If EGL_SUPPORT_REUSE_NV flag is set to EGL_TRUE, at the
        time of EGL creation this API doesn't release the last frame acquired
        on the EGLStream. By default, EGLStream is created with this flag set
        to EGL_TRUE.

        Parameters
        ----------
        conn : :py:obj:`~.CUeglStreamConnection`
            Connection on which to release
        pCudaResource : :py:obj:`~.CUgraphicsResource`
            CUDA resource whose corresponding frame is to be released
        pStream : :py:obj:`~.CUstream`
            CUDA stream on which release will be done.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,

        See Also
        --------
        :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerReleaseFrame`
    """


def cuEGLStreamProducerConnect(stream, width, height):
    """
    cuEGLStreamProducerConnect(stream, width, height)
     Connect CUDA to EGLStream as a producer.

        Connect CUDA as a producer to EGLStreamKHR specified by `stream`.

        The EGLStreamKHR is an EGL object that transfers a sequence of image
        frames from one API to another.

        Parameters
        ----------
        stream : :py:obj:`~.EGLStreamKHR`
            EGLStreamKHR handle
        width : :py:obj:`~.EGLint`
            width of the image to be submitted to the stream
        height : :py:obj:`~.EGLint`
            height of the image to be submitted to the stream

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
        conn : :py:obj:`~.CUeglStreamConnection`
            Pointer to the returned connection handle

        See Also
        --------
        :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerPresentFrame`, :py:obj:`~.cudaEGLStreamProducerConnect`
    """


def cuEGLStreamProducerDisconnect(conn):
    """
    cuEGLStreamProducerDisconnect(conn)
     Disconnect CUDA as a producer to EGLStream .

        Disconnect CUDA as a producer to EGLStreamKHR.

        Parameters
        ----------
        conn : :py:obj:`~.CUeglStreamConnection`
            Conection to disconnect.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,

        See Also
        --------
        :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerPresentFrame`, :py:obj:`~.cudaEGLStreamProducerDisconnect`
    """


def cuEGLStreamProducerPresentFrame(conn, eglframe: 'CUeglFrame', pStream):
    """
    cuEGLStreamProducerPresentFrame(conn, CUeglFrame eglframe: CUeglFrame, pStream)
     Present a CUDA eglFrame to the EGLStream with CUDA as a producer.

        When a frame is presented by the producer, it gets associated with the
        EGLStream and thus it is illegal to free the frame before the producer
        is disconnected. If a frame is freed and reused it may lead to
        undefined behavior.

        If producer and consumer are on different GPUs (iGPU and dGPU) then
        frametype :py:obj:`~.CU_EGL_FRAME_TYPE_ARRAY` is not supported.
        :py:obj:`~.CU_EGL_FRAME_TYPE_PITCH` can be used for such cross-device
        applications.

        The :py:obj:`~.CUeglFrame` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        For :py:obj:`~.CUeglFrame` of type :py:obj:`~.CU_EGL_FRAME_TYPE_PITCH`,
        the application may present sub-region of a memory allocation. In that
        case, the pitched pointer will specify the start address of the sub-
        region in the allocation and corresponding :py:obj:`~.CUeglFrame`
        fields will specify the dimensions of the sub-region.

        Parameters
        ----------
        conn : :py:obj:`~.CUeglStreamConnection`
            Connection on which to present the CUDA array
        eglframe : :py:obj:`~.CUeglFrame`
            CUDA Eglstream Proucer Frame handle to be sent to the consumer over
            EglStream.
        pStream : :py:obj:`~.CUstream`
            CUDA stream on which to present the frame.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,

        See Also
        --------
        :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerReturnFrame`, :py:obj:`~.cudaEGLStreamProducerPresentFrame`
    """


def cuEGLStreamProducerReturnFrame(conn, eglframe: 'Optional[CUeglFrame]', pStream):
    """
    cuEGLStreamProducerReturnFrame(conn, CUeglFrame eglframe: Optional[CUeglFrame], pStream)
     Return the CUDA eglFrame to the EGLStream released by the consumer.

        This API can potentially return CUDA_ERROR_LAUNCH_TIMEOUT if the
        consumer has not returned a frame to EGL stream. If timeout is returned
        the application can retry.

        Parameters
        ----------
        conn : :py:obj:`~.CUeglStreamConnection`
            Connection on which to return
        eglframe : :py:obj:`~.CUeglFrame`
            CUDA Eglstream Proucer Frame handle returned from the consumer over
            EglStream.
        pStream : :py:obj:`~.CUstream`
            CUDA stream on which to return the frame.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`

        See Also
        --------
        :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerPresentFrame`, :py:obj:`~.cudaEGLStreamProducerReturnFrame`
    """


def cuEventCreate(Flags):
    """
    cuEventCreate(unsigned int Flags)
     Creates an event.

        Creates an event *phEvent for the current context with the flags
        specified via `Flags`. Valid flags include:

        - :py:obj:`~.CU_EVENT_DEFAULT`: Default event creation flag.

        - :py:obj:`~.CU_EVENT_BLOCKING_SYNC`: Specifies that the created event
          should use blocking synchronization. A CPU thread that uses
          :py:obj:`~.cuEventSynchronize()` to wait on an event created with
          this flag will block until the event has actually been recorded.

        - :py:obj:`~.CU_EVENT_DISABLE_TIMING`: Specifies that the created event
          does not need to record timing data. Events created with this flag
          specified and the :py:obj:`~.CU_EVENT_BLOCKING_SYNC` flag not
          specified will provide the best performance when used with
          :py:obj:`~.cuStreamWaitEvent()` and :py:obj:`~.cuEventQuery()`.

        - :py:obj:`~.CU_EVENT_INTERPROCESS`: Specifies that the created event
          may be used as an interprocess event by
          :py:obj:`~.cuIpcGetEventHandle()`. :py:obj:`~.CU_EVENT_INTERPROCESS`
          must be specified along with :py:obj:`~.CU_EVENT_DISABLE_TIMING`.

        Parameters
        ----------
        Flags : unsigned int
            Event creation flags

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        phEvent : :py:obj:`~.CUevent`
            Returns newly created event

        See Also
        --------
        :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventCreate`, :py:obj:`~.cudaEventCreateWithFlags`
    """


def cuEventCreateFromEGLSync(eglSync, flags):
    """
    cuEventCreateFromEGLSync(eglSync, unsigned int flags)
     Creates an event from EGLSync object.

        Creates an event *phEvent from an EGLSyncKHR eglSync with the flags
        specified via `flags`. Valid flags include:

        - :py:obj:`~.CU_EVENT_DEFAULT`: Default event creation flag.

        - :py:obj:`~.CU_EVENT_BLOCKING_SYNC`: Specifies that the created event
          should use blocking synchronization. A CPU thread that uses
          :py:obj:`~.cuEventSynchronize()` to wait on an event created with
          this flag will block until the event has actually been completed.

        Once the `eglSync` gets destroyed, :py:obj:`~.cuEventDestroy` is the
        only API that can be invoked on the event.

        :py:obj:`~.cuEventRecord` and TimingData are not supported for events
        created from EGLSync.

        The EGLSyncKHR is an opaque handle to an EGL sync object. typedef void*
        EGLSyncKHR

        Parameters
        ----------
        eglSync : :py:obj:`~.EGLSyncKHR`
            Opaque handle to EGLSync object
        flags : unsigned int
            Event creation flags

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        phEvent : :py:obj:`~.CUevent`
            Returns newly created event

        See Also
        --------
        :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`
    """


def cuEventDestroy(hEvent):
    """
    cuEventDestroy(hEvent)
     Destroys an event.

        Destroys the event specified by `hEvent`.

        An event may be destroyed before it is complete (i.e., while
        :py:obj:`~.cuEventQuery()` would return
        :py:obj:`~.CUDA_ERROR_NOT_READY`). In this case, the call does not
        block on completion of the event, and any associated resources will
        automatically be released asynchronously at completion.

        Parameters
        ----------
        hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to destroy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventDestroy`
    """


def cuEventElapsedTime(hStart, hEnd):
    """
    cuEventElapsedTime(hStart, hEnd)
     Computes the elapsed time between two events.

        Computes the elapsed time between two events (in milliseconds with a
        resolution of around 0.5 microseconds).

        If either event was last recorded in a non-NULL stream, the resulting
        time may be greater than expected (even if both used the same stream
        handle). This happens because the :py:obj:`~.cuEventRecord()` operation
        takes place asynchronously and there is no guarantee that the measured
        latency is actually just between the two events. Any number of other
        different stream operations could execute in between the two measured
        events, thus altering the timing in a significant way.

        If :py:obj:`~.cuEventRecord()` has not been called on either event then
        :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. If
        :py:obj:`~.cuEventRecord()` has been called on both events but one or
        both of them has not yet been completed (that is,
        :py:obj:`~.cuEventQuery()` would return
        :py:obj:`~.CUDA_ERROR_NOT_READY` on at least one of the events),
        :py:obj:`~.CUDA_ERROR_NOT_READY` is returned. If either event was
        created with the :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag, then this
        function will return :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`.

        Note there is a later version of this API,
        :py:obj:`~.cuEventElapsedTime_v2`. It will supplant this version in
        CUDA 13.0, which is retained for minor version compatibility.

        Parameters
        ----------
        hStart : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Starting event
        hEnd : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Ending event

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_READY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        pMilliseconds : float
            Time between `hStart` and `hEnd` in ms

        See Also
        --------
        :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cudaEventElapsedTime`
    """


def cuEventElapsedTime_v2(hStart, hEnd):
    """
    cuEventElapsedTime_v2(hStart, hEnd)
     Computes the elapsed time between two events.

        Computes the elapsed time between two events (in milliseconds with a
        resolution of around 0.5 microseconds). Note this API is not guaranteed
        to return the latest errors for pending work. As such this API is
        intended to serve as an elapsed time calculation only and any polling
        for completion on the events to be compared should be done with
        :py:obj:`~.cuEventQuery` instead.

        If either event was last recorded in a non-NULL stream, the resulting
        time may be greater than expected (even if both used the same stream
        handle). This happens because the :py:obj:`~.cuEventRecord()` operation
        takes place asynchronously and there is no guarantee that the measured
        latency is actually just between the two events. Any number of other
        different stream operations could execute in between the two measured
        events, thus altering the timing in a significant way.

        If :py:obj:`~.cuEventRecord()` has not been called on either event then
        :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. If
        :py:obj:`~.cuEventRecord()` has been called on both events but one or
        both of them has not yet been completed (that is,
        :py:obj:`~.cuEventQuery()` would return
        :py:obj:`~.CUDA_ERROR_NOT_READY` on at least one of the events),
        :py:obj:`~.CUDA_ERROR_NOT_READY` is returned. If either event was
        created with the :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag, then this
        function will return :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`.

        Parameters
        ----------
        hStart : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Starting event
        hEnd : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Ending event

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_READY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        pMilliseconds : float
            Time between `hStart` and `hEnd` in ms

        See Also
        --------
        :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cudaEventElapsedTime`
    """


def cuEventQuery(hEvent):
    """
    cuEventQuery(hEvent)
     Queries an event's status.

        Queries the status of all work currently captured by `hEvent`. See
        :py:obj:`~.cuEventRecord()` for details on what is captured by an
        event.

        Returns :py:obj:`~.CUDA_SUCCESS` if all captured work has been
        completed, or :py:obj:`~.CUDA_ERROR_NOT_READY` if any captured work is
        incomplete.

        For the purposes of Unified Memory, a return value of
        :py:obj:`~.CUDA_SUCCESS` is equivalent to having called
        :py:obj:`~.cuEventSynchronize()`.

        Parameters
        ----------
        hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_READY`

        See Also
        --------
        :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventQuery`
    """


def cuEventRecord(hEvent, hStream):
    """
    cuEventRecord(hEvent, hStream)
     Records an event.

        Captures in `hEvent` the contents of `hStream` at the time of this
        call. `hEvent` and `hStream` must be from the same context otherwise
        :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. Calls such as
        :py:obj:`~.cuEventQuery()` or :py:obj:`~.cuStreamWaitEvent()` will then
        examine or wait for completion of the work that was captured. Uses of
        `hStream` after this call do not modify `hEvent`. See note on default
        stream behavior for what is captured in the default case.

        :py:obj:`~.cuEventRecord()` can be called multiple times on the same
        event and will overwrite the previously captured state. Other APIs such
        as :py:obj:`~.cuStreamWaitEvent()` use the most recently captured state
        at the time of the API call, and are not affected by later calls to
        :py:obj:`~.cuEventRecord()`. Before the first call to
        :py:obj:`~.cuEventRecord()`, an event represents an empty set of work,
        so for example :py:obj:`~.cuEventQuery()` would return
        :py:obj:`~.CUDA_SUCCESS`.

        Parameters
        ----------
        hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to record
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to record event for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventRecord`, :py:obj:`~.cuEventRecordWithFlags`
    """


def cuEventRecordWithFlags(hEvent, hStream, flags):
    """
    cuEventRecordWithFlags(hEvent, hStream, unsigned int flags)
     Records an event.

        Captures in `hEvent` the contents of `hStream` at the time of this
        call. `hEvent` and `hStream` must be from the same context otherwise
        :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. Calls such as
        :py:obj:`~.cuEventQuery()` or :py:obj:`~.cuStreamWaitEvent()` will then
        examine or wait for completion of the work that was captured. Uses of
        `hStream` after this call do not modify `hEvent`. See note on default
        stream behavior for what is captured in the default case.

        :py:obj:`~.cuEventRecordWithFlags()` can be called multiple times on
        the same event and will overwrite the previously captured state. Other
        APIs such as :py:obj:`~.cuStreamWaitEvent()` use the most recently
        captured state at the time of the API call, and are not affected by
        later calls to :py:obj:`~.cuEventRecordWithFlags()`. Before the first
        call to :py:obj:`~.cuEventRecordWithFlags()`, an event represents an
        empty set of work, so for example :py:obj:`~.cuEventQuery()` would
        return :py:obj:`~.CUDA_SUCCESS`.

        flags include:

        - :py:obj:`~.CU_EVENT_RECORD_DEFAULT`: Default event creation flag.

        - :py:obj:`~.CU_EVENT_RECORD_EXTERNAL`: Event is captured in the graph
          as an external event node when performing stream capture. This flag
          is invalid outside of stream capture.

        Parameters
        ----------
        hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to record
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to record event for
        flags : unsigned int
            See :py:obj:`~.CUevent_capture_flags`

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cudaEventRecord`
    """


def cuEventSynchronize(hEvent):
    """
    cuEventSynchronize(hEvent)
     Waits for an event to complete.

        Waits until the completion of all work currently captured in `hEvent`.
        See :py:obj:`~.cuEventRecord()` for details on what is captured by an
        event.

        Waiting for an event that was created with the
        :py:obj:`~.CU_EVENT_BLOCKING_SYNC` flag will cause the calling CPU
        thread to block until the event has been completed by the device. If
        the :py:obj:`~.CU_EVENT_BLOCKING_SYNC` flag has not been set, then the
        CPU thread will busy-wait until the event has been completed by the
        device.

        Parameters
        ----------
        hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to wait for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventSynchronize`
    """


def cuExternalMemoryGetMappedBuffer(extMem, bufferDesc: 'Optional[CUDA_EXTERNAL_MEMORY_BUFFER_DESC]'):
    """
    cuExternalMemoryGetMappedBuffer(extMem, CUDA_EXTERNAL_MEMORY_BUFFER_DESC bufferDesc: Optional[CUDA_EXTERNAL_MEMORY_BUFFER_DESC])
     Maps a buffer onto an imported memory object.

        Maps a buffer onto an imported memory object and returns a device
        pointer in `devPtr`.

        The properties of the buffer being mapped must be described in
        `bufferDesc`. The :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC`
        structure is defined as follows:

        **View CUDA Toolkit Documentation for a C++ code example**

        where :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC.offset` is the offset
        in the memory object where the buffer's base address is.
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC.size` is the size of the
        buffer. :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC.flags` must be
        zero.

        The offset and size have to be suitably aligned to match the
        requirements of the external API. Mapping two buffers whose ranges
        overlap may or may not result in the same virtual address being
        returned for the overlapped portion. In such cases, the application
        must ensure that all accesses to that region from the GPU are volatile.
        Otherwise writes made via one address are not guaranteed to be visible
        via the other address, even if they're issued by the same thread. It is
        recommended that applications map the combined range instead of mapping
        separate buffers and then apply the appropriate offsets to the returned
        pointer to derive the individual buffers.

        The returned pointer `devPtr` must be freed using
        :py:obj:`~.cuMemFree`.

        Parameters
        ----------
        extMem : :py:obj:`~.CUexternalMemory`
            Handle to external memory object
        bufferDesc : :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC`
            Buffer descriptor

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
        devPtr : :py:obj:`~.CUdeviceptr`
            Returned device pointer to buffer

        See Also
        --------
        :py:obj:`~.cuImportExternalMemory`, :py:obj:`~.cuDestroyExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedMipmappedArray`
    """


def cuExternalMemoryGetMappedMipmappedArray(extMem, mipmapDesc: 'Optional[CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC]'):
    """
    cuExternalMemoryGetMappedMipmappedArray(extMem, CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC mipmapDesc: Optional[CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC])
     Maps a CUDA mipmapped array onto an external memory object.

        Maps a CUDA mipmapped array onto an external object and returns a
        handle to it in `mipmap`.

        The properties of the CUDA mipmapped array being mapped must be
        described in `mipmapDesc`. The structure
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC` is defined as
        follows:

        **View CUDA Toolkit Documentation for a C++ code example**

        where :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.offset` is
        the offset in the memory object where the base level of the mipmap
        chain is.
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.arrayDesc`
        describes the format, dimensions and type of the base level of the
        mipmap chain. For further details on these parameters, please refer to
        the documentation for :py:obj:`~.cuMipmappedArrayCreate`. Note that if
        the mipmapped array is bound as a color target in the graphics API,
        then the flag :py:obj:`~.CUDA_ARRAY3D_COLOR_ATTACHMENT` must be
        specified in
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC`::arrayDesc::Flags.
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.numLevels`
        specifies the total number of levels in the mipmap chain.

        If `extMem` was imported from a handle of type
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`, then
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.numLevels` must be
        equal to 1.

        The returned CUDA mipmapped array must be freed using
        :py:obj:`~.cuMipmappedArrayDestroy`.

        Parameters
        ----------
        extMem : :py:obj:`~.CUexternalMemory`
            Handle to external memory object
        mipmapDesc : :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC`
            CUDA array descriptor

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
        mipmap : :py:obj:`~.CUmipmappedArray`
            Returned CUDA mipmapped array

        See Also
        --------
        :py:obj:`~.cuImportExternalMemory`, :py:obj:`~.cuDestroyExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedBuffer`
    """


def cuFlushGPUDirectRDMAWrites(target: 'CUflushGPUDirectRDMAWritesTarget', scope: 'CUflushGPUDirectRDMAWritesScope'):
    """
    cuFlushGPUDirectRDMAWrites(target: CUflushGPUDirectRDMAWritesTarget, scope: CUflushGPUDirectRDMAWritesScope)
     Blocks until remote writes are visible to the specified scope.

        Blocks until GPUDirect RDMA writes to the target context via mappings
        created through APIs like nvidia_p2p_get_pages (see
        https://docs.nvidia.com/cuda/gpudirect-rdma for more information), are
        visible to the specified scope.

        If the scope equals or lies within the scope indicated by
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING`, the
        call will be a no-op and can be safely omitted for performance. This
        can be determined by comparing the numerical values between the two
        enums, with smaller scopes having smaller values.

        On platforms that support GPUDirect RDMA writes via more than one path
        in hardware (see
        :py:obj:`~.CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE`), the user
        should consider those paths as belonging to separate ordering domains.
        Note that in such cases CUDA driver will report both RDMA writes
        ordering and RDMA write scope as ALL_DEVICES and a call to
        cuFlushGPUDirectRDMA will be a no-op, but when these multiple paths are
        used simultaneously, it is the user's responsibility to ensure ordering
        by using mechanisms outside the scope of CUDA.

        Users may query support for this API via
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_FLUSH_FLUSH_GPU_DIRECT_RDMA_OPTIONS`.

        Parameters
        ----------
        target : :py:obj:`~.CUflushGPUDirectRDMAWritesTarget`
            The target of the operation, see
            :py:obj:`~.CUflushGPUDirectRDMAWritesTarget`
        scope : :py:obj:`~.CUflushGPUDirectRDMAWritesScope`
            The scope of the operation, see
            :py:obj:`~.CUflushGPUDirectRDMAWritesScope`

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    """


def cuFuncGetAttribute(attrib: 'CUfunction_attribute', hfunc):
    """
    cuFuncGetAttribute(attrib: CUfunction_attribute, hfunc)
     Returns information about a function.

        Returns in `*pi` the integer value of the attribute `attrib` on the
        kernel given by `hfunc`. The supported attributes are:

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK`: The maximum
          number of threads per block, beyond which a launch of the function
          would fail. This number depends on both the function and the device
          on which the function is currently loaded.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES`: The size in bytes of
          statically-allocated shared memory per block required by this
          function. This does not include dynamically-allocated shared memory
          requested by the user at runtime.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES`: The size in bytes of
          user-allocated constant memory required by this function.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES`: The size in bytes of
          local memory used by each thread of this function.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_NUM_REGS`: The number of registers used
          by each thread of this function.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_PTX_VERSION`: The PTX virtual
          architecture version for which the function was compiled. This value
          is the major PTX version * 10

          - the minor PTX version, so a PTX version 1.3 function would return
            the value 13. Note that this may return the undefined value of 0
            for cubins compiled prior to CUDA 3.0.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_BINARY_VERSION`: The binary architecture
          version for which the function was compiled. This value is the major
          binary version * 10 + the minor binary version, so a binary version
          1.3 function would return the value 13. Note that this will return a
          value of 10 for legacy cubins that do not have a properly-encoded
          binary architecture version.

        - :py:obj:`~.CU_FUNC_CACHE_MODE_CA`: The attribute to indicate whether
          the function has been compiled with user specified option "-Xptxas
          --dlcm=ca" set .

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`: The
          maximum size in bytes of dynamically-allocated shared memory.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`:
          Preferred shared memory-L1 cache split ratio in percent of total
          shared memory.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET`: If this
          attribute is set, the kernel must launch with a valid cluster size
          specified.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH`: The required
          cluster width in blocks.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT`: The required
          cluster height in blocks.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH`: The required
          cluster depth in blocks.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED`:
          Indicates whether the function can be launched with non-portable
          cluster size. 1 is allowed, 0 is disallowed. A non-portable cluster
          size may only function on the specific SKUs the program is tested on.
          The launch might fail if the program is run on a different hardware
          platform. CUDA API provides cudaOccupancyMaxActiveClusters to assist
          with checking whether the desired size can be launched on the current
          device. A portable cluster size is guaranteed to be functional on all
          compute capabilities higher than the target compute capability. The
          portable cluster size for sm_90 is 8 blocks per cluster. This value
          may increase for future compute capabilities. The specific hardware
          unit may support higher cluster sizes thats not guaranteed to be
          portable.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE`:
          The block scheduling policy of a function. The value type is
          CUclusterSchedulingPolicy.

        With a few execeptions, function attributes may also be queried on
        unloaded function handles returned from
        :py:obj:`~.cuModuleEnumerateFunctions`.
        :py:obj:`~.CUDA_ERROR_FUNCTION_NOT_LOADED` is returned if the attribute
        requires a fully loaded function but the function is not loaded. The
        loading state of a function may be queried using
        :py:obj:`~.cuFuncIsloaded`. :py:obj:`~.cuFuncLoad` may be called to
        explicitly load a function before querying the following attributes
        that require the function to be loaded:

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK`

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES`

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`

        Parameters
        ----------
        attrib : :py:obj:`~.CUfunction_attribute`
            Attribute requested
        hfunc : :py:obj:`~.CUfunction`
            Function to query attribute of

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_FUNCTION_NOT_LOADED`
        pi : int
            Returned attribute value

        See Also
        --------
        :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncGetAttributes`, :py:obj:`~.cudaFuncSetAttribute`, :py:obj:`~.cuFuncIsLoaded`, :py:obj:`~.cuFuncLoad`, :py:obj:`~.cuKernelGetAttribute`
    """


def cuFuncGetModule(hfunc):
    """
    cuFuncGetModule(hfunc)
     Returns a module handle.

        Returns in `*hmod` the handle of the module that function `hfunc` is
        located in. The lifetime of the module corresponds to the lifetime of
        the context it was loaded in or until the module is explicitly
        unloaded.

        The CUDA runtime manages its own modules loaded into the primary
        context. If the handle returned by this API refers to a module loaded
        by the CUDA runtime, calling :py:obj:`~.cuModuleUnload()` on that
        module will result in undefined behavior.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            Function to retrieve module for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
        hmod : :py:obj:`~.CUmodule`
            Returned module handle
    """


def cuFuncGetName(hfunc):
    """
    cuFuncGetName(hfunc)
     Returns the function name for a :py:obj:`~.CUfunction` handle.

        Returns in `**name` the function name associated with the function
        handle `hfunc` . The function name is returned as a null-terminated
        string. The returned name is only valid when the function handle is
        valid. If the module is unloaded or reloaded, one must call the API
        again to get the updated name. This API may return a mangled name if
        the function is not declared as having C linkage. If either `**name` or
        `hfunc` is NULL, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            The function handle to retrieve the name for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        name : bytes
            The returned name of the function
    """


def cuFuncGetParamInfo(func, paramIndex):
    """
    cuFuncGetParamInfo(func, size_t paramIndex)
     Returns the offset and size of a kernel parameter in the device-side parameter layout.

        Queries the kernel parameter at `paramIndex` into `func's` list of
        parameters, and returns in `paramOffset` and `paramSize` the offset and
        size, respectively, where the parameter will reside in the device-side
        parameter layout. This information can be used to update kernel node
        parameters from the device via
        :py:obj:`~.cudaGraphKernelNodeSetParam()` and
        :py:obj:`~.cudaGraphKernelNodeUpdatesApply()`. `paramIndex` must be
        less than the number of parameters that `func` takes. `paramSize` can
        be set to NULL if only the parameter offset is desired.

        Parameters
        ----------
        func : :py:obj:`~.CUfunction`
            The function to query
        paramIndex : size_t
            The parameter index to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        paramOffset : int
            Returns the offset into the device-side parameter layout at which
            the parameter resides
        paramSize : int
            Optionally returns the size of the parameter in the device-side
            parameter layout

        See Also
        --------
        :py:obj:`~.cuKernelGetParamInfo`
    """


def cuFuncIsLoaded(function):
    """
    cuFuncIsLoaded(function)
     Returns if the function is loaded.

        Returns in `state` the loading state of `function`.

        Parameters
        ----------
        function : :py:obj:`~.CUfunction`
            the function to check

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        state : :py:obj:`~.CUfunctionLoadingState`
            returned loading state

        See Also
        --------
        :py:obj:`~.cuFuncLoad`, :py:obj:`~.cuModuleEnumerateFunctions`
    """


def cuFuncLoad(function):
    """
    cuFuncLoad(function)
     Loads a function.

        Finalizes function loading for `function`. Calling this API with a
        fully loaded function has no effect.

        Parameters
        ----------
        function : :py:obj:`~.CUfunction`
            the function to load

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuModuleEnumerateFunctions`, :py:obj:`~.cuFuncIsLoaded`
    """


def cuFuncSetAttribute(hfunc, attrib: 'CUfunction_attribute', value):
    """
    cuFuncSetAttribute(hfunc, attrib: CUfunction_attribute, int value)
     Sets information about a function.

        This call sets the value of a specified attribute `attrib` on the
        kernel given by `hfunc` to an integer value specified by `val` This
        function returns CUDA_SUCCESS if the new value of the attribute could
        be successfully set. If the set fails, this call will return an error.
        Not all attributes can have values set. Attempting to set a value on a
        read-only attribute will result in an error (CUDA_ERROR_INVALID_VALUE)

        Supported attributes for the cuFuncSetAttribute call are:

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`: This
          maximum size in bytes of dynamically-allocated shared memory. The
          value should contain the requested maximum size of dynamically-
          allocated shared memory. The sum of this value and the function
          attribute :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES` cannot
          exceed the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN`.
          The maximal size of requestable dynamic shared memory may differ by
          GPU architecture.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`: On
          devices where the L1 cache and shared memory use the same hardware
          resources, this sets the shared memory carveout preference, in
          percent of the total shared memory. See
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR`
          This is only a hint, and the driver can choose a different ratio if
          required to execute the function.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH`: The required
          cluster width in blocks. The width, height, and depth values must
          either all be 0 or all be positive. The validity of the cluster
          dimensions is checked at launch time. If the value is set during
          compile time, it cannot be set at runtime. Setting it at runtime will
          return CUDA_ERROR_NOT_PERMITTED.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT`: The required
          cluster height in blocks. The width, height, and depth values must
          either all be 0 or all be positive. The validity of the cluster
          dimensions is checked at launch time. If the value is set during
          compile time, it cannot be set at runtime. Setting it at runtime will
          return CUDA_ERROR_NOT_PERMITTED.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH`: The required
          cluster depth in blocks. The width, height, and depth values must
          either all be 0 or all be positive. The validity of the cluster
          dimensions is checked at launch time. If the value is set during
          compile time, it cannot be set at runtime. Setting it at runtime will
          return CUDA_ERROR_NOT_PERMITTED.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED`:
          Indicates whether the function can be launched with non-portable
          cluster size. 1 is allowed, 0 is disallowed.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE`:
          The block scheduling policy of a function. The value type is
          CUclusterSchedulingPolicy.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            Function to query attribute of
        attrib : :py:obj:`~.CUfunction_attribute`
            Attribute requested
        value : int
            The value to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncGetAttributes`, :py:obj:`~.cudaFuncSetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    """


def cuFuncSetBlockShape(hfunc, x, y, z):
    """
    cuFuncSetBlockShape(hfunc, int x, int y, int z)
     Sets the block-dimensions for the function.

        [Deprecated]

        Specifies the `x`, `y`, and `z` dimensions of the thread blocks that
        are created when the kernel given by `hfunc` is launched.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            Kernel to specify dimensions of
        x : int
            X dimension
        y : int
            Y dimension
        z : int
            Z dimension

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """


def cuFuncSetCacheConfig(hfunc, config: 'CUfunc_cache'):
    """
    cuFuncSetCacheConfig(hfunc, config: CUfunc_cache)
     Sets the preferred cache configuration for a device function.

        On devices where the L1 cache and shared memory use the same hardware
        resources, this sets through `config` the preferred cache configuration
        for the device function `hfunc`. This is only a preference. The driver
        will use the requested configuration if possible, but it is free to
        choose a different configuration if required to execute `hfunc`. Any
        context-wide preference set via :py:obj:`~.cuCtxSetCacheConfig()` will
        be overridden by this per-function setting unless the per-function
        setting is :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`. In that case, the
        current context-wide setting will be used.

        This setting does nothing on devices where the size of the L1 cache and
        shared memory are fixed.

        Launching a kernel with a different preference than the most recent
        preference setting may insert a device-side synchronization point.

        The supported cache configurations are:

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`: no preference for shared
          memory or L1 (default)

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_SHARED`: prefer larger shared memory
          and smaller L1 cache

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_L1`: prefer larger L1 cache and
          smaller shared memory

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_EQUAL`: prefer equal sized L1 cache
          and shared memory

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            Kernel to configure cache for
        config : :py:obj:`~.CUfunc_cache`
            Requested cache configuration

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

        See Also
        --------
        :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncSetCacheConfig`, :py:obj:`~.cuKernelSetCacheConfig`
    """


def cuFuncSetSharedMemConfig(hfunc, config: 'CUsharedconfig'):
    """
    cuFuncSetSharedMemConfig(hfunc, config: CUsharedconfig)
     Sets the shared memory configuration for a device function.

        [Deprecated]

        On devices with configurable shared memory banks, this function will
        force all subsequent launches of the specified device function to have
        the given shared memory bank size configuration. On any given launch of
        the function, the shared memory configuration of the device will be
        temporarily changed if needed to suit the function's preferred
        configuration. Changes in shared memory configuration between
        subsequent launches of functions, may introduce a device side
        synchronization point.

        Any per-function setting of shared memory bank size set via
        :py:obj:`~.cuFuncSetSharedMemConfig` will override the context wide
        setting set with :py:obj:`~.cuCtxSetSharedMemConfig`.

        Changing the shared memory bank size will not increase shared memory
        usage or affect occupancy of kernels, but may have major effects on
        performance. Larger bank sizes will allow for greater potential
        bandwidth to shared memory, but will change what kinds of accesses to
        shared memory will result in bank conflicts.

        This function will do nothing on devices with fixed shared memory bank
        size.

        The supported bank configurations are:

        - :py:obj:`~.CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE`: use the context's
          shared memory configuration when launching this function.

        - :py:obj:`~.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE`: set shared
          memory bank width to be natively four bytes when launching this
          function.

        - :py:obj:`~.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE`: set shared
          memory bank width to be natively eight bytes when launching this
          function.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            kernel to be given a shared memory config
        config : :py:obj:`~.CUsharedconfig`
            requested shared memory configuration

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

        See Also
        --------
        :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuCtxSetSharedMemConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncSetSharedMemConfig`
    """


def cuFuncSetSharedSize(hfunc, numbytes):
    """
    cuFuncSetSharedSize(hfunc, unsigned int numbytes)
     Sets the dynamic shared-memory size for the function.

        [Deprecated]

        Sets through `numbytes` the amount of dynamic shared memory that will
        be available to each thread block when the kernel given by `hfunc` is
        launched.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            Kernel to specify dynamic shared-memory size for
        numbytes : unsigned int
            Dynamic shared-memory size per thread in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """


def cuGLGetDevices(cudaDeviceCount, deviceList: 'CUGLDeviceList'):
    """
    cuGLGetDevices(unsigned int cudaDeviceCount, deviceList: CUGLDeviceList)
     Gets the CUDA devices associated with the current OpenGL context.

        Returns in `*pCudaDeviceCount` the number of CUDA-compatible devices
        corresponding to the current OpenGL context. Also returns in
        `*pCudaDevices` at most cudaDeviceCount of the CUDA-compatible devices
        corresponding to the current OpenGL context. If any of the GPUs being
        used by the current OpenGL context are not CUDA capable then the call
        will return CUDA_ERROR_NO_DEVICE.

        The `deviceList` argument may be any of the following:
        CU_GL_DEVICE_LIST_ALL: Query all devices used by the current OpenGL
        context. CU_GL_DEVICE_LIST_CURRENT_FRAME: Query the devices used by the
        current OpenGL context to render the current frame (in SLI).
        CU_GL_DEVICE_LIST_NEXT_FRAME: Query the devices used by the current
        OpenGL context to render the next frame (in SLI). Note that this is a
        prediction, it can't be guaranteed that this is correct in all cases.

        Parameters
        ----------
        cudaDeviceCount : unsigned int
            The size of the output device array pCudaDevices.
        deviceList : CUGLDeviceList
            The set of devices to return.

        Returns
        -------
        CUresult
            CUDA_SUCCESS
            CUDA_ERROR_NO_DEVICE
            CUDA_ERROR_INVALID_VALUE
            CUDA_ERROR_INVALID_CONTEXT
            CUDA_ERROR_INVALID_GRAPHICS_CONTEXT
        pCudaDeviceCount : unsigned int
            Returned number of CUDA devices.
        pCudaDevices : List[CUdevice]
            Returned CUDA devices.

        See Also
        --------
        ~.cudaGLGetDevices

        Notes
        -----
        This function is not supported on Mac OS X.
    """


def cuGetErrorName(error: 'CUresult'):
    """
    cuGetErrorName(error: CUresult)
     Gets the string representation of an error code enum name.

        Sets `*pStr` to the address of a NULL-terminated string representation
        of the name of the enum error code `error`. If the error code is not
        recognized, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned and
        `*pStr` will be set to the NULL address.

        Parameters
        ----------
        error : :py:obj:`~.CUresult`
            Error code to convert to string

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pStr : bytes
            Address of the string pointer.

        See Also
        --------
        :py:obj:`~.CUresult`, :py:obj:`~.cudaGetErrorName`
    """


def cuGetErrorString(error: 'CUresult'):
    """
    cuGetErrorString(error: CUresult)
     Gets the string description of an error code.

        Sets `*pStr` to the address of a NULL-terminated string description of
        the error code `error`. If the error code is not recognized,
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned and `*pStr` will
        be set to the NULL address.

        Parameters
        ----------
        error : :py:obj:`~.CUresult`
            Error code to convert to string

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pStr : bytes
            Address of the string pointer.

        See Also
        --------
        :py:obj:`~.CUresult`, :py:obj:`~.cudaGetErrorString`
    """


def cuGetExportTable(pExportTableId: 'Optional[CUuuid]'):
    """
    cuGetExportTable(CUuuid pExportTableId: Optional[CUuuid])
 

        Parameters
        ----------
        pExportTableId : :py:obj:`~.CUuuid`
            None

        Returns
        -------
        CUresult

        ppExportTable : Any
            None
    """


def cuGetProcAddress(symbol, cudaVersion, flags):
    """
    cuGetProcAddress(char *symbol, int cudaVersion, flags)
     Returns the requested driver API function pointer.

        Returns in `**pfn` the address of the CUDA driver function for the
        requested CUDA version and flags.

        The CUDA version is specified as (1000 * major + 10 * minor), so CUDA
        11.2 should be specified as 11020. For a requested driver symbol, if
        the specified CUDA version is greater than or equal to the CUDA version
        in which the driver symbol was introduced, this API will return the
        function pointer to the corresponding versioned function.

        The pointer returned by the API should be cast to a function pointer
        matching the requested driver function's definition in the API header
        file. The function pointer typedef can be picked up from the
        corresponding typedefs header file. For example, cudaTypedefs.h
        consists of function pointer typedefs for driver APIs defined in
        :py:obj:`~.cuda.h`.

        The API will return :py:obj:`~.CUDA_SUCCESS` and set the returned `pfn`
        to NULL if the requested driver function is not supported on the
        platform, no ABI compatible driver function exists for the specified
        `cudaVersion` or if the driver symbol is invalid.

        It will also set the optional `symbolStatus` to one of the values in
        :py:obj:`~.CUdriverProcAddressQueryResult` with the following meanings:

        - :py:obj:`~.CU_GET_PROC_ADDRESS_SUCCESS` - The requested symbol was
          succesfully found based on input arguments and `pfn` is valid

        - :py:obj:`~.CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND` - The requested
          symbol was not found

        - :py:obj:`~.CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT` - The
          requested symbol was found but is not supported by cudaVersion
          specified

        The requested flags can be:

        - :py:obj:`~.CU_GET_PROC_ADDRESS_DEFAULT`: This is the default mode.
          This is equivalent to
          :py:obj:`~.CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM` if the code
          is compiled with --default-stream per-thread compilation flag or the
          macro CUDA_API_PER_THREAD_DEFAULT_STREAM is defined;
          :py:obj:`~.CU_GET_PROC_ADDRESS_LEGACY_STREAM` otherwise.

        - :py:obj:`~.CU_GET_PROC_ADDRESS_LEGACY_STREAM`: This will enable the
          search for all driver symbols that match the requested driver symbol
          name except the corresponding per-thread versions.

        - :py:obj:`~.CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM`: This will
          enable the search for all driver symbols that match the requested
          driver symbol name including the per-thread versions. If a per-thread
          version is not found, the API will return the legacy version of the
          driver function.

        Parameters
        ----------
        symbol : bytes
            The base name of the driver API function to look for. As an
            example, for the driver API :py:obj:`~.cuMemAlloc_v2`, `symbol`
            would be cuMemAlloc and `cudaVersion` would be the ABI compatible
            CUDA version for the _v2 variant.
        cudaVersion : int
            The CUDA version to look for the requested driver symbol
        flags : Any
            Flags to specify search options.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        pfn : Any
            Location to return the function pointer to the requested driver
            function
        symbolStatus : :py:obj:`~.CUdriverProcAddressQueryResult`
            Optional location to store the status of the search for `symbol`
            based on `cudaVersion`. See
            :py:obj:`~.CUdriverProcAddressQueryResult` for possible values.

        See Also
        --------
        :py:obj:`~.cudaGetDriverEntryPoint`
    """


def cuGraphAddBatchMemOpNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, nodeParams: 'Optional[CUDA_BATCH_MEM_OP_NODE_PARAMS]'):
    """
    cuGraphAddBatchMemOpNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, CUDA_BATCH_MEM_OP_NODE_PARAMS nodeParams: Optional[CUDA_BATCH_MEM_OP_NODE_PARAMS])
     Creates a batch memory operation node and adds it to a graph.

        Creates a new batch memory operation node and adds it to `hGraph` with
        `numDependencies` dependencies specified via `dependencies` and
        arguments specified in `nodeParams`. It is possible for
        `numDependencies` to be 0, in which case the node will be placed at the
        root of the graph. `dependencies` may not have any duplicate entries. A
        handle to the new node will be returned in `phGraphNode`.

        When the node is added, the paramArray inside `nodeParams` is copied
        and therefore it can be freed after the call returns.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        nodeParams : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
            Parameters for the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuGraphBatchMemOpNodeGetParams`, :py:obj:`~.cuGraphBatchMemOpNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`

        Notes
        -----
        Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order. For more information, see the Stream Memory Operations section in the programming guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).
    """


def cuGraphAddChildGraphNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, childGraph):
    """
    cuGraphAddChildGraphNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, childGraph)
     Creates a child graph node and adds it to a graph.

        Creates a new node which executes an embedded graph, and adds it to
        `hGraph` with `numDependencies` dependencies specified via
        `dependencies`. It is possible for `numDependencies` to be 0, in which
        case the node will be placed at the root of the graph. `dependencies`
        may not have any duplicate entries. A handle to the new node will be
        returned in `phGraphNode`.

        If `hGraph` contains allocation or free nodes, this call will return an
        error.

        The node executes an embedded child graph. The child graph is cloned in
        this call.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        childGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            The graph to clone into this node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphChildGraphNodeGetGraph`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphClone`
    """


def cuGraphAddDependencies(hGraph, from_: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', to: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies):
    """
    cuGraphAddDependencies(hGraph, from_: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], to: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies)
     Adds dependency edges to a graph.

        The number of dependencies to be added is defined by `numDependencies`
        Elements in `from` and `to` at corresponding indices define a
        dependency. Each node in `from` and `to` must belong to `hGraph`.

        If `numDependencies` is 0, elements in `from` and `to` will be ignored.
        Specifying an existing dependency will return an error.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which dependencies are added
        from : List[:py:obj:`~.CUgraphNode`]
            Array of nodes that provide the dependencies
        to : List[:py:obj:`~.CUgraphNode`]
            Array of dependent nodes
        numDependencies : size_t
            Number of dependencies to be added

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuGraphRemoveDependencies`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """


def cuGraphAddDependencies_v2(hGraph, from_: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', to: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', edgeData: 'Optional[Tuple[CUgraphEdgeData] | List[CUgraphEdgeData]]', numDependencies):
    """
    cuGraphAddDependencies_v2(hGraph, from_: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], to: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], edgeData: Optional[Tuple[CUgraphEdgeData] | List[CUgraphEdgeData]], size_t numDependencies)
     Adds dependency edges to a graph (12.3+)

        The number of dependencies to be added is defined by `numDependencies`
        Elements in `from` and `to` at corresponding indices define a
        dependency. Each node in `from` and `to` must belong to `hGraph`.

        If `numDependencies` is 0, elements in `from` and `to` will be ignored.
        Specifying an existing dependency will return an error.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which dependencies are added
        from : List[:py:obj:`~.CUgraphNode`]
            Array of nodes that provide the dependencies
        to : List[:py:obj:`~.CUgraphNode`]
            Array of dependent nodes
        edgeData : List[:py:obj:`~.CUgraphEdgeData`]
            Optional array of edge data. If NULL, default (zeroed) edge data is
            assumed.
        numDependencies : size_t
            Number of dependencies to be added

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuGraphRemoveDependencies`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """


def cuGraphAddEmptyNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies):
    """
    cuGraphAddEmptyNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies)
     Creates an empty node and adds it to a graph.

        Creates a new node which performs no operation, and adds it to `hGraph`
        with `numDependencies` dependencies specified via `dependencies`. It is
        possible for `numDependencies` to be 0, in which case the node will be
        placed at the root of the graph. `dependencies` may not have any
        duplicate entries. A handle to the new node will be returned in
        `phGraphNode`.

        An empty node performs no operation during execution, but can be used
        for transitive ordering. For example, a phased execution graph with 2
        groups of n nodes with a barrier between them can be represented using
        an empty node and 2*n dependency edges, rather than no empty node and
        n^2 dependency edges.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """


def cuGraphAddEventRecordNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, event):
    """
    cuGraphAddEventRecordNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, event)
     Creates an event record node and adds it to a graph.

        Creates a new event record node and adds it to `hGraph` with
        `numDependencies` dependencies specified via `dependencies` and event
        specified in `event`. It is possible for `numDependencies` to be 0, in
        which case the node will be placed at the root of the graph.
        `dependencies` may not have any duplicate entries. A handle to the new
        node will be returned in `phGraphNode`.

        Each launch of the graph will record `event` to capture execution of
        the node's dependencies.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event for the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """


def cuGraphAddEventWaitNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, event):
    """
    cuGraphAddEventWaitNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, event)
     Creates an event wait node and adds it to a graph.

        Creates a new event wait node and adds it to `hGraph` with
        `numDependencies` dependencies specified via `dependencies` and event
        specified in `event`. It is possible for `numDependencies` to be 0, in
        which case the node will be placed at the root of the graph.
        `dependencies` may not have any duplicate entries. A handle to the new
        node will be returned in `phGraphNode`.

        The graph node will wait for all work captured in `event`. See
        :py:obj:`~.cuEventRecord()` for details on what is captured by an
        event. `event` may be from a different context or device than the
        launch stream.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event for the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """


def cuGraphAddExternalSemaphoresSignalNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, nodeParams: 'Optional[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS]'):
    """
    cuGraphAddExternalSemaphoresSignalNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, CUDA_EXT_SEM_SIGNAL_NODE_PARAMS nodeParams: Optional[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS])
     Creates an external semaphore signal node and adds it to a graph.

        Creates a new external semaphore signal node and adds it to `hGraph`
        with `numDependencies` dependencies specified via `dependencies` and
        arguments specified in `nodeParams`. It is possible for
        `numDependencies` to be 0, in which case the node will be placed at the
        root of the graph. `dependencies` may not have any duplicate entries. A
        handle to the new node will be returned in `phGraphNode`.

        Performs a signal operation on a set of externally allocated semaphore
        objects when the node is launched. The operation(s) will occur after
        all of the node's dependencies have completed.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        nodeParams : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
            Parameters for the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphExternalSemaphoresSignalNodeGetParams`, :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """


def cuGraphAddExternalSemaphoresWaitNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, nodeParams: 'Optional[CUDA_EXT_SEM_WAIT_NODE_PARAMS]'):
    """
    cuGraphAddExternalSemaphoresWaitNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, CUDA_EXT_SEM_WAIT_NODE_PARAMS nodeParams: Optional[CUDA_EXT_SEM_WAIT_NODE_PARAMS])
     Creates an external semaphore wait node and adds it to a graph.

        Creates a new external semaphore wait node and adds it to `hGraph` with
        `numDependencies` dependencies specified via `dependencies` and
        arguments specified in `nodeParams`. It is possible for
        `numDependencies` to be 0, in which case the node will be placed at the
        root of the graph. `dependencies` may not have any duplicate entries. A
        handle to the new node will be returned in `phGraphNode`.

        Performs a wait operation on a set of externally allocated semaphore
        objects when the node is launched. The node's dependencies will not be
        launched until the wait operation has completed.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        nodeParams : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
            Parameters for the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphExternalSemaphoresWaitNodeGetParams`, :py:obj:`~.cuGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """


def cuGraphAddHostNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, nodeParams: 'Optional[CUDA_HOST_NODE_PARAMS]'):
    """
    cuGraphAddHostNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, CUDA_HOST_NODE_PARAMS nodeParams: Optional[CUDA_HOST_NODE_PARAMS])
     Creates a host execution node and adds it to a graph.

        Creates a new CPU execution node and adds it to `hGraph` with
        `numDependencies` dependencies specified via `dependencies` and
        arguments specified in `nodeParams`. It is possible for
        `numDependencies` to be 0, in which case the node will be placed at the
        root of the graph. `dependencies` may not have any duplicate entries. A
        handle to the new node will be returned in `phGraphNode`.

        When the graph is launched, the node will invoke the specified CPU
        function. Host nodes are not supported under MPS with pre-Volta GPUs.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
            Parameters for the host node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuLaunchHostFunc`, :py:obj:`~.cuGraphHostNodeGetParams`, :py:obj:`~.cuGraphHostNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """


def cuGraphAddKernelNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, nodeParams: 'Optional[CUDA_KERNEL_NODE_PARAMS]'):
    """
    cuGraphAddKernelNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, CUDA_KERNEL_NODE_PARAMS nodeParams: Optional[CUDA_KERNEL_NODE_PARAMS])
     Creates a kernel execution node and adds it to a graph.

        Creates a new kernel execution node and adds it to `hGraph` with
        `numDependencies` dependencies specified via `dependencies` and
        arguments specified in `nodeParams`. It is possible for
        `numDependencies` to be 0, in which case the node will be placed at the
        root of the graph. `dependencies` may not have any duplicate entries. A
        handle to the new node will be returned in `phGraphNode`.

        The CUDA_KERNEL_NODE_PARAMS structure is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        When the graph is launched, the node will invoke kernel `func` on a
        (`gridDimX` x `gridDimY` x `gridDimZ`) grid of blocks. Each block
        contains (`blockDimX` x `blockDimY` x `blockDimZ`) threads.

        `sharedMemBytes` sets the amount of dynamic shared memory that will be
        available to each thread block.

        Kernel parameters to `func` can be specified in one of two ways:

        1) Kernel parameters can be specified via `kernelParams`. If the kernel
        has N parameters, then `kernelParams` needs to be an array of N
        pointers. Each pointer, from `kernelParams`[0] to `kernelParams`[N-1],
        points to the region of memory from which the actual parameter will be
        copied. The number of kernel parameters and their offsets and sizes do
        not need to be specified as that information is retrieved directly from
        the kernel's image.

        2) Kernel parameters for non-cooperative kernels can also be packaged
        by the application into a single buffer that is passed in via `extra`.
        This places the burden on the application of knowing each kernel
        parameter's size and alignment/padding within the buffer. The `extra`
        parameter exists to allow this function to take additional less
        commonly used arguments. `extra` specifies a list of names of extra
        settings and their corresponding values. Each extra setting name is
        immediately followed by the corresponding value. The list must be
        terminated with either NULL or CU_LAUNCH_PARAM_END.

        - :py:obj:`~.CU_LAUNCH_PARAM_END`, which indicates the end of the
          `extra` array;

        - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`, which specifies that the
          next value in `extra` will be a pointer to a buffer containing all
          the kernel parameters for launching kernel `func`;

        - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_SIZE`, which specifies that the
          next value in `extra` will be a pointer to a size_t containing the
          size of the buffer specified with
          :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`;

        The error :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned if
        kernel parameters are specified with both `kernelParams` and `extra`
        (i.e. both `kernelParams` and `extra` are non-NULL).
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned if `extra` is
        used for a cooperative kernel.

        The `kernelParams` or `extra` array, as well as the argument values it
        points to, are copied during this call.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
            Parameters for the GPU execution node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuLaunchCooperativeKernel`, :py:obj:`~.cuGraphKernelNodeGetParams`, :py:obj:`~.cuGraphKernelNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`

        Notes
        -----
        Kernels launched using graphs must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.
    """


def cuGraphAddMemAllocNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, nodeParams: 'Optional[CUDA_MEM_ALLOC_NODE_PARAMS]'):
    """
    cuGraphAddMemAllocNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, CUDA_MEM_ALLOC_NODE_PARAMS nodeParams: Optional[CUDA_MEM_ALLOC_NODE_PARAMS])
     Creates an allocation node and adds it to a graph.

        Creates a new allocation node and adds it to `hGraph` with
        `numDependencies` dependencies specified via `dependencies` and
        arguments specified in `nodeParams`. It is possible for
        `numDependencies` to be 0, in which case the node will be placed at the
        root of the graph. `dependencies` may not have any duplicate entries. A
        handle to the new node will be returned in `phGraphNode`.

        When :py:obj:`~.cuGraphAddMemAllocNode` creates an allocation node, it
        returns the address of the allocation in `nodeParams.dptr`. The
        allocation's address remains fixed across instantiations and launches.

        If the allocation is freed in the same graph, by creating a free node
        using :py:obj:`~.cuGraphAddMemFreeNode`, the allocation can be accessed
        by nodes ordered after the allocation node but before the free node.
        These allocations cannot be freed outside the owning graph, and they
        can only be freed once in the owning graph.

        If the allocation is not freed in the same graph, then it can be
        accessed not only by nodes in the graph which are ordered after the
        allocation node, but also by stream operations ordered after the
        graph's execution but before the allocation is freed.

        Allocations which are not freed in the same graph can be freed by:

        - passing the allocation to :py:obj:`~.cuMemFreeAsync` or
          :py:obj:`~.cuMemFree`;

        - launching a graph with a free node for that allocation; or

        - specifying
          :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH` during
          instantiation, which makes each launch behave as though it called
          :py:obj:`~.cuMemFreeAsync` for every unfreed allocation.

        It is not possible to free an allocation in both the owning graph and
        another graph. If the allocation is freed in the same graph, a free
        node cannot be added to another graph. If the allocation is freed in
        another graph, a free node can no longer be added to the owning graph.

        The following restrictions apply to graphs which contain allocation
        and/or memory free nodes:

        - Nodes and edges of the graph cannot be deleted.

        - The graph cannot be used in a child node.

        - Only one instantiation of the graph may exist at any point in time.

        - The graph cannot be cloned.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        nodeParams : :py:obj:`~.CUDA_MEM_ALLOC_NODE_PARAMS`
            Parameters for the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphAddMemFreeNode`, :py:obj:`~.cuGraphMemAllocNodeGetParams`, :py:obj:`~.cuDeviceGraphMemTrim`, :py:obj:`~.cuDeviceGetGraphMemAttribute`, :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """


def cuGraphAddMemFreeNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, dptr):
    """
    cuGraphAddMemFreeNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, dptr)
     Creates a memory free node and adds it to a graph.

        Creates a new memory free node and adds it to `hGraph` with
        `numDependencies` dependencies specified via `dependencies` and
        arguments specified in `nodeParams`. It is possible for
        `numDependencies` to be 0, in which case the node will be placed at the
        root of the graph. `dependencies` may not have any duplicate entries. A
        handle to the new node will be returned in `phGraphNode`.

        :py:obj:`~.cuGraphAddMemFreeNode` will return
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the user attempts to free:

        - an allocation twice in the same graph.

        - an address that was not returned by an allocation node.

        - an invalid address.

        The following restrictions apply to graphs which contain allocation
        and/or memory free nodes:

        - Nodes and edges of the graph cannot be deleted.

        - The graph cannot be used in a child node.

        - Only one instantiation of the graph may exist at any point in time.

        - The graph cannot be cloned.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        dptr : :py:obj:`~.CUdeviceptr`
            Address of memory to free

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphMemFreeNodeGetParams`, :py:obj:`~.cuDeviceGraphMemTrim`, :py:obj:`~.cuDeviceGetGraphMemAttribute`, :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """


def cuGraphAddMemcpyNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, copyParams: 'Optional[CUDA_MEMCPY3D]', ctx):
    """
    cuGraphAddMemcpyNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, CUDA_MEMCPY3D copyParams: Optional[CUDA_MEMCPY3D], ctx)
     Creates a memcpy node and adds it to a graph.

        Creates a new memcpy node and adds it to `hGraph` with
        `numDependencies` dependencies specified via `dependencies`. It is
        possible for `numDependencies` to be 0, in which case the node will be
        placed at the root of the graph. `dependencies` may not have any
        duplicate entries. A handle to the new node will be returned in
        `phGraphNode`.

        When the graph is launched, the node will perform the memcpy described
        by `copyParams`. See :py:obj:`~.cuMemcpy3D()` for a description of the
        structure and its restrictions.

        Memcpy nodes have some additional restrictions with regards to managed
        memory, if the system contains at least one device which has a zero
        value for the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. If one or
        more of the operands refer to managed memory, then using the memory
        type :py:obj:`~.CU_MEMORYTYPE_UNIFIED` is disallowed for those
        operand(s). The managed memory will be treated as residing on either
        the host or the device, depending on which memory type is specified.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        copyParams : :py:obj:`~.CUDA_MEMCPY3D`
            Parameters for the memory copy
        ctx : :py:obj:`~.CUcontext`
            Context on which to run the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuGraphMemcpyNodeGetParams`, :py:obj:`~.cuGraphMemcpyNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """


def cuGraphAddMemsetNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, memsetParams: 'Optional[CUDA_MEMSET_NODE_PARAMS]', ctx):
    """
    cuGraphAddMemsetNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, CUDA_MEMSET_NODE_PARAMS memsetParams: Optional[CUDA_MEMSET_NODE_PARAMS], ctx)
     Creates a memset node and adds it to a graph.

        Creates a new memset node and adds it to `hGraph` with
        `numDependencies` dependencies specified via `dependencies`. It is
        possible for `numDependencies` to be 0, in which case the node will be
        placed at the root of the graph. `dependencies` may not have any
        duplicate entries. A handle to the new node will be returned in
        `phGraphNode`.

        The element size must be 1, 2, or 4 bytes. When the graph is launched,
        the node will perform the memset described by `memsetParams`.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        memsetParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
            Parameters for the memory set
        ctx : :py:obj:`~.CUcontext`
            Context on which to run the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuGraphMemsetNodeGetParams`, :py:obj:`~.cuGraphMemsetNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`
    """


def cuGraphAddNode(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, nodeParams: 'Optional[CUgraphNodeParams]'):
    """
    cuGraphAddNode(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, CUgraphNodeParams nodeParams: Optional[CUgraphNodeParams])
     Adds a node of arbitrary type to a graph.

        Creates a new node in `hGraph` described by `nodeParams` with
        `numDependencies` dependencies specified via `dependencies`.
        `numDependencies` may be 0. `dependencies` may be null if
        `numDependencies` is 0. `dependencies` may not have any duplicate
        entries.

        `nodeParams` is a tagged union. The node type should be specified in
        the `typename` field, and type-specific parameters in the corresponding
        union member. All unused bytes - that is, `reserved0` and all bytes
        past the utilized union member - must be set to zero. It is recommended
        to use brace initialization or memset to ensure all bytes are
        initialized.

        Note that for some node types, `nodeParams` may contain "out
        parameters" which are modified during the call, such as
        `nodeParams->alloc.dptr`.

        A handle to the new node will be returned in `phGraphNode`.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        numDependencies : size_t
            Number of dependencies
        nodeParams : :py:obj:`~.CUgraphNodeParams`
            Specification of the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuGraphExecNodeSetParams`
    """


def cuGraphAddNode_v2(hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', dependencyData: 'Optional[Tuple[CUgraphEdgeData] | List[CUgraphEdgeData]]', numDependencies, nodeParams: 'Optional[CUgraphNodeParams]'):
    """
    cuGraphAddNode_v2(hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], dependencyData: Optional[Tuple[CUgraphEdgeData] | List[CUgraphEdgeData]], size_t numDependencies, CUgraphNodeParams nodeParams: Optional[CUgraphNodeParams])
     Adds a node of arbitrary type to a graph (12.3+)

        Creates a new node in `hGraph` described by `nodeParams` with
        `numDependencies` dependencies specified via `dependencies`.
        `numDependencies` may be 0. `dependencies` may be null if
        `numDependencies` is 0. `dependencies` may not have any duplicate
        entries.

        `nodeParams` is a tagged union. The node type should be specified in
        the `typename` field, and type-specific parameters in the corresponding
        union member. All unused bytes - that is, `reserved0` and all bytes
        past the utilized union member - must be set to zero. It is recommended
        to use brace initialization or memset to ensure all bytes are
        initialized.

        Note that for some node types, `nodeParams` may contain "out
        parameters" which are modified during the call, such as
        `nodeParams->alloc.dptr`.

        A handle to the new node will be returned in `phGraphNode`.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to which to add the node
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the node
        dependencyData : List[:py:obj:`~.CUgraphEdgeData`]
            Optional edge data for the dependencies. If NULL, the data is
            assumed to be default (zeroed) for all dependencies.
        numDependencies : size_t
            Number of dependencies
        nodeParams : :py:obj:`~.CUgraphNodeParams`
            Specification of the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        phGraphNode : :py:obj:`~.CUgraphNode`
            Returns newly created node

        See Also
        --------
        :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuGraphExecNodeSetParams`
    """


def cuGraphBatchMemOpNodeGetParams(hNode):
    """
    cuGraphBatchMemOpNodeGetParams(hNode)
     Returns a batch mem op node's parameters.

        Returns the parameters of batch mem op node `hNode` in
        `nodeParams_out`. The `paramArray` returned in `nodeParams_out` is
        owned by the node. This memory remains valid until the node is
        destroyed or its parameters are modified, and should not be modified
        directly. Use :py:obj:`~.cuGraphBatchMemOpNodeSetParams` to update the
        parameters of this node.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the parameters for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        nodeParams_out : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
            Pointer to return the parameters

        See Also
        --------
        :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuGraphAddBatchMemOpNode`, :py:obj:`~.cuGraphBatchMemOpNodeSetParams`
    """


def cuGraphBatchMemOpNodeSetParams(hNode, nodeParams: 'Optional[CUDA_BATCH_MEM_OP_NODE_PARAMS]'):
    """
    cuGraphBatchMemOpNodeSetParams(hNode, CUDA_BATCH_MEM_OP_NODE_PARAMS nodeParams: Optional[CUDA_BATCH_MEM_OP_NODE_PARAMS])
     Sets a batch mem op node's parameters.

        Sets the parameters of batch mem op node `hNode` to `nodeParams`.

        The paramArray inside `nodeParams` is copied and therefore it can be
        freed after the call returns.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to set the parameters for
        nodeParams : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
            Parameters to copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

        See Also
        --------
        :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuGraphAddBatchMemOpNode`, :py:obj:`~.cuGraphBatchMemOpNodeGetParams`
    """


def cuGraphChildGraphNodeGetGraph(hNode):
    """
    cuGraphChildGraphNodeGetGraph(hNode)
     Gets a handle to the embedded graph of a child graph node.

        Gets a handle to the embedded graph in a child graph node. This call
        does not clone the graph. Changes to the graph will be reflected in the
        node, and the node retains ownership of the graph.

        Allocation and free nodes cannot be added to the returned graph.
        Attempting to do so will return an error.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the embedded graph for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        phGraph : :py:obj:`~.CUgraph`
            Location to store a handle to the graph

        See Also
        --------
        :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphNodeFindInClone`
    """


def cuGraphClone(originalGraph):
    """
    cuGraphClone(originalGraph)
     Clones a graph.

        This function creates a copy of `originalGraph` and returns it in
        `phGraphClone`. All parameters are copied into the cloned graph. The
        original graph may be modified after this call without affecting the
        clone.

        Child graph nodes in the original graph are recursively copied into the
        clone.

        Parameters
        ----------
        originalGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to clone

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        phGraphClone : :py:obj:`~.CUgraph`
            Returns newly created cloned graph

        See Also
        --------
        :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphNodeFindInClone`
    """


def cuGraphConditionalHandleCreate(hGraph, ctx, defaultLaunchValue, flags):
    """
    cuGraphConditionalHandleCreate(hGraph, ctx, unsigned int defaultLaunchValue, unsigned int flags)
     Create a conditional handle.

        Creates a conditional handle associated with `hGraph`.

        The conditional handle must be associated with a conditional node in
        this graph or one of its children.

        Handles not associated with a conditional node may cause graph
        instantiation to fail.

        Handles can only be set from the context with which they are
        associated.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph which will contain the conditional node using this handle.
        ctx : :py:obj:`~.CUcontext`
            Context for the handle and associated conditional node.
        defaultLaunchValue : unsigned int
            Optional initial value for the conditional variable. Applied at the
            beginning of each graph execution if CU_GRAPH_COND_ASSIGN_DEFAULT
            is set in `flags`.
        flags : unsigned int
            Currently must be CU_GRAPH_COND_ASSIGN_DEFAULT or 0.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        pHandle_out : :py:obj:`~.CUgraphConditionalHandle`
            Pointer used to return the handle to the caller.

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`
    """


def cuGraphCreate(flags):
    """
    cuGraphCreate(unsigned int flags)
     Creates a graph.

        Creates an empty graph, which is returned via `phGraph`.

        Parameters
        ----------
        flags : unsigned int
            Graph creation flags, must be 0

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        phGraph : :py:obj:`~.CUgraph`
            Returns newly created graph

        See Also
        --------
        :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphDestroy`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphClone`
    """


def cuGraphDebugDotPrint(hGraph, path, flags):
    """
    cuGraphDebugDotPrint(hGraph, char *path, unsigned int flags)
     Write a DOT file describing graph structure.

        Using the provided `hGraph`, write to `path` a DOT formatted
        description of the graph. By default this includes the graph topology,
        node types, node id, kernel names and memcpy direction. `flags` can be
        specified to write more detailed information about each node type such
        as parameter values, kernel attributes, node and function handles.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            The graph to create a DOT file from
        path : bytes
            The path to write the DOT file to
        flags : unsigned int
            Flags from CUgraphDebugDot_flags for specifying which additional
            node information to write

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OPERATING_SYSTEM`
    """


def cuGraphDestroy(hGraph):
    """
    cuGraphDestroy(hGraph)
     Destroys a graph.

        Destroys the graph specified by `hGraph`, as well as all of its nodes.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to destroy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuGraphCreate`
    """


def cuGraphDestroyNode(hNode):
    """
    cuGraphDestroyNode(hNode)
     Remove a node from the graph.

        Removes `hNode` from its graph. This operation also severs any
        dependencies of other nodes on `hNode` and vice versa.

        Nodes which belong to a graph which contains allocation or free nodes
        cannot be destroyed. Any attempt to do so will return an error.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to remove

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """


def cuGraphEventRecordNodeGetEvent(hNode):
    """
    cuGraphEventRecordNodeGetEvent(hNode)
     Returns the event associated with an event record node.

        Returns the event of event record node `hNode` in `event_out`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the event for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        event_out : :py:obj:`~.CUevent`
            Pointer to return the event

        See Also
        --------
        :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphEventRecordNodeSetEvent`, :py:obj:`~.cuGraphEventWaitNodeGetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """


def cuGraphEventRecordNodeSetEvent(hNode, event):
    """
    cuGraphEventRecordNodeSetEvent(hNode, event)
     Sets an event record node's event.

        Sets the event of event record node `hNode` to `event`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to set the event for
        event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to use

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

        See Also
        --------
        :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphEventRecordNodeGetEvent`, :py:obj:`~.cuGraphEventWaitNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """


def cuGraphEventWaitNodeGetEvent(hNode):
    """
    cuGraphEventWaitNodeGetEvent(hNode)
     Returns the event associated with an event wait node.

        Returns the event of event wait node `hNode` in `event_out`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the event for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        event_out : :py:obj:`~.CUevent`
            Pointer to return the event

        See Also
        --------
        :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphEventWaitNodeSetEvent`, :py:obj:`~.cuGraphEventRecordNodeGetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """


def cuGraphEventWaitNodeSetEvent(hNode, event):
    """
    cuGraphEventWaitNodeSetEvent(hNode, event)
     Sets an event wait node's event.

        Sets the event of event wait node `hNode` to `event`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to set the event for
        event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to use

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

        See Also
        --------
        :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphEventWaitNodeGetEvent`, :py:obj:`~.cuGraphEventRecordNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """


def cuGraphExecBatchMemOpNodeSetParams(hGraphExec, hNode, nodeParams: 'Optional[CUDA_BATCH_MEM_OP_NODE_PARAMS]'):
    """
    cuGraphExecBatchMemOpNodeSetParams(hGraphExec, hNode, CUDA_BATCH_MEM_OP_NODE_PARAMS nodeParams: Optional[CUDA_BATCH_MEM_OP_NODE_PARAMS])
     Sets the parameters for a batch mem op node in the given graphExec.

        Sets the parameters of a batch mem op node in an executable graph
        `hGraphExec`. The node is identified by the corresponding node `hNode`
        in the non-executable graph, from which the executable graph was
        instantiated.

        The following fields on operations may be modified on an executable
        graph:

        op.waitValue.address op.waitValue.value[64] op.waitValue.flags bits
        corresponding to wait type (i.e. CU_STREAM_WAIT_VALUE_FLUSH bit cannot
        be modified) op.writeValue.address op.writeValue.value[64]

        Other fields, such as the context, count or type of operations, and
        other types of operations such as membars, may not be modified.

        `hNode` must not have been removed from the original graph.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. `hNode` is also not modified by this call.

        The paramArray inside `nodeParams` is copied and therefore it can be
        freed after the call returns.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Batch mem op node from the graph from which graphExec was
            instantiated
        nodeParams : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
            Updated Parameters to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuGraphAddBatchMemOpNode`, :py:obj:`~.cuGraphBatchMemOpNodeGetParams`, :py:obj:`~.cuGraphBatchMemOpNodeSetParams`, :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExecChildGraphNodeSetParams(hGraphExec, hNode, childGraph):
    """
    cuGraphExecChildGraphNodeSetParams(hGraphExec, hNode, childGraph)
     Updates node parameters in the child graph node in the given graphExec.

        Updates the work represented by `hNode` in `hGraphExec` as though the
        nodes contained in `hNode's` graph had the parameters contained in
        `childGraph's` nodes at instantiation. `hNode` must remain in the graph
        which was used to instantiate `hGraphExec`. Changed edges to and from
        `hNode` are ignored.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. `hNode` is also not modified by this call.

        The topology of `childGraph`, as well as the node insertion order, must
        match that of the graph contained in `hNode`. See
        :py:obj:`~.cuGraphExecUpdate()` for a list of restrictions on what can
        be updated in an instantiated graph. The update is recursive, so child
        graph nodes contained within the top level child graph will also be
        updated.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Host node from the graph which was used to instantiate graphExec
        childGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            The graph supplying the updated parameters

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphChildGraphNodeGetGraph`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExecDestroy(hGraphExec):
    """
    cuGraphExecDestroy(hGraphExec)
     Destroys an executable graph.

        Destroys the executable graph specified by `hGraphExec`, as well as all
        of its executable nodes. If the executable graph is in-flight, it will
        not be terminated, but rather freed asynchronously on completion.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            Executable graph to destroy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphUpload`, :py:obj:`~.cuGraphLaunch`
    """


def cuGraphExecEventRecordNodeSetEvent(hGraphExec, hNode, event):
    """
    cuGraphExecEventRecordNodeSetEvent(hGraphExec, hNode, event)
     Sets the event for an event record node in the given graphExec.

        Sets the event of an event record node in an executable graph
        `hGraphExec`. The node is identified by the corresponding node `hNode`
        in the non-executable graph, from which the executable graph was
        instantiated.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. `hNode` is also not modified by this call.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            event record node from the graph from which graphExec was
            instantiated
        event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Updated event to use

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphEventRecordNodeGetEvent`, :py:obj:`~.cuGraphEventWaitNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExecEventWaitNodeSetEvent(hGraphExec, hNode, event):
    """
    cuGraphExecEventWaitNodeSetEvent(hGraphExec, hNode, event)
     Sets the event for an event wait node in the given graphExec.

        Sets the event of an event wait node in an executable graph
        `hGraphExec`. The node is identified by the corresponding node `hNode`
        in the non-executable graph, from which the executable graph was
        instantiated.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. `hNode` is also not modified by this call.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            event wait node from the graph from which graphExec was
            instantiated
        event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Updated event to use

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphEventWaitNodeGetEvent`, :py:obj:`~.cuGraphEventRecordNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExecExternalSemaphoresSignalNodeSetParams(hGraphExec, hNode, nodeParams: 'Optional[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS]'):
    """
    cuGraphExecExternalSemaphoresSignalNodeSetParams(hGraphExec, hNode, CUDA_EXT_SEM_SIGNAL_NODE_PARAMS nodeParams: Optional[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS])
     Sets the parameters for an external semaphore signal node in the given graphExec.

        Sets the parameters of an external semaphore signal node in an
        executable graph `hGraphExec`. The node is identified by the
        corresponding node `hNode` in the non-executable graph, from which the
        executable graph was instantiated.

        `hNode` must not have been removed from the original graph.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. `hNode` is also not modified by this call.

        Changing `nodeParams->numExtSems` is not supported.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            semaphore signal node from the graph from which graphExec was
            instantiated
        nodeParams : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
            Updated Parameters to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExecExternalSemaphoresWaitNodeSetParams(hGraphExec, hNode, nodeParams: 'Optional[CUDA_EXT_SEM_WAIT_NODE_PARAMS]'):
    """
    cuGraphExecExternalSemaphoresWaitNodeSetParams(hGraphExec, hNode, CUDA_EXT_SEM_WAIT_NODE_PARAMS nodeParams: Optional[CUDA_EXT_SEM_WAIT_NODE_PARAMS])
     Sets the parameters for an external semaphore wait node in the given graphExec.

        Sets the parameters of an external semaphore wait node in an executable
        graph `hGraphExec`. The node is identified by the corresponding node
        `hNode` in the non-executable graph, from which the executable graph
        was instantiated.

        `hNode` must not have been removed from the original graph.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. `hNode` is also not modified by this call.

        Changing `nodeParams->numExtSems` is not supported.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            semaphore wait node from the graph from which graphExec was
            instantiated
        nodeParams : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
            Updated Parameters to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExecGetFlags(hGraphExec):
    """
    cuGraphExecGetFlags(hGraphExec)
     Query the instantiation flags of an executable graph.

        Returns the flags that were passed to instantiation for the given
        executable graph. :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD` will
        not be returned by this API as it does not affect the resulting
        executable graph.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        flags : :py:obj:`~.cuuint64_t`
            Returns the instantiation flags

        See Also
        --------
        :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphInstantiateWithParams`
    """


def cuGraphExecHostNodeSetParams(hGraphExec, hNode, nodeParams: 'Optional[CUDA_HOST_NODE_PARAMS]'):
    """
    cuGraphExecHostNodeSetParams(hGraphExec, hNode, CUDA_HOST_NODE_PARAMS nodeParams: Optional[CUDA_HOST_NODE_PARAMS])
     Sets the parameters for a host node in the given graphExec.

        Updates the work represented by `hNode` in `hGraphExec` as though
        `hNode` had contained `nodeParams` at instantiation. hNode must remain
        in the graph which was used to instantiate `hGraphExec`. Changed edges
        to and from hNode are ignored.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. hNode is also not modified by this call.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Host node from the graph which was used to instantiate graphExec
        nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
            The updated parameters to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphHostNodeSetParams`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExecKernelNodeSetParams(hGraphExec, hNode, nodeParams: 'Optional[CUDA_KERNEL_NODE_PARAMS]'):
    """
    cuGraphExecKernelNodeSetParams(hGraphExec, hNode, CUDA_KERNEL_NODE_PARAMS nodeParams: Optional[CUDA_KERNEL_NODE_PARAMS])
     Sets the parameters for a kernel node in the given graphExec.

        Sets the parameters of a kernel node in an executable graph
        `hGraphExec`. The node is identified by the corresponding node `hNode`
        in the non-executable graph, from which the executable graph was
        instantiated.

        `hNode` must not have been removed from the original graph. All
        `nodeParams` fields may change, but the following restrictions apply to
        `func` updates:

        - The owning context of the function cannot change.

        - A node whose function originally did not use CUDA dynamic parallelism
          cannot be updated to a function which uses CDP

        - A node whose function originally did not make device-side update
          calls cannot be updated to a function which makes device-side update
          calls.

        - If `hGraphExec` was not instantiated for device launch, a node whose
          function originally did not use device-side cudaGraphLaunch() cannot
          be updated to a function which uses device-side cudaGraphLaunch()
          unless the node resides on the same context as nodes which contained
          such calls at instantiate-time. If no such calls were present at
          instantiation, these updates cannot be performed at all.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. `hNode` is also not modified by this call.

        If `hNode` is a device-updatable kernel node, the next upload/launch of
        `hGraphExec` will overwrite any previous device-side updates.
        Additionally, applying host updates to a device-updatable kernel node
        while it is being updated from the device will result in undefined
        behavior.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            kernel node from the graph from which graphExec was instantiated
        nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
            Updated Parameters to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExecMemcpyNodeSetParams(hGraphExec, hNode, copyParams: 'Optional[CUDA_MEMCPY3D]', ctx):
    """
    cuGraphExecMemcpyNodeSetParams(hGraphExec, hNode, CUDA_MEMCPY3D copyParams: Optional[CUDA_MEMCPY3D], ctx)
     Sets the parameters for a memcpy node in the given graphExec.

        Updates the work represented by `hNode` in `hGraphExec` as though
        `hNode` had contained `copyParams` at instantiation. hNode must remain
        in the graph which was used to instantiate `hGraphExec`. Changed edges
        to and from hNode are ignored.

        The source and destination memory in `copyParams` must be allocated
        from the same contexts as the original source and destination memory.
        Both the instantiation-time memory operands and the memory operands in
        `copyParams` must be 1-dimensional. Zero-length operations are not
        supported.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. hNode is also not modified by this call.

        Returns CUDA_ERROR_INVALID_VALUE if the memory operands' mappings
        changed or either the original or new memory operands are
        multidimensional.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Memcpy node from the graph which was used to instantiate graphExec
        copyParams : :py:obj:`~.CUDA_MEMCPY3D`
            The updated parameters to set
        ctx : :py:obj:`~.CUcontext`
            Context on which to run the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExecMemsetNodeSetParams(hGraphExec, hNode, memsetParams: 'Optional[CUDA_MEMSET_NODE_PARAMS]', ctx):
    """
    cuGraphExecMemsetNodeSetParams(hGraphExec, hNode, CUDA_MEMSET_NODE_PARAMS memsetParams: Optional[CUDA_MEMSET_NODE_PARAMS], ctx)
     Sets the parameters for a memset node in the given graphExec.

        Updates the work represented by `hNode` in `hGraphExec` as though
        `hNode` had contained `memsetParams` at instantiation. hNode must
        remain in the graph which was used to instantiate `hGraphExec`. Changed
        edges to and from hNode are ignored.

        Zero sized operations are not supported.

        The new destination pointer in memsetParams must be to the same kind of
        allocation as the original destination pointer and have the same
        context association and device mapping as the original destination
        pointer.

        Both the value and pointer address may be updated.   Changing other
        aspects of the memset (width, height, element size or pitch) may cause
        the update to be rejected. Specifically, for 2d memsets, all dimension
        changes are rejected. For 1d memsets, changes in height are explicitly
        rejected and other changes are oportunistically allowed if the
        resulting work maps onto the work resources already allocated for the
        node.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. hNode is also not modified by this call.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Memset node from the graph which was used to instantiate graphExec
        memsetParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
            The updated parameters to set
        ctx : :py:obj:`~.CUcontext`
            Context on which to run the node

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphMemsetNodeSetParams`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExecNodeSetParams(hGraphExec, hNode, nodeParams: 'Optional[CUgraphNodeParams]'):
    """
    cuGraphExecNodeSetParams(hGraphExec, hNode, CUgraphNodeParams nodeParams: Optional[CUgraphNodeParams])
     Update's a graph node's parameters in an instantiated graph.

        Sets the parameters of a node in an executable graph `hGraphExec`. The
        node is identified by the corresponding node `hNode` in the non-
        executable graph from which the executable graph was instantiated.
        `hNode` must not have been removed from the original graph.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. `hNode` is also not modified by this call.

        Allowed changes to parameters on executable graphs are as follows:

        **View CUDA Toolkit Documentation for a table example**

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to update the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Corresponding node from the graph from which graphExec was
            instantiated
        nodeParams : :py:obj:`~.CUgraphNodeParams`
            Updated Parameters to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphNodeSetParams` :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExecUpdate(hGraphExec, hGraph):
    """
    cuGraphExecUpdate(hGraphExec, hGraph)
     Check whether an executable graph can be updated with a graph and perform the update if possible.

        Updates the node parameters in the instantiated graph specified by
        `hGraphExec` with the node parameters in a topologically identical
        graph specified by `hGraph`.

        Limitations:

        - Kernel nodes:

          - The owning context of the function cannot change.

          - A node whose function originally did not use CUDA dynamic
            parallelism cannot be updated to a function which uses CDP.

          - A node whose function originally did not make device-side update
            calls cannot be updated to a function which makes device-side
            update calls.

          - A cooperative node cannot be updated to a non-cooperative node, and
            vice-versa.

          - If the graph was instantiated with
            CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY, the priority
            attribute cannot change. Equality is checked on the originally
            requested priority values, before they are clamped to the device's
            supported range.

          - If `hGraphExec` was not instantiated for device launch, a node
            whose function originally did not use device-side cudaGraphLaunch()
            cannot be updated to a function which uses device-side
            cudaGraphLaunch() unless the node resides on the same context as
            nodes which contained such calls at instantiate-time. If no such
            calls were present at instantiation, these updates cannot be
            performed at all.

          - Neither `hGraph` nor `hGraphExec` may contain device-updatable
            kernel nodes.

        - Memset and memcpy nodes:

          - The CUDA device(s) to which the operand(s) was allocated/mapped
            cannot change.

          - The source/destination memory must be allocated from the same
            contexts as the original source/destination memory.

          - For 2d memsets, only address and assinged value may be updated.

          - For 1d memsets, updating dimensions is also allowed, but may fail
            if the resulting operation doesn't map onto the work resources
            already allocated for the node.

        - Additional memcpy node restrictions:

          - Changing either the source or destination memory type(i.e.
            CU_MEMORYTYPE_DEVICE, CU_MEMORYTYPE_ARRAY, etc.) is not supported.

        - External semaphore wait nodes and record nodes:

          - Changing the number of semaphores is not supported.

        - Conditional nodes:

          - Changing node parameters is not supported.

          - Changeing parameters of nodes within the conditional body graph is
            subject to the rules above.

          - Conditional handle flags and default values are updated as part of
            the graph update.

        Note: The API may add further restrictions in future releases. The
        return code should always be checked.

        cuGraphExecUpdate sets the result member of `resultInfo` to
        CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED under the following
        conditions:

        - The count of nodes directly in `hGraphExec` and `hGraph` differ, in
          which case resultInfo->errorNode is set to NULL.

        - `hGraph` has more exit nodes than `hGraph`, in which case
          resultInfo->errorNode is set to one of the exit nodes in hGraph.

        - A node in `hGraph` has a different number of dependencies than the
          node from `hGraphExec` it is paired with, in which case
          resultInfo->errorNode is set to the node from `hGraph`.

        - A node in `hGraph` has a dependency that does not match with the
          corresponding dependency of the paired node from `hGraphExec`.
          resultInfo->errorNode will be set to the node from `hGraph`.
          resultInfo->errorFromNode will be set to the mismatched dependency.
          The dependencies are paired based on edge order and a dependency does
          not match when the nodes are already paired based on other edges
          examined in the graph.

        cuGraphExecUpdate sets the result member of `resultInfo` to:

        - CU_GRAPH_EXEC_UPDATE_ERROR if passed an invalid value.

        - CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED if the graph topology
          changed

        - CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED if the type of a node
          changed, in which case `hErrorNode_out` is set to the node from
          `hGraph`.

        - CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE if the
          function changed in an unsupported way(see note above), in which case
          `hErrorNode_out` is set to the node from `hGraph`

        - CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED if any parameters to a
          node changed in a way that is not supported, in which case
          `hErrorNode_out` is set to the node from `hGraph`.

        - CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED if any attributes of a
          node changed in a way that is not supported, in which case
          `hErrorNode_out` is set to the node from `hGraph`.

        - CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED if something about a node is
          unsupported, like the node's type or configuration, in which case
          `hErrorNode_out` is set to the node from `hGraph`

        If the update fails for a reason not listed above, the result member of
        `resultInfo` will be set to CU_GRAPH_EXEC_UPDATE_ERROR. If the update
        succeeds, the result member will be set to
        CU_GRAPH_EXEC_UPDATE_SUCCESS.

        cuGraphExecUpdate returns CUDA_SUCCESS when the updated was performed
        successfully. It returns CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE if the
        graph update was not performed because it included changes which
        violated constraints specific to instantiated graph update.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The instantiated graph to be updated
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            The graph containing the updated parameters

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE`,
        resultInfo : :py:obj:`~.CUgraphExecUpdateResultInfo`
            the error info structure

        See Also
        --------
        :py:obj:`~.cuGraphInstantiate`
    """


def cuGraphExternalSemaphoresSignalNodeGetParams(hNode):
    """
    cuGraphExternalSemaphoresSignalNodeGetParams(hNode)
     Returns an external semaphore signal node's parameters.

        Returns the parameters of an external semaphore signal node `hNode` in
        `params_out`. The `extSemArray` and `paramsArray` returned in
        `params_out`, are owned by the node. This memory remains valid until
        the node is destroyed or its parameters are modified, and should not be
        modified directly. Use
        :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams` to update the
        parameters of this node.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the parameters for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        params_out : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
            Pointer to return the parameters

        See Also
        --------
        :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """


def cuGraphExternalSemaphoresSignalNodeSetParams(hNode, nodeParams: 'Optional[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS]'):
    """
    cuGraphExternalSemaphoresSignalNodeSetParams(hNode, CUDA_EXT_SEM_SIGNAL_NODE_PARAMS nodeParams: Optional[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS])
     Sets an external semaphore signal node's parameters.

        Sets the parameters of an external semaphore signal node `hNode` to
        `nodeParams`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to set the parameters for
        nodeParams : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
            Parameters to copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

        See Also
        --------
        :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """


def cuGraphExternalSemaphoresWaitNodeGetParams(hNode):
    """
    cuGraphExternalSemaphoresWaitNodeGetParams(hNode)
     Returns an external semaphore wait node's parameters.

        Returns the parameters of an external semaphore wait node `hNode` in
        `params_out`. The `extSemArray` and `paramsArray` returned in
        `params_out`, are owned by the node. This memory remains valid until
        the node is destroyed or its parameters are modified, and should not be
        modified directly. Use
        :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams` to update the
        parameters of this node.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the parameters for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        params_out : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
            Pointer to return the parameters

        See Also
        --------
        :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """


def cuGraphExternalSemaphoresWaitNodeSetParams(hNode, nodeParams: 'Optional[CUDA_EXT_SEM_WAIT_NODE_PARAMS]'):
    """
    cuGraphExternalSemaphoresWaitNodeSetParams(hNode, CUDA_EXT_SEM_WAIT_NODE_PARAMS nodeParams: Optional[CUDA_EXT_SEM_WAIT_NODE_PARAMS])
     Sets an external semaphore wait node's parameters.

        Sets the parameters of an external semaphore wait node `hNode` to
        `nodeParams`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to set the parameters for
        nodeParams : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
            Parameters to copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

        See Also
        --------
        :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """


def cuGraphGetEdges(hGraph, numEdges=0):
    """
    cuGraphGetEdges(hGraph, size_t numEdges=0)
     Returns a graph's dependency edges.

        Returns a list of `hGraph's` dependency edges. Edges are returned via
        corresponding indices in `from` and `to`; that is, the node in `to`[i]
        has a dependency on the node in `from`[i]. `from` and `to` may both be
        NULL, in which case this function only returns the number of edges in
        `numEdges`. Otherwise, `numEdges` entries will be filled in. If
        `numEdges` is higher than the actual number of edges, the remaining
        entries in `from` and `to` will be set to NULL, and the number of edges
        actually returned will be written to `numEdges`.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to get the edges from
        numEdges : int
            See description

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        from : List[:py:obj:`~.CUgraphNode`]
            Location to return edge endpoints
        to : List[:py:obj:`~.CUgraphNode`]
            Location to return edge endpoints
        numEdges : int
            See description

        See Also
        --------
        :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """


def cuGraphGetEdges_v2(hGraph, numEdges=0):
    """
    cuGraphGetEdges_v2(hGraph, size_t numEdges=0)
     Returns a graph's dependency edges (12.3+)

        Returns a list of `hGraph's` dependency edges. Edges are returned via
        corresponding indices in `from`, `to` and `edgeData`; that is, the node
        in `to`[i] has a dependency on the node in `from`[i] with data
        `edgeData`[i]. `from` and `to` may both be NULL, in which case this
        function only returns the number of edges in `numEdges`. Otherwise,
        `numEdges` entries will be filled in. If `numEdges` is higher than the
        actual number of edges, the remaining entries in `from` and `to` will
        be set to NULL, and the number of edges actually returned will be
        written to `numEdges`. `edgeData` may alone be NULL, in which case the
        edges must all have default (zeroed) edge data. Attempting a lossy
        query via NULL `edgeData` will result in
        :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`. If `edgeData` is non-NULL then
        `from` and `to` must be as well.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to get the edges from
        numEdges : int
            See description

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        from : List[:py:obj:`~.CUgraphNode`]
            Location to return edge endpoints
        to : List[:py:obj:`~.CUgraphNode`]
            Location to return edge endpoints
        edgeData : List[:py:obj:`~.CUgraphEdgeData`]
            Optional location to return edge data
        numEdges : int
            See description

        See Also
        --------
        :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """


def cuGraphGetNodes(hGraph, numNodes=0):
    """
    cuGraphGetNodes(hGraph, size_t numNodes=0)
     Returns a graph's nodes.

        Returns a list of `hGraph's` nodes. `nodes` may be NULL, in which case
        this function will return the number of nodes in `numNodes`. Otherwise,
        `numNodes` entries will be filled in. If `numNodes` is higher than the
        actual number of nodes, the remaining entries in `nodes` will be set to
        NULL, and the number of nodes actually obtained will be returned in
        `numNodes`.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to query
        numNodes : int
            See description

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        nodes : List[:py:obj:`~.CUgraphNode`]
            Pointer to return the nodes
        numNodes : int
            See description

        See Also
        --------
        :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetType`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """


def cuGraphGetRootNodes(hGraph, numRootNodes=0):
    """
    cuGraphGetRootNodes(hGraph, size_t numRootNodes=0)
     Returns a graph's root nodes.

        Returns a list of `hGraph's` root nodes. `rootNodes` may be NULL, in
        which case this function will return the number of root nodes in
        `numRootNodes`. Otherwise, `numRootNodes` entries will be filled in. If
        `numRootNodes` is higher than the actual number of root nodes, the
        remaining entries in `rootNodes` will be set to NULL, and the number of
        nodes actually obtained will be returned in `numRootNodes`.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to query
        numRootNodes : int
            See description

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        rootNodes : List[:py:obj:`~.CUgraphNode`]
            Pointer to return the root nodes
        numRootNodes : int
            See description

        See Also
        --------
        :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetType`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """


def cuGraphHostNodeGetParams(hNode):
    """
    cuGraphHostNodeGetParams(hNode)
     Returns a host node's parameters.

        Returns the parameters of host node `hNode` in `nodeParams`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the parameters for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
            Pointer to return the parameters

        See Also
        --------
        :py:obj:`~.cuLaunchHostFunc`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphHostNodeSetParams`
    """


def cuGraphHostNodeSetParams(hNode, nodeParams: 'Optional[CUDA_HOST_NODE_PARAMS]'):
    """
    cuGraphHostNodeSetParams(hNode, CUDA_HOST_NODE_PARAMS nodeParams: Optional[CUDA_HOST_NODE_PARAMS])
     Sets a host node's parameters.

        Sets the parameters of host node `hNode` to `nodeParams`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to set the parameters for
        nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
            Parameters to copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuLaunchHostFunc`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphHostNodeGetParams`
    """


def cuGraphInstantiate(hGraph, flags):
    """
    cuGraphInstantiate(hGraph, unsigned long long flags)
     Creates an executable graph from a graph.

        Instantiates `hGraph` as an executable graph. The graph is validated
        for any structural constraints or intra-node constraints which were not
        previously validated. If instantiation is successful, a handle to the
        instantiated graph is returned in `phGraphExec`.

        The `flags` parameter controls the behavior of instantiation and
        subsequent graph launches. Valid flags are:

        - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`, which
          configures a graph containing memory allocation nodes to
          automatically free any unfreed memory allocations before the graph is
          relaunched.

        - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH`, which
          configures the graph for launch from the device. If this flag is
          passed, the executable graph handle returned can be used to launch
          the graph from both the host and device. This flag can only be used
          on platforms which support unified addressing. This flag cannot be
          used in conjunction with
          :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`.

        - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY`, which
          causes the graph to use the priorities from the per-node attributes
          rather than the priority of the launch stream during execution. Note
          that priorities are only available on kernel nodes, and are copied
          from stream priority during stream capture.

        If `hGraph` contains any allocation or free nodes, there can be at most
        one executable graph in existence for that graph at a time. An attempt
        to instantiate a second executable graph before destroying the first
        with :py:obj:`~.cuGraphExecDestroy` will result in an error. The same
        also applies if `hGraph` contains any device-updatable kernel nodes.

        If `hGraph` contains kernels which call device-side cudaGraphLaunch()
        from multiple contexts, this will result in an error.

        Graphs instantiated for launch on the device have additional
        restrictions which do not apply to host graphs:

        - The graph's nodes must reside on a single context.

        - The graph can only contain kernel nodes, memcpy nodes, memset nodes,
          and child graph nodes.

        - The graph cannot be empty and must contain at least one kernel,
          memcpy, or memset node. Operation-specific restrictions are outlined
          below.

        - Kernel nodes:

          - Use of CUDA Dynamic Parallelism is not permitted.

          - Cooperative launches are permitted as long as MPS is not in use.

        - Memcpy nodes:

          - Only copies involving device memory and/or pinned device-mapped
            host memory are permitted.

          - Copies involving CUDA arrays are not permitted.

          - Both operands must be accessible from the current context, and the
            current context must match the context of other nodes in the graph.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to instantiate
        flags : unsigned long long
            Flags to control instantiation. See
            :py:obj:`~.CUgraphInstantiate_flags`.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phGraphExec : :py:obj:`~.CUgraphExec`
            Returns instantiated graph

        See Also
        --------
        :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphUpload`, :py:obj:`~.cuGraphLaunch`, :py:obj:`~.cuGraphExecDestroy`
    """


def cuGraphInstantiateWithParams(hGraph, instantiateParams: 'Optional[CUDA_GRAPH_INSTANTIATE_PARAMS]'):
    """
    cuGraphInstantiateWithParams(hGraph, CUDA_GRAPH_INSTANTIATE_PARAMS instantiateParams: Optional[CUDA_GRAPH_INSTANTIATE_PARAMS])
     Creates an executable graph from a graph.

        Instantiates `hGraph` as an executable graph according to the
        `instantiateParams` structure. The graph is validated for any
        structural constraints or intra-node constraints which were not
        previously validated. If instantiation is successful, a handle to the
        instantiated graph is returned in `phGraphExec`.

        `instantiateParams` controls the behavior of instantiation and
        subsequent graph launches, as well as returning more detailed
        information in the event of an error.
        :py:obj:`~.CUDA_GRAPH_INSTANTIATE_PARAMS` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        The `flags` field controls the behavior of instantiation and subsequent
        graph launches. Valid flags are:

        - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`, which
          configures a graph containing memory allocation nodes to
          automatically free any unfreed memory allocations before the graph is
          relaunched.

        - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD`, which will perform an
          upload of the graph into `hUploadStream` once the graph has been
          instantiated.

        - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH`, which
          configures the graph for launch from the device. If this flag is
          passed, the executable graph handle returned can be used to launch
          the graph from both the host and device. This flag can only be used
          on platforms which support unified addressing. This flag cannot be
          used in conjunction with
          :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`.

        - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY`, which
          causes the graph to use the priorities from the per-node attributes
          rather than the priority of the launch stream during execution. Note
          that priorities are only available on kernel nodes, and are copied
          from stream priority during stream capture.

        If `hGraph` contains any allocation or free nodes, there can be at most
        one executable graph in existence for that graph at a time. An attempt
        to instantiate a second executable graph before destroying the first
        with :py:obj:`~.cuGraphExecDestroy` will result in an error. The same
        also applies if `hGraph` contains any device-updatable kernel nodes.

        If `hGraph` contains kernels which call device-side cudaGraphLaunch()
        from multiple contexts, this will result in an error.

        Graphs instantiated for launch on the device have additional
        restrictions which do not apply to host graphs:

        - The graph's nodes must reside on a single context.

        - The graph can only contain kernel nodes, memcpy nodes, memset nodes,
          and child graph nodes.

        - The graph cannot be empty and must contain at least one kernel,
          memcpy, or memset node. Operation-specific restrictions are outlined
          below.

        - Kernel nodes:

          - Use of CUDA Dynamic Parallelism is not permitted.

          - Cooperative launches are permitted as long as MPS is not in use.

        - Memcpy nodes:

          - Only copies involving device memory and/or pinned device-mapped
            host memory are permitted.

          - Copies involving CUDA arrays are not permitted.

          - Both operands must be accessible from the current context, and the
            current context must match the context of other nodes in the graph.

        In the event of an error, the `result_out` and `hErrNode_out` fields
        will contain more information about the nature of the error. Possible
        error reporting includes:

        - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_ERROR`, if passed an invalid value
          or if an unexpected error occurred which is described by the return
          value of the function. `hErrNode_out` will be set to NULL.

        - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE`, if the graph
          structure is invalid. `hErrNode_out` will be set to one of the
          offending nodes.

        - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED`, if
          the graph is instantiated for device launch but contains a node of an
          unsupported node type, or a node which performs unsupported
          operations, such as use of CUDA dynamic parallelism within a kernel
          node. `hErrNode_out` will be set to this node.

        - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED`, if
          the graph is instantiated for device launch but a nodes context
          differs from that of another node. This error can also be returned if
          a graph is not instantiated for device launch and it contains kernels
          which call device-side cudaGraphLaunch() from multiple contexts.
          `hErrNode_out` will be set to this node.

        If instantiation is successful, `result_out` will be set to
        :py:obj:`~.CUDA_GRAPH_INSTANTIATE_SUCCESS`, and `hErrNode_out` will be
        set to NULL.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to instantiate
        instantiateParams : :py:obj:`~.CUDA_GRAPH_INSTANTIATE_PARAMS`
            Instantiation parameters

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        phGraphExec : :py:obj:`~.CUgraphExec`
            Returns instantiated graph

        See Also
        --------
        :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphExecDestroy`
    """


def cuGraphKernelNodeCopyAttributes(dst, src):
    """
    cuGraphKernelNodeCopyAttributes(dst, src)
     Copies attributes from source node to destination node.

        Copies attributes from source node `src` to destination node `dst`.
        Both node must have the same context.

        Parameters
        ----------
        dst : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Destination node
        src : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Source node For list of attributes see
            :py:obj:`~.CUkernelNodeAttrID`

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.CUaccessPolicyWindow`
    """


def cuGraphKernelNodeGetAttribute(hNode, attr: 'CUkernelNodeAttrID'):
    """
    cuGraphKernelNodeGetAttribute(hNode, attr: CUkernelNodeAttrID)
     Queries node attribute.

        Queries attribute `attr` from node `hNode` and stores it in
        corresponding member of `value_out`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`

        attr : :py:obj:`~.CUkernelNodeAttrID`


        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
        value_out : :py:obj:`~.CUkernelNodeAttrValue`


        See Also
        --------
        :py:obj:`~.CUaccessPolicyWindow`
    """


def cuGraphKernelNodeGetParams(hNode):
    """
    cuGraphKernelNodeGetParams(hNode)
     Returns a kernel node's parameters.

        Returns the parameters of kernel node `hNode` in `nodeParams`. The
        `kernelParams` or `extra` array returned in `nodeParams`, as well as
        the argument values it points to, are owned by the node. This memory
        remains valid until the node is destroyed or its parameters are
        modified, and should not be modified directly. Use
        :py:obj:`~.cuGraphKernelNodeSetParams` to update the parameters of this
        node.

        The params will contain either `kernelParams` or `extra`, according to
        which of these was most recently set on the node.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the parameters for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
            Pointer to return the parameters

        See Also
        --------
        :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphKernelNodeSetParams`
    """


def cuGraphKernelNodeSetAttribute(hNode, attr: 'CUkernelNodeAttrID', value: 'Optional[CUkernelNodeAttrValue]'):
    """
    cuGraphKernelNodeSetAttribute(hNode, attr: CUkernelNodeAttrID, CUkernelNodeAttrValue value: Optional[CUkernelNodeAttrValue])
     Sets node attribute.

        Sets attribute `attr` on node `hNode` from corresponding attribute of
        `value`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`

        attr : :py:obj:`~.CUkernelNodeAttrID`

        value : :py:obj:`~.CUkernelNodeAttrValue`


        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.CUaccessPolicyWindow`
    """


def cuGraphKernelNodeSetParams(hNode, nodeParams: 'Optional[CUDA_KERNEL_NODE_PARAMS]'):
    """
    cuGraphKernelNodeSetParams(hNode, CUDA_KERNEL_NODE_PARAMS nodeParams: Optional[CUDA_KERNEL_NODE_PARAMS])
     Sets a kernel node's parameters.

        Sets the parameters of kernel node `hNode` to `nodeParams`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to set the parameters for
        nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
            Parameters to copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

        See Also
        --------
        :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphKernelNodeGetParams`
    """


def cuGraphLaunch(hGraphExec, hStream):
    """
    cuGraphLaunch(hGraphExec, hStream)
     Launches an executable graph in a stream.

        Executes `hGraphExec` in `hStream`. Only one instance of `hGraphExec`
        may be executing at a time. Each launch is ordered behind both any
        previous work in `hStream` and any previous launches of `hGraphExec`.
        To execute a graph concurrently, it must be instantiated multiple times
        into multiple executable graphs.

        If any allocations created by `hGraphExec` remain unfreed (from a
        previous launch) and `hGraphExec` was not instantiated with
        :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`, the launch
        will fail with :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            Executable graph to launch
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream in which to launch the graph

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphUpload`, :py:obj:`~.cuGraphExecDestroy`
    """


def cuGraphMemAllocNodeGetParams(hNode):
    """
    cuGraphMemAllocNodeGetParams(hNode)
     Returns a memory alloc node's parameters.

        Returns the parameters of a memory alloc node `hNode` in `params_out`.
        The `poolProps` and `accessDescs` returned in `params_out`, are owned
        by the node. This memory remains valid until the node is destroyed. The
        returned parameters must not be modified.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the parameters for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        params_out : :py:obj:`~.CUDA_MEM_ALLOC_NODE_PARAMS`
            Pointer to return the parameters

        See Also
        --------
        :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphMemFreeNodeGetParams`
    """


def cuGraphMemFreeNodeGetParams(hNode):
    """
    cuGraphMemFreeNodeGetParams(hNode)
     Returns a memory free node's parameters.

        Returns the address of a memory free node `hNode` in `dptr_out`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the parameters for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        dptr_out : :py:obj:`~.CUdeviceptr`
            Pointer to return the device address

        See Also
        --------
        :py:obj:`~.cuGraphAddMemFreeNode`, :py:obj:`~.cuGraphMemAllocNodeGetParams`
    """


def cuGraphMemcpyNodeGetParams(hNode):
    """
    cuGraphMemcpyNodeGetParams(hNode)
     Returns a memcpy node's parameters.

        Returns the parameters of memcpy node `hNode` in `nodeParams`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the parameters for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        nodeParams : :py:obj:`~.CUDA_MEMCPY3D`
            Pointer to return the parameters

        See Also
        --------
        :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphMemcpyNodeSetParams`
    """


def cuGraphMemcpyNodeSetParams(hNode, nodeParams: 'Optional[CUDA_MEMCPY3D]'):
    """
    cuGraphMemcpyNodeSetParams(hNode, CUDA_MEMCPY3D nodeParams: Optional[CUDA_MEMCPY3D])
     Sets a memcpy node's parameters.

        Sets the parameters of memcpy node `hNode` to `nodeParams`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to set the parameters for
        nodeParams : :py:obj:`~.CUDA_MEMCPY3D`
            Parameters to copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphMemcpyNodeGetParams`
    """


def cuGraphMemsetNodeGetParams(hNode):
    """
    cuGraphMemsetNodeGetParams(hNode)
     Returns a memset node's parameters.

        Returns the parameters of memset node `hNode` in `nodeParams`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to get the parameters for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        nodeParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
            Pointer to return the parameters

        See Also
        --------
        :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphMemsetNodeSetParams`
    """


def cuGraphMemsetNodeSetParams(hNode, nodeParams: 'Optional[CUDA_MEMSET_NODE_PARAMS]'):
    """
    cuGraphMemsetNodeSetParams(hNode, CUDA_MEMSET_NODE_PARAMS nodeParams: Optional[CUDA_MEMSET_NODE_PARAMS])
     Sets a memset node's parameters.

        Sets the parameters of memset node `hNode` to `nodeParams`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to set the parameters for
        nodeParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
            Parameters to copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphMemsetNodeGetParams`
    """


def cuGraphNodeFindInClone(hOriginalNode, hClonedGraph):
    """
    cuGraphNodeFindInClone(hOriginalNode, hClonedGraph)
     Finds a cloned version of a node.

        This function returns the node in `hClonedGraph` corresponding to
        `hOriginalNode` in the original graph.

        `hClonedGraph` must have been cloned from `hOriginalGraph` via
        :py:obj:`~.cuGraphClone`. `hOriginalNode` must have been in
        `hOriginalGraph` at the time of the call to :py:obj:`~.cuGraphClone`,
        and the corresponding cloned node in `hClonedGraph` must not have been
        removed. The cloned node is then returned via `phClonedNode`.

        Parameters
        ----------
        hOriginalNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Handle to the original node
        hClonedGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Cloned graph to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        phNode : :py:obj:`~.CUgraphNode`
            Returns handle to the cloned node

        See Also
        --------
        :py:obj:`~.cuGraphClone`
    """


def cuGraphNodeGetDependencies(hNode, numDependencies=0):
    """
    cuGraphNodeGetDependencies(hNode, size_t numDependencies=0)
     Returns a node's dependencies.

        Returns a list of `node's` dependencies. `dependencies` may be NULL, in
        which case this function will return the number of dependencies in
        `numDependencies`. Otherwise, `numDependencies` entries will be filled
        in. If `numDependencies` is higher than the actual number of
        dependencies, the remaining entries in `dependencies` will be set to
        NULL, and the number of nodes actually obtained will be returned in
        `numDependencies`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to query
        numDependencies : int
            See description

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Pointer to return the dependencies
        numDependencies : int
            See description

        See Also
        --------
        :py:obj:`~.cuGraphNodeGetDependentNodes`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`
    """


def cuGraphNodeGetDependencies_v2(hNode, numDependencies=0):
    """
    cuGraphNodeGetDependencies_v2(hNode, size_t numDependencies=0)
     Returns a node's dependencies (12.3+)

        Returns a list of `node's` dependencies. `dependencies` may be NULL, in
        which case this function will return the number of dependencies in
        `numDependencies`. Otherwise, `numDependencies` entries will be filled
        in. If `numDependencies` is higher than the actual number of
        dependencies, the remaining entries in `dependencies` will be set to
        NULL, and the number of nodes actually obtained will be returned in
        `numDependencies`.

        Note that if an edge has non-zero (non-default) edge data and
        `edgeData` is NULL, this API will return
        :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`. If `edgeData` is non-NULL, then
        `dependencies` must be as well.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to query
        numDependencies : int
            See description

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Pointer to return the dependencies
        edgeData : List[:py:obj:`~.CUgraphEdgeData`]
            Optional array to return edge data for each dependency
        numDependencies : int
            See description

        See Also
        --------
        :py:obj:`~.cuGraphNodeGetDependentNodes`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`
    """


def cuGraphNodeGetDependentNodes(hNode, numDependentNodes=0):
    """
    cuGraphNodeGetDependentNodes(hNode, size_t numDependentNodes=0)
     Returns a node's dependent nodes.

        Returns a list of `node's` dependent nodes. `dependentNodes` may be
        NULL, in which case this function will return the number of dependent
        nodes in `numDependentNodes`. Otherwise, `numDependentNodes` entries
        will be filled in. If `numDependentNodes` is higher than the actual
        number of dependent nodes, the remaining entries in `dependentNodes`
        will be set to NULL, and the number of nodes actually obtained will be
        returned in `numDependentNodes`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to query
        numDependentNodes : int
            See description

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        dependentNodes : List[:py:obj:`~.CUgraphNode`]
            Pointer to return the dependent nodes
        numDependentNodes : int
            See description

        See Also
        --------
        :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`
    """


def cuGraphNodeGetDependentNodes_v2(hNode, numDependentNodes=0):
    """
    cuGraphNodeGetDependentNodes_v2(hNode, size_t numDependentNodes=0)
     Returns a node's dependent nodes (12.3+)

        Returns a list of `node's` dependent nodes. `dependentNodes` may be
        NULL, in which case this function will return the number of dependent
        nodes in `numDependentNodes`. Otherwise, `numDependentNodes` entries
        will be filled in. If `numDependentNodes` is higher than the actual
        number of dependent nodes, the remaining entries in `dependentNodes`
        will be set to NULL, and the number of nodes actually obtained will be
        returned in `numDependentNodes`.

        Note that if an edge has non-zero (non-default) edge data and
        `edgeData` is NULL, this API will return
        :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`. If `edgeData` is non-NULL, then
        `dependentNodes` must be as well.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to query
        numDependentNodes : int
            See description

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        dependentNodes : List[:py:obj:`~.CUgraphNode`]
            Pointer to return the dependent nodes
        edgeData : List[:py:obj:`~.CUgraphEdgeData`]
            Optional pointer to return edge data for dependent nodes
        numDependentNodes : int
            See description

        See Also
        --------
        :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`
    """


def cuGraphNodeGetEnabled(hGraphExec, hNode):
    """
    cuGraphNodeGetEnabled(hGraphExec, hNode)
     Query whether a node in the given graphExec is enabled.

        Sets isEnabled to 1 if `hNode` is enabled, or 0 if `hNode` is disabled.

        The node is identified by the corresponding node `hNode` in the non-
        executable graph, from which the executable graph was instantiated.

        `hNode` must not have been removed from the original graph.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node from the graph from which graphExec was instantiated

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        isEnabled : unsigned int
            Location to return the enabled status of the node

        See Also
        --------
        :py:obj:`~.cuGraphNodeSetEnabled`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate` :py:obj:`~.cuGraphLaunch`

        Notes
        -----
        Currently only kernel, memset and memcpy nodes are supported.

        This function will not reflect device-side updates for device-updatable kernel nodes.
    """


def cuGraphNodeGetType(hNode):
    """
    cuGraphNodeGetType(hNode)
     Returns a node's type.

        Returns the node type of `hNode` in `typename`.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        typename : :py:obj:`~.CUgraphNodeType`
            Pointer to return the node type

        See Also
        --------
        :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphChildGraphNodeGetGraph`, :py:obj:`~.cuGraphKernelNodeGetParams`, :py:obj:`~.cuGraphKernelNodeSetParams`, :py:obj:`~.cuGraphHostNodeGetParams`, :py:obj:`~.cuGraphHostNodeSetParams`, :py:obj:`~.cuGraphMemcpyNodeGetParams`, :py:obj:`~.cuGraphMemcpyNodeSetParams`, :py:obj:`~.cuGraphMemsetNodeGetParams`, :py:obj:`~.cuGraphMemsetNodeSetParams`
    """


def cuGraphNodeSetEnabled(hGraphExec, hNode, isEnabled):
    """
    cuGraphNodeSetEnabled(hGraphExec, hNode, unsigned int isEnabled)
     Enables or disables the specified node in the given graphExec.

        Sets `hNode` to be either enabled or disabled. Disabled nodes are
        functionally equivalent to empty nodes until they are reenabled.
        Existing node parameters are not affected by disabling/enabling the
        node.

        The node is identified by the corresponding node `hNode` in the non-
        executable graph, from which the executable graph was instantiated.

        `hNode` must not have been removed from the original graph.

        The modifications only affect future launches of `hGraphExec`. Already
        enqueued or running launches of `hGraphExec` are not affected by this
        call. `hNode` is also not modified by this call.

        If `hNode` is a device-updatable kernel node, the next upload/launch of
        `hGraphExec` will overwrite any previous device-side updates.
        Additionally, applying host updates to a device-updatable kernel node
        while it is being updated from the device will result in undefined
        behavior.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            The executable graph in which to set the specified node
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node from the graph from which graphExec was instantiated
        isEnabled : unsigned int
            Node is enabled if != 0, otherwise the node is disabled

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

        See Also
        --------
        :py:obj:`~.cuGraphNodeGetEnabled`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate` :py:obj:`~.cuGraphLaunch`

        Notes
        -----
        Currently only kernel, memset and memcpy nodes are supported.
    """


def cuGraphNodeSetParams(hNode, nodeParams: 'Optional[CUgraphNodeParams]'):
    """
    cuGraphNodeSetParams(hNode, CUgraphNodeParams nodeParams: Optional[CUgraphNodeParams])
     Update's a graph node's parameters.

        Sets the parameters of graph node `hNode` to `nodeParams`. The node
        type specified by `nodeParams->type` must match the type of `hNode`.
        `nodeParams` must be fully initialized and all unused bytes (reserved,
        padding) zeroed.

        Modifying parameters is not supported for node types
        CU_GRAPH_NODE_TYPE_MEM_ALLOC and CU_GRAPH_NODE_TYPE_MEM_FREE.

        Parameters
        ----------
        hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
            Node to set the parameters for
        nodeParams : :py:obj:`~.CUgraphNodeParams`
            Parameters to copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphExecNodeSetParams`
    """


def cuGraphReleaseUserObject(graph, object, count):
    """
    cuGraphReleaseUserObject(graph, object, unsigned int count)
     Release a user object reference from a graph.

        Releases user object references owned by a graph.

        See CUDA User Objects in the CUDA C++ Programming Guide for more
        information on user objects.

        Parameters
        ----------
        graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            The graph that will release the reference
        object : :py:obj:`~.CUuserObject`
            The user object to release a reference for
        count : unsigned int
            The number of references to release, typically 1. Must be nonzero
            and not larger than INT_MAX.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphCreate`
    """


def cuGraphRemoveDependencies(hGraph, from_: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', to: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies):
    """
    cuGraphRemoveDependencies(hGraph, from_: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], to: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies)
     Removes dependency edges from a graph.

        The number of `dependencies` to be removed is defined by
        `numDependencies`. Elements in `from` and `to` at corresponding indices
        define a dependency. Each node in `from` and `to` must belong to
        `hGraph`.

        If `numDependencies` is 0, elements in `from` and `to` will be ignored.
        Specifying a non-existing dependency will return an error.

        Dependencies cannot be removed from graphs which contain allocation or
        free nodes. Any attempt to do so will return an error.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph from which to remove dependencies
        from : List[:py:obj:`~.CUgraphNode`]
            Array of nodes that provide the dependencies
        to : List[:py:obj:`~.CUgraphNode`]
            Array of dependent nodes
        numDependencies : size_t
            Number of dependencies to be removed

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """


def cuGraphRemoveDependencies_v2(hGraph, from_: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', to: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', edgeData: 'Optional[Tuple[CUgraphEdgeData] | List[CUgraphEdgeData]]', numDependencies):
    """
    cuGraphRemoveDependencies_v2(hGraph, from_: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], to: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], edgeData: Optional[Tuple[CUgraphEdgeData] | List[CUgraphEdgeData]], size_t numDependencies)
     Removes dependency edges from a graph (12.3+)

        The number of `dependencies` to be removed is defined by
        `numDependencies`. Elements in `from` and `to` at corresponding indices
        define a dependency. Each node in `from` and `to` must belong to
        `hGraph`.

        If `numDependencies` is 0, elements in `from` and `to` will be ignored.
        Specifying an edge that does not exist in the graph, with data matching
        `edgeData`, results in an error. `edgeData` is nullable, which is
        equivalent to passing default (zeroed) data for each edge.

        Dependencies cannot be removed from graphs which contain allocation or
        free nodes. Any attempt to do so will return an error.

        Parameters
        ----------
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph from which to remove dependencies
        from : List[:py:obj:`~.CUgraphNode`]
            Array of nodes that provide the dependencies
        to : List[:py:obj:`~.CUgraphNode`]
            Array of dependent nodes
        edgeData : List[:py:obj:`~.CUgraphEdgeData`]
            Optional array of edge data. If NULL, edge data is assumed to be
            default (zeroed).
        numDependencies : size_t
            Number of dependencies to be removed

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """


def cuGraphRetainUserObject(graph, object, count, flags):
    """
    cuGraphRetainUserObject(graph, object, unsigned int count, unsigned int flags)
     Retain a reference to a user object from a graph.

        Creates or moves user object references that will be owned by a CUDA
        graph.

        See CUDA User Objects in the CUDA C++ Programming Guide for more
        information on user objects.

        Parameters
        ----------
        graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            The graph to associate the reference with
        object : :py:obj:`~.CUuserObject`
            The user object to retain a reference for
        count : unsigned int
            The number of references to add to the graph, typically 1. Must be
            nonzero and not larger than INT_MAX.
        flags : unsigned int
            The optional flag :py:obj:`~.CU_GRAPH_USER_OBJECT_MOVE` transfers
            references from the calling thread, rather than create new
            references. Pass 0 to create new references.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """


def cuGraphUpload(hGraphExec, hStream):
    """
    cuGraphUpload(hGraphExec, hStream)
     Uploads an executable graph in a stream.

        Uploads `hGraphExec` to the device in `hStream` without executing it.
        Uploads of the same `hGraphExec` will be serialized. Each upload is
        ordered behind both any previous work in `hStream` and any previous
        launches of `hGraphExec`. Uses memory cached by `stream` to back the
        allocations owned by `hGraphExec`.

        Parameters
        ----------
        hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
            Executable graph to upload
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream in which to upload the graph

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphLaunch`, :py:obj:`~.cuGraphExecDestroy`
    """


def cuGraphicsEGLRegisterImage(image, flags):
    """
    cuGraphicsEGLRegisterImage(image, unsigned int flags)
     Registers an EGL image.

        Registers the EGLImageKHR specified by `image` for access by CUDA. A
        handle to the registered object is returned as `pCudaResource`.
        Additional Mapping/Unmapping is not required for the registered
        resource and :py:obj:`~.cuGraphicsResourceGetMappedEglFrame` can be
        directly called on the `pCudaResource`.

        The application will be responsible for synchronizing access to shared
        objects. The application must ensure that any pending operation which
        access the objects have completed before passing control to CUDA. This
        may be accomplished by issuing and waiting for glFinish command on all
        GLcontexts (for OpenGL and likewise for other APIs). The application
        will be also responsible for ensuring that any pending operation on the
        registered CUDA resource has completed prior to executing subsequent
        commands in other APIs accesing the same memory objects. This can be
        accomplished by calling cuCtxSynchronize or cuEventSynchronize
        (preferably).

        The surface's intended usage is specified using `flags`, as follows:

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
          about how this resource will be used. It is therefore assumed that
          this resource will be read from and written to by CUDA. This is the
          default value.

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY`: Specifies that
          CUDA will not write to this resource.

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD`: Specifies
          that CUDA will not read from this resource and will write over the
          entire contents of the resource, so none of the data previously
          stored in the resource will be preserved.

        The EGLImageKHR is an object which can be used to create EGLImage
        target resource. It is defined as a void pointer. typedef void*
        EGLImageKHR

        Parameters
        ----------
        image : :py:obj:`~.EGLImageKHR`
            An EGLImageKHR image which can be used to create target resource.
        flags : unsigned int
            Map flags

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
        pCudaResource : :py:obj:`~.CUgraphicsResource`
            Pointer to the returned object handle

        See Also
        --------
        :py:obj:`~.cuGraphicsEGLRegisterImage`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cudaGraphicsEGLRegisterImage`
    """


def cuGraphicsGLRegisterBuffer(buffer, Flags):
    """
    cuGraphicsGLRegisterBuffer(buffer, unsigned int Flags)
     Registers an OpenGL buffer object.

        Registers the buffer object specified by `buffer` for access by CUDA. A
        handle to the registered object is returned as `pCudaResource`. The
        register flags `Flags` specify the intended usage, as follows:

        - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_NONE`: Specifies no hints about
          how this resource will be used. It is therefore assumed that this
          resource will be read from and written to by CUDA. This is the
          default value.

        - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY`: Specifies that CUDA
          will not write to this resource.

        - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD`: Specifies that
          CUDA will not read from this resource and will write over the entire
          contents of the resource, so none of the data previously stored in
          the resource will be preserved.

        Parameters
        ----------
        buffer : :py:obj:`~.GLuint`
            name of buffer object to be registered
        Flags : unsigned int
            Register flags

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_OPERATING_SYSTEM`
        pCudaResource : :py:obj:`~.CUgraphicsResource`
            Pointer to the returned object handle

        See Also
        --------
        :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cudaGraphicsGLRegisterBuffer`
    """


def cuGraphicsGLRegisterImage(image, target, Flags):
    """
    cuGraphicsGLRegisterImage(image, target, unsigned int Flags)
     Register an OpenGL texture or renderbuffer object.

        Registers the texture or renderbuffer object specified by `image` for
        access by CUDA.   A handle to the registered object is returned as
        `pCudaResource`.

        `target` must match the type of the object, and must be one of
        :py:obj:`~.GL_TEXTURE_2D`, :py:obj:`~.GL_TEXTURE_RECTANGLE`,
        :py:obj:`~.GL_TEXTURE_CUBE_MAP`, :py:obj:`~.GL_TEXTURE_3D`,
        :py:obj:`~.GL_TEXTURE_2D_ARRAY`, or :py:obj:`~.GL_RENDERBUFFER`.

        The register flags `Flags` specify the intended usage, as follows:

        - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_NONE`: Specifies no hints about
          how this resource will be used. It is therefore assumed that this
          resource will be read from and written to by CUDA. This is the
          default value.

        - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY`: Specifies that CUDA
          will not write to this resource.

        - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD`: Specifies that
          CUDA will not read from this resource and will write over the entire
          contents of the resource, so none of the data previously stored in
          the resource will be preserved.

        - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST`: Specifies that
          CUDA will bind this resource to a surface reference.

        - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER`: Specifies that
          CUDA will perform texture gather operations on this resource.

        The following image formats are supported. For brevity's sake, the list
        is abbreviated. For ex., {GL_R, GL_RG} X {8, 16} would expand to the
        following 4 formats {GL_R8, GL_R16, GL_RG8, GL_RG16} :

        - GL_RED, GL_RG, GL_RGBA, GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA,
          GL_INTENSITY

        - {GL_R, GL_RG, GL_RGBA} X {8, 16, 16F, 32F, 8UI, 16UI, 32UI, 8I, 16I,
          32I}

        - {GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA, GL_INTENSITY} X {8, 16,
          16F_ARB, 32F_ARB, 8UI_EXT, 16UI_EXT, 32UI_EXT, 8I_EXT, 16I_EXT,
          32I_EXT}

        The following image classes are currently disallowed:

        - Textures with borders

        - Multisampled renderbuffers

        Parameters
        ----------
        image : :py:obj:`~.GLuint`
            name of texture or renderbuffer object to be registered
        target : :py:obj:`~.GLenum`
            Identifies the type of object specified by `image`
        Flags : unsigned int
            Register flags

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_OPERATING_SYSTEM`
        pCudaResource : :py:obj:`~.CUgraphicsResource`
            Pointer to the returned object handle

        See Also
        --------
        :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cudaGraphicsGLRegisterImage`
    """


def cuGraphicsMapResources(count, resources, hStream):
    """
    cuGraphicsMapResources(unsigned int count, resources, hStream)
     Map graphics resources for access by CUDA.

        Maps the `count` graphics resources in `resources` for access by CUDA.

        The resources in `resources` may be accessed by CUDA until they are
        unmapped. The graphics API from which `resources` were registered
        should not access any resources while they are mapped by CUDA. If an
        application does so, the results are undefined.

        This function provides the synchronization guarantee that any graphics
        calls issued before :py:obj:`~.cuGraphicsMapResources()` will complete
        before any subsequent CUDA work issued in `stream` begins.

        If `resources` includes any duplicate entries then
        :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. If any of
        `resources` are presently mapped for access by CUDA then
        :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED` is returned.

        Parameters
        ----------
        count : unsigned int
            Number of resources to map
        resources : :py:obj:`~.CUgraphicsResource`
            Resources to map for CUDA usage
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream with which to synchronize

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_UNKNOWN`

        See Also
        --------
        :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cudaGraphicsMapResources`
    """


def cuGraphicsResourceGetMappedEglFrame(resource, index, mipLevel):
    """
    cuGraphicsResourceGetMappedEglFrame(resource, unsigned int index, unsigned int mipLevel)
     Get an eglFrame through which to access a registered EGL graphics resource.

        Returns in `*eglFrame` an eglFrame pointer through which the registered
        graphics resource `resource` may be accessed. This API can only be
        called for registered EGL graphics resources.

        The :py:obj:`~.CUeglFrame` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        If `resource` is not registered then :py:obj:`~.CUDA_ERROR_NOT_MAPPED`
        is returned.

        Parameters
        ----------
        resource : :py:obj:`~.CUgraphicsResource`
            None
        index : unsigned int
            None
        mipLevel : unsigned int
            None

        Returns
        -------
        CUresult

        eglFrame : :py:obj:`~.CUeglFrame`
            None
    """


def cuGraphicsResourceGetMappedMipmappedArray(resource):
    """
    cuGraphicsResourceGetMappedMipmappedArray(resource)
     Get a mipmapped array through which to access a mapped graphics resource.

        Returns in `*pMipmappedArray` a mipmapped array through which the
        mapped graphics resource `resource`. The value set in
        `*pMipmappedArray` may change every time that `resource` is mapped.

        If `resource` is not a texture then it cannot be accessed via a
        mipmapped array and :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY` is
        returned. If `resource` is not mapped then
        :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is returned.

        Parameters
        ----------
        resource : :py:obj:`~.CUgraphicsResource`
            Mapped resource to access

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY`
        pMipmappedArray : :py:obj:`~.CUmipmappedArray`
            Returned mipmapped array through which `resource` may be accessed

        See Also
        --------
        :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cudaGraphicsResourceGetMappedMipmappedArray`
    """


def cuGraphicsResourceGetMappedPointer(resource):
    """
    cuGraphicsResourceGetMappedPointer(resource)
     Get a device pointer through which to access a mapped graphics resource.

        Returns in `*pDevPtr` a pointer through which the mapped graphics
        resource `resource` may be accessed. Returns in `pSize` the size of the
        memory in bytes which may be accessed from that pointer. The value set
        in `pPointer` may change every time that `resource` is mapped.

        If `resource` is not a buffer then it cannot be accessed via a pointer
        and :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_POINTER` is returned. If
        `resource` is not mapped then :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is
        returned.

        Parameters
        ----------
        resource : :py:obj:`~.CUgraphicsResource`
            None

        Returns
        -------
        CUresult

        pDevPtr : :py:obj:`~.CUdeviceptr`
            None
        pSize : int
            None
    """


def cuGraphicsResourceSetMapFlags(resource, flags):
    """
    cuGraphicsResourceSetMapFlags(resource, unsigned int flags)
     Set usage flags for mapping a graphics resource.

        Set `flags` for mapping the graphics resource `resource`.

        Changes to `flags` will take effect the next time `resource` is mapped.
        The `flags` argument may be any of the following:

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
          about how this resource will be used. It is therefore assumed that
          this resource will be read from and written to by CUDA kernels. This
          is the default value.

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READONLY`: Specifies that
          CUDA kernels which access this resource will not write to this
          resource.

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITEDISCARD`: Specifies
          that CUDA kernels which access this resource will not read from this
          resource and will write over the entire contents of the resource, so
          none of the data previously stored in the resource will be preserved.

        If `resource` is presently mapped for access by CUDA then
        :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED` is returned. If `flags` is not
        one of the above values then :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is
        returned.

        Parameters
        ----------
        resource : :py:obj:`~.CUgraphicsResource`
            Registered resource to set flags for
        flags : unsigned int
            Parameters for resource mapping

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`

        See Also
        --------
        :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cudaGraphicsResourceSetMapFlags`
    """


def cuGraphicsSubResourceGetMappedArray(resource, arrayIndex, mipLevel):
    """
    cuGraphicsSubResourceGetMappedArray(resource, unsigned int arrayIndex, unsigned int mipLevel)
     Get an array through which to access a subresource of a mapped graphics resource.

        Returns in `*pArray` an array through which the subresource of the
        mapped graphics resource `resource` which corresponds to array index
        `arrayIndex` and mipmap level `mipLevel` may be accessed. The value set
        in `*pArray` may change every time that `resource` is mapped.

        If `resource` is not a texture then it cannot be accessed via an array
        and :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY` is returned. If
        `arrayIndex` is not a valid array index for `resource` then
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned. If `mipLevel` is not
        a valid mipmap level for `resource` then
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned. If `resource` is not
        mapped then :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is returned.

        Parameters
        ----------
        resource : :py:obj:`~.CUgraphicsResource`
            Mapped resource to access
        arrayIndex : unsigned int
            Array index for array textures or cubemap face index as defined by
            :py:obj:`~.CUarray_cubemap_face` for cubemap textures for the
            subresource to access
        mipLevel : unsigned int
            Mipmap level for the subresource to access

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY`
        pArray : :py:obj:`~.CUarray`
            Returned array through which a subresource of `resource` may be
            accessed

        See Also
        --------
        :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cudaGraphicsSubResourceGetMappedArray`
    """


def cuGraphicsUnmapResources(count, resources, hStream):
    """
    cuGraphicsUnmapResources(unsigned int count, resources, hStream)
     Unmap graphics resources.

        Unmaps the `count` graphics resources in `resources`.

        Once unmapped, the resources in `resources` may not be accessed by CUDA
        until they are mapped again.

        This function provides the synchronization guarantee that any CUDA work
        issued in `stream` before :py:obj:`~.cuGraphicsUnmapResources()` will
        complete before any subsequently issued graphics work begins.

        If `resources` includes any duplicate entries then
        :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. If any of
        `resources` are not presently mapped for access by CUDA then
        :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is returned.

        Parameters
        ----------
        count : unsigned int
            Number of resources to unmap
        resources : :py:obj:`~.CUgraphicsResource`
            Resources to unmap
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream with which to synchronize

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED`, :py:obj:`~.CUDA_ERROR_UNKNOWN`

        See Also
        --------
        :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cudaGraphicsUnmapResources`
    """


def cuGraphicsUnregisterResource(resource):
    """
    cuGraphicsUnregisterResource(resource)
     Unregisters a graphics resource for access by CUDA.

        Unregisters the graphics resource `resource` so it is not accessible by
        CUDA unless registered again.

        If `resource` is invalid then :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is
        returned.

        Parameters
        ----------
        resource : :py:obj:`~.CUgraphicsResource`
            Resource to unregister

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`

        See Also
        --------
        :py:obj:`~.cuGraphicsD3D9RegisterResource`, :py:obj:`~.cuGraphicsD3D10RegisterResource`, :py:obj:`~.cuGraphicsD3D11RegisterResource`, :py:obj:`~.cuGraphicsGLRegisterBuffer`, :py:obj:`~.cuGraphicsGLRegisterImage`, :py:obj:`~.cudaGraphicsUnregisterResource`
    """


def cuGraphicsVDPAURegisterOutputSurface(vdpSurface, flags):
    """
    cuGraphicsVDPAURegisterOutputSurface(vdpSurface, unsigned int flags)
     Registers a VDPAU VdpOutputSurface object.

        Registers the VdpOutputSurface specified by `vdpSurface` for access by
        CUDA. A handle to the registered object is returned as `pCudaResource`.
        The surface's intended usage is specified using `flags`, as follows:

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
          about how this resource will be used. It is therefore assumed that
          this resource will be read from and written to by CUDA. This is the
          default value.

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY`: Specifies that
          CUDA will not write to this resource.

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD`: Specifies
          that CUDA will not read from this resource and will write over the
          entire contents of the resource, so none of the data previously
          stored in the resource will be preserved.

        The VdpOutputSurface is presented as an array of subresources that may
        be accessed using pointers returned by
        :py:obj:`~.cuGraphicsSubResourceGetMappedArray`. The exact number of
        valid `arrayIndex` values depends on the VDPAU surface format. The
        mapping is shown in the table below. `mipLevel` must be 0.

        Parameters
        ----------
        vdpSurface : :py:obj:`~.VdpOutputSurface`
            The VdpOutputSurface to be registered
        flags : unsigned int
            Map flags

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
        pCudaResource : :py:obj:`~.CUgraphicsResource`
            Pointer to the returned object handle

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuVDPAUCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterVideoSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuVDPAUGetDevice`, :py:obj:`~.cudaGraphicsVDPAURegisterOutputSurface`
    """


def cuGraphicsVDPAURegisterVideoSurface(vdpSurface, flags):
    """
    cuGraphicsVDPAURegisterVideoSurface(vdpSurface, unsigned int flags)
     Registers a VDPAU VdpVideoSurface object.

        Registers the VdpVideoSurface specified by `vdpSurface` for access by
        CUDA. A handle to the registered object is returned as `pCudaResource`.
        The surface's intended usage is specified using `flags`, as follows:

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
          about how this resource will be used. It is therefore assumed that
          this resource will be read from and written to by CUDA. This is the
          default value.

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY`: Specifies that
          CUDA will not write to this resource.

        - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD`: Specifies
          that CUDA will not read from this resource and will write over the
          entire contents of the resource, so none of the data previously
          stored in the resource will be preserved.

        The VdpVideoSurface is presented as an array of subresources that may
        be accessed using pointers returned by
        :py:obj:`~.cuGraphicsSubResourceGetMappedArray`. The exact number of
        valid `arrayIndex` values depends on the VDPAU surface format. The
        mapping is shown in the table below. `mipLevel` must be 0.

        Parameters
        ----------
        vdpSurface : :py:obj:`~.VdpVideoSurface`
            The VdpVideoSurface to be registered
        flags : unsigned int
            Map flags

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
        pCudaResource : :py:obj:`~.CUgraphicsResource`
            Pointer to the returned object handle

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuVDPAUCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterOutputSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuVDPAUGetDevice`, :py:obj:`~.cudaGraphicsVDPAURegisterVideoSurface`
    """


def cuGreenCtxCreate(desc, dev, flags):
    """
    cuGreenCtxCreate(desc, dev, unsigned int flags)
     Creates a green context with a specified set of resources.

        This API creates a green context with the resources specified in the
        descriptor `desc` and returns it in the handle represented by `phCtx`.
        This API will retain the primary context on device `dev`, which will is
        released when the green context is destroyed. It is advised to have the
        primary context active before calling this API to avoid the heavy cost
        of triggering primary context initialization and deinitialization
        multiple times.

        The API does not set the green context current. In order to set it
        current, you need to explicitly set it current by first converting the
        green context to a CUcontext using :py:obj:`~.cuCtxFromGreenCtx` and
        subsequently calling :py:obj:`~.cuCtxSetCurrent` /
        :py:obj:`~.cuCtxPushCurrent`. It should be noted that a green context
        can be current to only one thread at a time. There is no internal
        synchronization to make API calls accessing the same green context from
        multiple threads work.

        Note: The API is not supported on 32-bit platforms.

        The supported flags are:

        - `CU_GREEN_CTX_DEFAULT_STREAM` : Creates a default stream to use
          inside the green context. Required.

        Parameters
        ----------
        desc : :py:obj:`~.CUdevResourceDesc`
            Descriptor generated via :py:obj:`~.cuDevResourceGenerateDesc`
            which contains the set of resources to be used
        dev : :py:obj:`~.CUdevice`
            Device on which to create the green context.
        flags : unsigned int
            One of the supported green context creation flags.
            `CU_GREEN_CTX_DEFAULT_STREAM` is required.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        phCtx : :py:obj:`~.CUgreenCtx`
            Pointer for the output handle to the green context

        See Also
        --------
        :py:obj:`~.cuGreenCtxDestroy`, :py:obj:`~.cuCtxFromGreenCtx`, :py:obj:`~.cuCtxSetCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuDevResourceGenerateDesc`, :py:obj:`~.cuDevicePrimaryCtxRetain`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxCreate_v3`
    """


def cuGreenCtxDestroy(hCtx):
    """
    cuGreenCtxDestroy(hCtx)
     Destroys a green context.

        Destroys the green context, releasing the primary context of the device
        that this green context was created for. Any resources provisioned for
        this green context (that were initially available via the resource
        descriptor) are released as well.

        Parameters
        ----------
        hCtx : :py:obj:`~.CUgreenCtx`
            Green context to be destroyed

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`

        See Also
        --------
        :py:obj:`~.cuGreenCtxCreate`, :py:obj:`~.cuCtxDestroy`
    """


def cuGreenCtxGetDevResource(hCtx, typename: 'CUdevResourceType'):
    """
    cuGreenCtxGetDevResource(hCtx, typename: CUdevResourceType)
     Get green context resources.

        Get the `typename` resources available to the green context represented
        by `hCtx`

        Parameters
        ----------
        hCtx : :py:obj:`~.CUgreenCtx`
            Green context to get resource for
        typename : :py:obj:`~.CUdevResourceType`
            Type of resource to retrieve

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_TYPE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        resource : :py:obj:`~.CUdevResource`
            Output pointer to a :py:obj:`~.CUdevResource` structure

        See Also
        --------
        :py:obj:`~.cuDevResourceGenerateDesc`
    """


def cuGreenCtxRecordEvent(hCtx, hEvent):
    """
    cuGreenCtxRecordEvent(hCtx, hEvent)
     Records an event.

        Captures in `hEvent` all the activities of the green context of `hCtx`
        at the time of this call. `hEvent` and `hCtx` must be from the same
        primary context otherwise :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is
        returned. Calls such as :py:obj:`~.cuEventQuery()` or
        :py:obj:`~.cuGreenCtxWaitEvent()` will then examine or wait for
        completion of the work that was captured. Uses of `hCtx` after this
        call do not modify `hEvent`.

        Parameters
        ----------
        hCtx : :py:obj:`~.CUgreenCtx`
            Green context to record event for
        hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to record

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED`

        See Also
        --------
        :py:obj:`~.cuGreenCtxWaitEvent`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuCtxRecordEvent`, :py:obj:`~.cuCtxWaitEvent`

        Notes
        -----
        The API will return :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED` if the specified green context `hCtx` has a stream in the capture mode. In such a case, the call will invalidate all the conflicting captures.
    """


def cuGreenCtxStreamCreate(greenCtx, flags, priority):
    """
    cuGreenCtxStreamCreate(greenCtx, unsigned int flags, int priority)
     Create a stream for use in the green context.

        Creates a stream for use in the specified green context `greenCtx` and
        returns a handle in `phStream`. The stream can be destroyed by calling
        :py:obj:`~.cuStreamDestroy()`. Note that the API ignores the context
        that is current to the calling thread and creates a stream in the
        specified green context `greenCtx`.

        The supported values for `flags` are:

        - :py:obj:`~.CU_STREAM_NON_BLOCKING`: This must be specified. It
          indicates that work running in the created stream may run
          concurrently with work in the default stream, and that the created
          stream should perform no implicit synchronization with the default
          stream.

        Specifying `priority` affects the scheduling priority of work in the
        stream. Priorities provide a hint to preferentially run work with
        higher priority when possible, but do not preempt already-running work
        or provide any other functional guarantee on execution order.
        `priority` follows a convention where lower numbers represent higher
        priorities. '0' represents default priority. The range of meaningful
        numerical priorities can be queried using
        :py:obj:`~.cuCtxGetStreamPriorityRange`. If the specified priority is
        outside the numerical range returned by
        :py:obj:`~.cuCtxGetStreamPriorityRange`, it will automatically be
        clamped to the lowest or the highest number in the range.

        Parameters
        ----------
        greenCtx : :py:obj:`~.CUgreenCtx`
            Green context for which to create the stream for
        flags : unsigned int
            Flags for stream creation. `CU_STREAM_NON_BLOCKING` must be
            specified.
        priority : int
            Stream priority. Lower numbers represent higher priorities. See
            :py:obj:`~.cuCtxGetStreamPriorityRange` for more information about
            meaningful stream priorities that can be passed.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        phStream : :py:obj:`~.CUstream`
            Returned newly created stream

        See Also
        --------
        :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuGreenCtxCreate` :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice` :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreateWithPriority`

        Notes
        -----
        In the current implementation, only compute kernels launched in priority streams are affected by the stream's priority. Stream priorities have no effect on host-to-device and device-to-host memory operations.
    """


def cuGreenCtxWaitEvent(hCtx, hEvent):
    """
    cuGreenCtxWaitEvent(hCtx, hEvent)
     Make a green context wait on an event.

        Makes all future work submitted to green context `hCtx` wait for all
        work captured in `hEvent`. The synchronization will be performed on the
        device and will not block the calling CPU thread. See
        :py:obj:`~.cuGreenCtxRecordEvent()` or :py:obj:`~.cuEventRecord()`, for
        details on what is captured by an event.

        Parameters
        ----------
        hCtx : :py:obj:`~.CUgreenCtx`
            Green context to wait
        hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to wait on

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED`

        See Also
        --------
        :py:obj:`~.cuGreenCtxRecordEvent`, :py:obj:`~.cuStreamWaitEvent` :py:obj:`~.cuCtxRecordEvent`, :py:obj:`~.cuCtxWaitEvent`

        Notes
        -----
        `hEvent` may be from a different context or device than `hCtx`.

        The API will return :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED` and invalidate the capture if the specified event `hEvent` is part of an ongoing capture sequence or if the specified green context `hCtx` has a stream in the capture mode.
    """


def cuImportExternalMemory(memHandleDesc: 'Optional[CUDA_EXTERNAL_MEMORY_HANDLE_DESC]'):
    """
    cuImportExternalMemory(CUDA_EXTERNAL_MEMORY_HANDLE_DESC memHandleDesc: Optional[CUDA_EXTERNAL_MEMORY_HANDLE_DESC])
     Imports an external memory object.

        Imports an externally allocated memory object and returns a handle to
        that in `extMem_out`.

        The properties of the handle being imported must be described in
        `memHandleDesc`. The :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`
        structure is defined as follows:

        **View CUDA Toolkit Documentation for a C++ code example**

        where :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` specifies the
        type of handle being imported. :py:obj:`~.CUexternalMemoryHandleType`
        is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD`, then
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::fd must be a
        valid file descriptor referencing a memory object. Ownership of the
        file descriptor is transferred to the CUDA driver when the handle is
        imported successfully. Performing any operations on the file descriptor
        after it is imported results in undefined behavior.

        If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32`, then exactly
        one of
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle and
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
        not be NULL. If
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle is
        not NULL, then it must represent a valid shared NT handle that
        references a memory object. Ownership of this handle is not transferred
        to CUDA after the import operation, so the application must release the
        handle using the appropriate system call. If
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
        not NULL, then it must point to a NULL-terminated array of UTF-16
        characters that refers to a memory object.

        If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT`, then
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
        must be non-NULL and
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
        be NULL. The handle specified must be a globally shared KMT handle.
        This handle does not hold a reference to the underlying object, and
        thus will be invalid when all references to the memory object are
        destroyed.

        If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP`, then exactly one
        of :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
        and :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name
        must not be NULL. If
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle is
        not NULL, then it must represent a valid shared NT handle that is
        returned by ID3D12Device::CreateSharedHandle when referring to a
        ID3D12Heap object. This handle holds a reference to the underlying
        object. If
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
        not NULL, then it must point to a NULL-terminated array of UTF-16
        characters that refers to a ID3D12Heap object.

        If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE`, then exactly
        one of
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle and
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
        not be NULL. If
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle is
        not NULL, then it must represent a valid shared NT handle that is
        returned by ID3D12Device::CreateSharedHandle when referring to a
        ID3D12Resource object. This handle holds a reference to the underlying
        object. If
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
        not NULL, then it must point to a NULL-terminated array of UTF-16
        characters that refers to a ID3D12Resource object.

        If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE`, then
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
        must represent a valid shared NT handle that is returned by
        IDXGIResource1::CreateSharedHandle when referring to a ID3D11Resource
        object. If
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
        not NULL, then it must point to a NULL-terminated array of UTF-16
        characters that refers to a ID3D11Resource object.

        If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT`, then
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
        must represent a valid shared KMT handle that is returned by
        IDXGIResource::GetSharedHandle when referring to a ID3D11Resource
        object and
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
        be NULL.

        If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`, then
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::nvSciBufObject
        must be non-NULL and reference a valid NvSciBuf object. If the NvSciBuf
        object imported into CUDA is also mapped by other drivers, then the
        application must use :py:obj:`~.cuWaitExternalSemaphoresAsync` or
        :py:obj:`~.cuSignalExternalSemaphoresAsync` as appropriate barriers to
        maintain coherence between CUDA and the other drivers. See
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC` and
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC` for
        memory synchronization.

        The size of the memory object must be specified in
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.size`.

        Specifying the flag :py:obj:`~.CUDA_EXTERNAL_MEMORY_DEDICATED` in
        :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.flags` indicates that the
        resource is a dedicated resource. The definition of what a dedicated
        resource is outside the scope of this extension. This flag must be set
        if :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is one of the
        following: :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE`
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE`
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT`

        Parameters
        ----------
        memHandleDesc : :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`
            Memory import handle descriptor

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OPERATING_SYSTEM`
        extMem_out : :py:obj:`~.CUexternalMemory`
            Returned handle to an external memory object

        See Also
        --------
        :py:obj:`~.cuDestroyExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedBuffer`, :py:obj:`~.cuExternalMemoryGetMappedMipmappedArray`

        Notes
        -----
        If the Vulkan memory imported into CUDA is mapped on the CPU then the application must use vkInvalidateMappedMemoryRanges/vkFlushMappedMemoryRanges as well as appropriate Vulkan pipeline barriers to maintain coherence between CPU and GPU. For more information on these APIs, please refer to "Synchronization
        and Cache Control" chapter from Vulkan specification.
    """


def cuImportExternalSemaphore(semHandleDesc: 'Optional[CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC]'):
    """
    cuImportExternalSemaphore(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC semHandleDesc: Optional[CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC])
     Imports an external semaphore.

        Imports an externally allocated synchronization object and returns a
        handle to that in `extSem_out`.

        The properties of the handle being imported must be described in
        `semHandleDesc`. The :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC` is
        defined as follows:

        **View CUDA Toolkit Documentation for a C++ code example**

        where :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` specifies
        the type of handle being imported.
        :py:obj:`~.CUexternalSemaphoreHandleType` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD`, then
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::fd must be a
        valid file descriptor referencing a synchronization object. Ownership
        of the file descriptor is transferred to the CUDA driver when the
        handle is imported successfully. Performing any operations on the file
        descriptor after it is imported results in undefined behavior.

        If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32`, then
        exactly one of
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
        and
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
        must not be NULL. If
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
        is not NULL, then it must represent a valid shared NT handle that
        references a synchronization object. Ownership of this handle is not
        transferred to CUDA after the import operation, so the application must
        release the handle using the appropriate system call. If
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
        not NULL, then it must name a valid synchronization object.

        If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT`, then
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
        must be non-NULL and
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
        must be NULL. The handle specified must be a globally shared KMT
        handle. This handle does not hold a reference to the underlying object,
        and thus will be invalid when all references to the synchronization
        object are destroyed.

        If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE`, then exactly
        one of
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
        and
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
        must not be NULL. If
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
        is not NULL, then it must represent a valid shared NT handle that is
        returned by ID3D12Device::CreateSharedHandle when referring to a
        ID3D12Fence object. This handle holds a reference to the underlying
        object. If
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
        not NULL, then it must name a valid synchronization object that refers
        to a valid ID3D12Fence object.

        If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE`, then
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
        represents a valid shared NT handle that is returned by
        ID3D11Fence::CreateSharedHandle. If
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
        not NULL, then it must name a valid synchronization object that refers
        to a valid ID3D11Fence object.

        If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC`, then
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::nvSciSyncObj
        represents a valid NvSciSyncObj.

        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX`, then
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
        represents a valid shared NT handle that is returned by
        IDXGIResource1::CreateSharedHandle when referring to a IDXGIKeyedMutex
        object. If
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
        not NULL, then it must name a valid synchronization object that refers
        to a valid IDXGIKeyedMutex object.

        If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT`,
        then
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
        represents a valid shared KMT handle that is returned by
        IDXGIResource::GetSharedHandle when referring to a IDXGIKeyedMutex
        object and
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
        must be NULL.

        If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD`,
        then :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::fd must
        be a valid file descriptor referencing a synchronization object.
        Ownership of the file descriptor is transferred to the CUDA driver when
        the handle is imported successfully. Performing any operations on the
        file descriptor after it is imported results in undefined behavior.

        If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32`,
        then exactly one of
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
        and
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
        must not be NULL. If
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
        is not NULL, then it must represent a valid shared NT handle that
        references a synchronization object. Ownership of this handle is not
        transferred to CUDA after the import operation, so the application must
        release the handle using the appropriate system call. If
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
        not NULL, then it must name a valid synchronization object.

        Parameters
        ----------
        semHandleDesc : :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`
            Semaphore import handle descriptor

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OPERATING_SYSTEM`
        extSem_out : :py:obj:`~.CUexternalSemaphore`
            Returned handle to an external semaphore

        See Also
        --------
        :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """


def cuInit(Flags):
    """
    cuInit(unsigned int Flags)
     Initialize the CUDA driver API Initializes the driver API and must be called before any other function from the driver API in the current process. Currently, the `Flags` parameter must be 0. If :py:obj:`~.cuInit()` has not been called, any function from the driver API will return :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`.

        Parameters
        ----------
        Flags : unsigned int
            Initialization flag for CUDA.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_SYSTEM_DRIVER_MISMATCH`, :py:obj:`~.CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE`
    """


def cuIpcCloseMemHandle(dptr):
    """
    cuIpcCloseMemHandle(dptr)
     Attempts to close memory mapped with :py:obj:`~.cuIpcOpenMemHandle`.

        Decrements the reference count of the memory returned by
        :py:obj:`~.cuIpcOpenMemHandle` by 1. When the reference count reaches
        0, this API unmaps the memory. The original allocation in the exporting
        process as well as imported mappings in other processes will be
        unaffected.

        Any resources used to enable peer access will be freed if this is the
        last mapping using them.

        IPC functionality is restricted to devices with support for unified
        addressing on Linux and Windows operating systems. IPC functionality on
        Windows is supported for compatibility purposes but not recommended as
        it comes with performance cost. Users can test their device for IPC
        functionality by calling :py:obj:`~.cuapiDeviceGetAttribute` with
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED`

        Parameters
        ----------
        dptr : :py:obj:`~.CUdeviceptr`
            Device pointer returned by :py:obj:`~.cuIpcOpenMemHandle`

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cudaIpcCloseMemHandle`
    """


def cuIpcGetEventHandle(event):
    """
    cuIpcGetEventHandle(event)
     Gets an interprocess handle for a previously allocated event.

        Takes as input a previously allocated event. This event must have been
        created with the :py:obj:`~.CU_EVENT_INTERPROCESS` and
        :py:obj:`~.CU_EVENT_DISABLE_TIMING` flags set. This opaque handle may
        be copied into other processes and opened with
        :py:obj:`~.cuIpcOpenEventHandle` to allow efficient hardware
        synchronization between GPU work in different processes.

        After the event has been opened in the importing process,
        :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventSynchronize`,
        :py:obj:`~.cuStreamWaitEvent` and :py:obj:`~.cuEventQuery` may be used
        in either process. Performing operations on the imported event after
        the exported event has been freed with :py:obj:`~.cuEventDestroy` will
        result in undefined behavior.

        IPC functionality is restricted to devices with support for unified
        addressing on Linux and Windows operating systems. IPC functionality on
        Windows is supported for compatibility purposes but not recommended as
        it comes with performance cost. Users can test their device for IPC
        functionality by calling :py:obj:`~.cuapiDeviceGetAttribute` with
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED`

        Parameters
        ----------
        event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event allocated with :py:obj:`~.CU_EVENT_INTERPROCESS` and
            :py:obj:`~.CU_EVENT_DISABLE_TIMING` flags.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pHandle : :py:obj:`~.CUipcEventHandle`
            Pointer to a user allocated CUipcEventHandle in which to return the
            opaque event handle

        See Also
        --------
        :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cudaIpcGetEventHandle`
    """


def cuIpcGetMemHandle(dptr):
    """
    cuIpcGetMemHandle(dptr)
     Gets an interprocess memory handle for an existing device memory allocation.

        Takes a pointer to the base of an existing device memory allocation
        created with :py:obj:`~.cuMemAlloc` and exports it for use in another
        process. This is a lightweight operation and may be called multiple
        times on an allocation without adverse effects.

        If a region of memory is freed with :py:obj:`~.cuMemFree` and a
        subsequent call to :py:obj:`~.cuMemAlloc` returns memory with the same
        device address, :py:obj:`~.cuIpcGetMemHandle` will return a unique
        handle for the new memory.

        IPC functionality is restricted to devices with support for unified
        addressing on Linux and Windows operating systems. IPC functionality on
        Windows is supported for compatibility purposes but not recommended as
        it comes with performance cost. Users can test their device for IPC
        functionality by calling :py:obj:`~.cuapiDeviceGetAttribute` with
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED`

        Parameters
        ----------
        dptr : :py:obj:`~.CUdeviceptr`
            Base pointer to previously allocated device memory

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pHandle : :py:obj:`~.CUipcMemHandle`
            Pointer to user allocated :py:obj:`~.CUipcMemHandle` to return the
            handle in.

        See Also
        --------
        :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cudaIpcGetMemHandle`
    """


def cuIpcOpenEventHandle(handle: 'CUipcEventHandle'):
    """
    cuIpcOpenEventHandle(CUipcEventHandle handle: CUipcEventHandle)
     Opens an interprocess event handle for use in the current process.

        Opens an interprocess event handle exported from another process with
        :py:obj:`~.cuIpcGetEventHandle`. This function returns a
        :py:obj:`~.CUevent` that behaves like a locally created event with the
        :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag specified. This event must be
        freed with :py:obj:`~.cuEventDestroy`.

        Performing operations on the imported event after the exported event
        has been freed with :py:obj:`~.cuEventDestroy` will result in undefined
        behavior.

        IPC functionality is restricted to devices with support for unified
        addressing on Linux and Windows operating systems. IPC functionality on
        Windows is supported for compatibility purposes but not recommended as
        it comes with performance cost. Users can test their device for IPC
        functionality by calling :py:obj:`~.cuapiDeviceGetAttribute` with
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED`

        Parameters
        ----------
        handle : :py:obj:`~.CUipcEventHandle`
            Interprocess handle to open

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phEvent : :py:obj:`~.CUevent`
            Returns the imported event

        See Also
        --------
        :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cudaIpcOpenEventHandle`
    """


def cuIpcOpenMemHandle(handle: 'CUipcMemHandle', Flags):
    """
    cuIpcOpenMemHandle(CUipcMemHandle handle: CUipcMemHandle, unsigned int Flags)
     Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process.

        Maps memory exported from another process with
        :py:obj:`~.cuIpcGetMemHandle` into the current device address space.
        For contexts on different devices :py:obj:`~.cuIpcOpenMemHandle` can
        attempt to enable peer access between the devices as if the user called
        :py:obj:`~.cuCtxEnablePeerAccess`. This behavior is controlled by the
        :py:obj:`~.CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS` flag.
        :py:obj:`~.cuDeviceCanAccessPeer` can determine if a mapping is
        possible.

        Contexts that may open :py:obj:`~.CUipcMemHandles` are restricted in
        the following way. :py:obj:`~.CUipcMemHandles` from each
        :py:obj:`~.CUdevice` in a given process may only be opened by one
        :py:obj:`~.CUcontext` per :py:obj:`~.CUdevice` per other process.

        If the memory handle has already been opened by the current context,
        the reference count on the handle is incremented by 1 and the existing
        device pointer is returned.

        Memory returned from :py:obj:`~.cuIpcOpenMemHandle` must be freed with
        :py:obj:`~.cuIpcCloseMemHandle`.

        Calling :py:obj:`~.cuMemFree` on an exported memory region before
        calling :py:obj:`~.cuIpcCloseMemHandle` in the importing context will
        result in undefined behavior.

        IPC functionality is restricted to devices with support for unified
        addressing on Linux and Windows operating systems. IPC functionality on
        Windows is supported for compatibility purposes but not recommended as
        it comes with performance cost. Users can test their device for IPC
        functionality by calling :py:obj:`~.cuapiDeviceGetAttribute` with
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED`

        Parameters
        ----------
        handle : :py:obj:`~.CUipcMemHandle`
            :py:obj:`~.CUipcMemHandle` to open
        Flags : unsigned int
            Flags for this operation. Must be specified as
            :py:obj:`~.CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS`

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_TOO_MANY_PEERS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pdptr : :py:obj:`~.CUdeviceptr`
            Returned device pointer

        See Also
        --------
        :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cudaIpcOpenMemHandle`

        Notes
        -----
        No guarantees are made about the address returned in `*pdptr`. In particular, multiple processes may not receive the same address for the same `handle`.
    """


def cuKernelGetAttribute(attrib: 'CUfunction_attribute', kernel, dev):
    """
    cuKernelGetAttribute(attrib: CUfunction_attribute, kernel, dev)
     Returns information about a kernel.

        Returns in `*pi` the integer value of the attribute `attrib` for the
        kernel `kernel` for the requested device `dev`. The supported
        attributes are:

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK`: The maximum
          number of threads per block, beyond which a launch of the kernel
          would fail. This number depends on both the kernel and the requested
          device.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES`: The size in bytes of
          statically-allocated shared memory per block required by this kernel.
          This does not include dynamically-allocated shared memory requested
          by the user at runtime.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES`: The size in bytes of
          user-allocated constant memory required by this kernel.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES`: The size in bytes of
          local memory used by each thread of this kernel.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_NUM_REGS`: The number of registers used
          by each thread of this kernel.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_PTX_VERSION`: The PTX virtual
          architecture version for which the kernel was compiled. This value is
          the major PTX version * 10

          - the minor PTX version, so a PTX version 1.3 function would return
            the value 13. Note that this may return the undefined value of 0
            for cubins compiled prior to CUDA 3.0.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_BINARY_VERSION`: The binary architecture
          version for which the kernel was compiled. This value is the major
          binary version * 10 + the minor binary version, so a binary version
          1.3 function would return the value 13. Note that this will return a
          value of 10 for legacy cubins that do not have a properly-encoded
          binary architecture version.

        - :py:obj:`~.CU_FUNC_CACHE_MODE_CA`: The attribute to indicate whether
          the kernel has been compiled with user specified option "-Xptxas
          --dlcm=ca" set.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`: The
          maximum size in bytes of dynamically-allocated shared memory.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`:
          Preferred shared memory-L1 cache split ratio in percent of total
          shared memory.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET`: If this
          attribute is set, the kernel must launch with a valid cluster size
          specified.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH`: The required
          cluster width in blocks.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT`: The required
          cluster height in blocks.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH`: The required
          cluster depth in blocks.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED`:
          Indicates whether the function can be launched with non-portable
          cluster size. 1 is allowed, 0 is disallowed. A non-portable cluster
          size may only function on the specific SKUs the program is tested on.
          The launch might fail if the program is run on a different hardware
          platform. CUDA API provides cudaOccupancyMaxActiveClusters to assist
          with checking whether the desired size can be launched on the current
          device. A portable cluster size is guaranteed to be functional on all
          compute capabilities higher than the target compute capability. The
          portable cluster size for sm_90 is 8 blocks per cluster. This value
          may increase for future compute capabilities. The specific hardware
          unit may support higher cluster sizes thats not guaranteed to be
          portable.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE`:
          The block scheduling policy of a function. The value type is
          CUclusterSchedulingPolicy.

        Parameters
        ----------
        attrib : :py:obj:`~.CUfunction_attribute`
            Attribute requested
        kernel : :py:obj:`~.CUkernel`
            Kernel to query attribute of
        dev : :py:obj:`~.CUdevice`
            Device to query attribute of

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        pi : int
            Returned attribute value

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuKernelSetAttribute`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuKernelGetFunction`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuFuncGetAttribute`

        Notes
        -----
        If another thread is trying to set the same attribute on the same device using :py:obj:`~.cuKernelSetAttribute()` simultaneously, the attribute query will give the old or new value depending on the interleavings chosen by the OS scheduler and memory consistency.
    """


def cuKernelGetFunction(kernel):
    """
    cuKernelGetFunction(kernel)
     Returns a function handle.

        Returns in `pFunc` the handle of the function for the requested kernel
        `kernel` and the current context. If function handle is not found, the
        call returns :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

        Parameters
        ----------
        kernel : :py:obj:`~.CUkernel`
            Kernel to retrieve function for the requested context

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`
        pFunc : :py:obj:`~.CUfunction`
            Returned function handle

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetFunction`
    """


def cuKernelGetLibrary(kernel):
    """
    cuKernelGetLibrary(kernel)
     Returns a library handle.

        Returns in `pLib` the handle of the library for the requested kernel
        `kernel`

        Parameters
        ----------
        kernel : :py:obj:`~.CUkernel`
            Kernel to retrieve library handle

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
        pLib : :py:obj:`~.CUlibrary`
            Returned library handle

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuLibraryGetKernel`
    """


def cuKernelGetName(hfunc):
    """
    cuKernelGetName(hfunc)
     Returns the function name for a :py:obj:`~.CUkernel` handle.

        Returns in `**name` the function name associated with the kernel handle
        `hfunc` . The function name is returned as a null-terminated string.
        The returned name is only valid when the kernel handle is valid. If the
        library is unloaded or reloaded, one must call the API again to get the
        updated name. This API may return a mangled name if the function is not
        declared as having C linkage. If either `**name` or `hfunc` is NULL,
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUkernel`
            The function handle to retrieve the name for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        name : bytes
            The returned name of the function
    """


def cuKernelGetParamInfo(kernel, paramIndex):
    """
    cuKernelGetParamInfo(kernel, size_t paramIndex)
     Returns the offset and size of a kernel parameter in the device-side parameter layout.

        Queries the kernel parameter at `paramIndex` into `kernel's` list of
        parameters, and returns in `paramOffset` and `paramSize` the offset and
        size, respectively, where the parameter will reside in the device-side
        parameter layout. This information can be used to update kernel node
        parameters from the device via
        :py:obj:`~.cudaGraphKernelNodeSetParam()` and
        :py:obj:`~.cudaGraphKernelNodeUpdatesApply()`. `paramIndex` must be
        less than the number of parameters that `kernel` takes. `paramSize` can
        be set to NULL if only the parameter offset is desired.

        Parameters
        ----------
        kernel : :py:obj:`~.CUkernel`
            The kernel to query
        paramIndex : size_t
            The parameter index to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        paramOffset : int
            Returns the offset into the device-side parameter layout at which
            the parameter resides
        paramSize : int
            Optionally returns the size of the parameter in the device-side
            parameter layout

        See Also
        --------
        :py:obj:`~.cuFuncGetParamInfo`
    """


def cuKernelSetAttribute(attrib: 'CUfunction_attribute', val, kernel, dev):
    """
    cuKernelSetAttribute(attrib: CUfunction_attribute, int val, kernel, dev)
     Sets information about a kernel.

        This call sets the value of a specified attribute `attrib` on the
        kernel `kernel` for the requested device `dev` to an integer value
        specified by `val`. This function returns CUDA_SUCCESS if the new value
        of the attribute could be successfully set. If the set fails, this call
        will return an error. Not all attributes can have values set.
        Attempting to set a value on a read-only attribute will result in an
        error (CUDA_ERROR_INVALID_VALUE)

        Note that attributes set using :py:obj:`~.cuFuncSetAttribute()` will
        override the attribute set by this API irrespective of whether the call
        to :py:obj:`~.cuFuncSetAttribute()` is made before or after this API
        call. However, :py:obj:`~.cuKernelGetAttribute()` will always return
        the attribute value set by this API.

        Supported attributes are:

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`: This is
          the maximum size in bytes of dynamically-allocated shared memory. The
          value should contain the requested maximum size of dynamically-
          allocated shared memory. The sum of this value and the function
          attribute :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES` cannot
          exceed the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN`.
          The maximal size of requestable dynamic shared memory may differ by
          GPU architecture.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`: On
          devices where the L1 cache and shared memory use the same hardware
          resources, this sets the shared memory carveout preference, in
          percent of the total shared memory. See
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR`
          This is only a hint, and the driver can choose a different ratio if
          required to execute the function.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH`: The required
          cluster width in blocks. The width, height, and depth values must
          either all be 0 or all be positive. The validity of the cluster
          dimensions is checked at launch time. If the value is set during
          compile time, it cannot be set at runtime. Setting it at runtime will
          return CUDA_ERROR_NOT_PERMITTED.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT`: The required
          cluster height in blocks. The width, height, and depth values must
          either all be 0 or all be positive. The validity of the cluster
          dimensions is checked at launch time. If the value is set during
          compile time, it cannot be set at runtime. Setting it at runtime will
          return CUDA_ERROR_NOT_PERMITTED.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH`: The required
          cluster depth in blocks. The width, height, and depth values must
          either all be 0 or all be positive. The validity of the cluster
          dimensions is checked at launch time. If the value is set during
          compile time, it cannot be set at runtime. Setting it at runtime will
          return CUDA_ERROR_NOT_PERMITTED.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED`:
          Indicates whether the function can be launched with non-portable
          cluster size. 1 is allowed, 0 is disallowed.

        - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE`:
          The block scheduling policy of a function. The value type is
          CUclusterSchedulingPolicy.

        Parameters
        ----------
        attrib : :py:obj:`~.CUfunction_attribute`
            Attribute requested
        val : int
            Value to set
        kernel : :py:obj:`~.CUkernel`
            Kernel to set attribute of
        dev : :py:obj:`~.CUdevice`
            Device to set attribute of

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuKernelGetAttribute`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuKernelGetFunction`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuFuncSetAttribute`

        Notes
        -----
        The API has stricter locking requirements in comparison to its legacy counterpart :py:obj:`~.cuFuncSetAttribute()` due to device-wide semantics. If multiple threads are trying to set the same attribute on the same device simultaneously, the attribute setting will depend on the interleavings chosen by the OS scheduler and memory consistency.
    """


def cuKernelSetCacheConfig(kernel, config: 'CUfunc_cache', dev):
    """
    cuKernelSetCacheConfig(kernel, config: CUfunc_cache, dev)
     Sets the preferred cache configuration for a device kernel.

        On devices where the L1 cache and shared memory use the same hardware
        resources, this sets through `config` the preferred cache configuration
        for the device kernel `kernel` on the requested device `dev`. This is
        only a preference. The driver will use the requested configuration if
        possible, but it is free to choose a different configuration if
        required to execute `kernel`. Any context-wide preference set via
        :py:obj:`~.cuCtxSetCacheConfig()` will be overridden by this per-kernel
        setting.

        Note that attributes set using :py:obj:`~.cuFuncSetCacheConfig()` will
        override the attribute set by this API irrespective of whether the call
        to :py:obj:`~.cuFuncSetCacheConfig()` is made before or after this API
        call.

        This setting does nothing on devices where the size of the L1 cache and
        shared memory are fixed.

        Launching a kernel with a different preference than the most recent
        preference setting may insert a device-side synchronization point.

        The supported cache configurations are:

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`: no preference for shared
          memory or L1 (default)

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_SHARED`: prefer larger shared memory
          and smaller L1 cache

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_L1`: prefer larger L1 cache and
          smaller shared memory

        - :py:obj:`~.CU_FUNC_CACHE_PREFER_EQUAL`: prefer equal sized L1 cache
          and shared memory

        Parameters
        ----------
        kernel : :py:obj:`~.CUkernel`
            Kernel to configure cache for
        config : :py:obj:`~.CUfunc_cache`
            Requested cache configuration
        dev : :py:obj:`~.CUdevice`
            Device to set attribute of

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuKernelGetFunction`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuLaunchKernel`

        Notes
        -----
        The API has stricter locking requirements in comparison to its legacy counterpart :py:obj:`~.cuFuncSetCacheConfig()` due to device-wide semantics. If multiple threads are trying to set a config on the same device simultaneously, the cache config setting will depend on the interleavings chosen by the OS scheduler and memory consistency.
    """


def cuLaunch(f):
    """
    cuLaunch(f)
     Launches a CUDA function.

        [Deprecated]

        Invokes the kernel `f` on a 1 x 1 x 1 grid of blocks. The block
        contains the number of threads specified by a previous call to
        :py:obj:`~.cuFuncSetBlockShape()`.

        The block shape, dynamic shared memory size, and parameter information
        must be set using :py:obj:`~.cuFuncSetBlockShape()`,
        :py:obj:`~.cuFuncSetSharedSize()`, :py:obj:`~.cuParamSetSize()`,
        :py:obj:`~.cuParamSeti()`, :py:obj:`~.cuParamSetf()`, and
        :py:obj:`~.cuParamSetv()` prior to calling this function.

        Launching a function via :py:obj:`~.cuLaunchKernel()` invalidates the
        function's block shape, dynamic shared memory size, and parameter
        information. After launching via cuLaunchKernel, this state must be re-
        initialized prior to calling this function. Failure to do so results in
        undefined behavior.

        Parameters
        ----------
        f : :py:obj:`~.CUfunction`
            Kernel to launch

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

        See Also
        --------
        :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """


def cuLaunchCooperativeKernel(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, hStream, kernelParams):
    """
    cuLaunchCooperativeKernel(f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hStream, kernelParams)
     Launches a CUDA function :py:obj:`~.CUfunction` or a CUDA kernel :py:obj:`~.CUkernel` where thread blocks can cooperate and synchronize as they execute.

        Invokes the function :py:obj:`~.CUfunction` or the kernel
        :py:obj:`~.CUkernel` `f` on a `gridDimX` x `gridDimY` x `gridDimZ` grid
        of blocks. Each block contains `blockDimX` x `blockDimY` x `blockDimZ`
        threads.

        `sharedMemBytes` sets the amount of dynamic shared memory that will be
        available to each thread block.

        The device on which this kernel is invoked must have a non-zero value
        for the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH`.

        The total number of blocks launched cannot exceed the maximum number of
        blocks per multiprocessor as returned by
        :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor` (or
        :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`) times
        the number of multiprocessors as specified by the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT`.

        The kernel cannot make use of CUDA dynamic parallelism.

        Kernel parameters must be specified via `kernelParams`. If `f` has N
        parameters, then `kernelParams` needs to be an array of N pointers.
        Each of `kernelParams`[0] through `kernelParams`[N-1] must point to a
        region of memory from which the actual kernel parameter will be copied.
        The number of kernel parameters and their offsets and sizes do not need
        to be specified as that information is retrieved directly from the
        kernel's image.

        Calling :py:obj:`~.cuLaunchCooperativeKernel()` sets persistent
        function state that is the same as function state set through
        :py:obj:`~.cuLaunchKernel` API

        When the kernel `f` is launched via
        :py:obj:`~.cuLaunchCooperativeKernel()`, the previous block shape,
        shared size and parameter info associated with `f` is overwritten.

        Note that to use :py:obj:`~.cuLaunchCooperativeKernel()`, the kernel
        `f` must either have been compiled with toolchain version 3.2 or later
        so that it will contain kernel parameter information, or have no kernel
        parameters. If either of these conditions is not met, then
        :py:obj:`~.cuLaunchCooperativeKernel()` will return
        :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`.

        Note that the API can also be used to launch context-less kernel
        :py:obj:`~.CUkernel` by querying the handle using
        :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
        casting to :py:obj:`~.CUfunction`. Here, the context to launch the
        kernel on will either be taken from the specified stream `hStream` or
        the current context in case of NULL stream.

        Parameters
        ----------
        f : :py:obj:`~.CUfunction`
            Function :py:obj:`~.CUfunction` or Kernel :py:obj:`~.CUkernel` to
            launch
        gridDimX : unsigned int
            Width of grid in blocks
        gridDimY : unsigned int
            Height of grid in blocks
        gridDimZ : unsigned int
            Depth of grid in blocks
        blockDimX : unsigned int
            X dimension of each thread block
        blockDimY : unsigned int
            Y dimension of each thread block
        blockDimZ : unsigned int
            Z dimension of each thread block
        sharedMemBytes : unsigned int
            Dynamic shared-memory size per thread block in bytes
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier
        kernelParams : Any
            Array of pointers to kernel parameters

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`

        See Also
        --------
        :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchCooperativeKernelMultiDevice`, :py:obj:`~.cudaLaunchCooperativeKernel`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuKernelSetCacheConfig`, :py:obj:`~.cuKernelGetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    """


def cuLaunchCooperativeKernelMultiDevice(launchParamsList: 'Optional[Tuple[CUDA_LAUNCH_PARAMS] | List[CUDA_LAUNCH_PARAMS]]', numDevices, flags):
    """
    cuLaunchCooperativeKernelMultiDevice(launchParamsList: Optional[Tuple[CUDA_LAUNCH_PARAMS] | List[CUDA_LAUNCH_PARAMS]], unsigned int numDevices, unsigned int flags)
     Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute.

        [Deprecated]

        Invokes kernels as specified in the `launchParamsList` array where each
        element of the array specifies all the parameters required to perform a
        single kernel launch. These kernels can cooperate and synchronize as
        they execute. The size of the array is specified by `numDevices`.

        No two kernels can be launched on the same device. All the devices
        targeted by this multi-device launch must be identical. All devices
        must have a non-zero value for the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH`.

        All kernels launched must be identical with respect to the compiled
        code. Note that any device, constant or managed variables present in
        the module that owns the kernel launched on each device, are
        independently instantiated on every device. It is the application's
        responsibility to ensure these variables are initialized and used
        appropriately.

        The size of the grids as specified in blocks, the size of the blocks
        themselves and the amount of shared memory used by each thread block
        must also match across all launched kernels.

        The streams used to launch these kernels must have been created via
        either :py:obj:`~.cuStreamCreate` or
        :py:obj:`~.cuStreamCreateWithPriority`. The NULL stream or
        :py:obj:`~.CU_STREAM_LEGACY` or :py:obj:`~.CU_STREAM_PER_THREAD` cannot
        be used.

        The total number of blocks launched per kernel cannot exceed the
        maximum number of blocks per multiprocessor as returned by
        :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor` (or
        :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`) times
        the number of multiprocessors as specified by the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT`. Since the total
        number of blocks launched per device has to match across all devices,
        the maximum number of blocks that can be launched per device will be
        limited by the device with the least number of multiprocessors.

        The kernels cannot make use of CUDA dynamic parallelism.

        The :py:obj:`~.CUDA_LAUNCH_PARAMS` structure is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - :py:obj:`~.CUDA_LAUNCH_PARAMS.function` specifies the kernel to be
          launched. All functions must be identical with respect to the
          compiled code. Note that you can also specify context-less kernel
          :py:obj:`~.CUkernel` by querying the handle using
          :py:obj:`~.cuLibraryGetKernel()` and then casting to
          :py:obj:`~.CUfunction`. In this case, the context to launch the
          kernel on be taken from the specified stream
          :py:obj:`~.CUDA_LAUNCH_PARAMS.hStream`.

        - :py:obj:`~.CUDA_LAUNCH_PARAMS.gridDimX` is the width of the grid in
          blocks. This must match across all kernels launched.

        - :py:obj:`~.CUDA_LAUNCH_PARAMS.gridDimY` is the height of the grid in
          blocks. This must match across all kernels launched.

        - :py:obj:`~.CUDA_LAUNCH_PARAMS.gridDimZ` is the depth of the grid in
          blocks. This must match across all kernels launched.

        - :py:obj:`~.CUDA_LAUNCH_PARAMS.blockDimX` is the X dimension of each
          thread block. This must match across all kernels launched.

        - :py:obj:`~.CUDA_LAUNCH_PARAMS.blockDimX` is the Y dimension of each
          thread block. This must match across all kernels launched.

        - :py:obj:`~.CUDA_LAUNCH_PARAMS.blockDimZ` is the Z dimension of each
          thread block. This must match across all kernels launched.

        - :py:obj:`~.CUDA_LAUNCH_PARAMS.sharedMemBytes` is the dynamic shared-
          memory size per thread block in bytes. This must match across all
          kernels launched.

        - :py:obj:`~.CUDA_LAUNCH_PARAMS.hStream` is the handle to the stream to
          perform the launch in. This cannot be the NULL stream or
          :py:obj:`~.CU_STREAM_LEGACY` or :py:obj:`~.CU_STREAM_PER_THREAD`. The
          CUDA context associated with this stream must match that associated
          with :py:obj:`~.CUDA_LAUNCH_PARAMS.function`.

        - :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams` is an array of pointers
          to kernel parameters. If :py:obj:`~.CUDA_LAUNCH_PARAMS.function` has
          N parameters, then :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams` needs
          to be an array of N pointers. Each of
          :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams`[0] through
          :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams`[N-1] must point to a
          region of memory from which the actual kernel parameter will be
          copied. The number of kernel parameters and their offsets and sizes
          do not need to be specified as that information is retrieved directly
          from the kernel's image.

        By default, the kernel won't begin execution on any GPU until all prior
        work in all the specified streams has completed. This behavior can be
        overridden by specifying the flag
        :py:obj:`~.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC`.
        When this flag is specified, each kernel will only wait for prior work
        in the stream corresponding to that GPU to complete before it begins
        execution.

        Similarly, by default, any subsequent work pushed in any of the
        specified streams will not begin execution until the kernels on all
        GPUs have completed. This behavior can be overridden by specifying the
        flag
        :py:obj:`~.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC`.
        When this flag is specified, any subsequent work pushed in any of the
        specified streams will only wait for the kernel launched on the GPU
        corresponding to that stream to complete before it begins execution.

        Calling :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()` sets
        persistent function state that is the same as function state set
        through :py:obj:`~.cuLaunchKernel` API when called individually for
        each element in `launchParamsList`.

        When kernels are launched via
        :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()`, the previous block
        shape, shared size and parameter info associated with each
        :py:obj:`~.CUDA_LAUNCH_PARAMS.function` in `launchParamsList` is
        overwritten.

        Note that to use :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()`,
        the kernels must either have been compiled with toolchain version 3.2
        or later so that it will contain kernel parameter information, or have
        no kernel parameters. If either of these conditions is not met, then
        :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()` will return
        :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`.

        Parameters
        ----------
        launchParamsList : List[:py:obj:`~.CUDA_LAUNCH_PARAMS`]
            List of launch parameters, one per device
        numDevices : unsigned int
            Size of the `launchParamsList` array
        flags : unsigned int
            Flags to control launch behavior

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

        See Also
        --------
        :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchCooperativeKernel`, :py:obj:`~.cudaLaunchCooperativeKernelMultiDevice`
    """


def cuLaunchGrid(f, grid_width, grid_height):
    """
    cuLaunchGrid(f, int grid_width, int grid_height)
     Launches a CUDA function.

        [Deprecated]

        Invokes the kernel `f` on a `grid_width` x `grid_height` grid of
        blocks. Each block contains the number of threads specified by a
        previous call to :py:obj:`~.cuFuncSetBlockShape()`.

        The block shape, dynamic shared memory size, and parameter information
        must be set using :py:obj:`~.cuFuncSetBlockShape()`,
        :py:obj:`~.cuFuncSetSharedSize()`, :py:obj:`~.cuParamSetSize()`,
        :py:obj:`~.cuParamSeti()`, :py:obj:`~.cuParamSetf()`, and
        :py:obj:`~.cuParamSetv()` prior to calling this function.

        Launching a function via :py:obj:`~.cuLaunchKernel()` invalidates the
        function's block shape, dynamic shared memory size, and parameter
        information. After launching via cuLaunchKernel, this state must be re-
        initialized prior to calling this function. Failure to do so results in
        undefined behavior.

        Parameters
        ----------
        f : :py:obj:`~.CUfunction`
            Kernel to launch
        grid_width : int
            Width of grid in blocks
        grid_height : int
            Height of grid in blocks

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

        See Also
        --------
        :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """


def cuLaunchGridAsync(f, grid_width, grid_height, hStream):
    """
    cuLaunchGridAsync(f, int grid_width, int grid_height, hStream)
     Launches a CUDA function.

        [Deprecated]

        Invokes the kernel `f` on a `grid_width` x `grid_height` grid of
        blocks. Each block contains the number of threads specified by a
        previous call to :py:obj:`~.cuFuncSetBlockShape()`.

        The block shape, dynamic shared memory size, and parameter information
        must be set using :py:obj:`~.cuFuncSetBlockShape()`,
        :py:obj:`~.cuFuncSetSharedSize()`, :py:obj:`~.cuParamSetSize()`,
        :py:obj:`~.cuParamSeti()`, :py:obj:`~.cuParamSetf()`, and
        :py:obj:`~.cuParamSetv()` prior to calling this function.

        Launching a function via :py:obj:`~.cuLaunchKernel()` invalidates the
        function's block shape, dynamic shared memory size, and parameter
        information. After launching via cuLaunchKernel, this state must be re-
        initialized prior to calling this function. Failure to do so results in
        undefined behavior.

    
    ote_null_stream

        Parameters
        ----------
        f : :py:obj:`~.CUfunction`
            Kernel to launch
        grid_width : int
            Width of grid in blocks
        grid_height : int
            Height of grid in blocks
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

        See Also
        --------
        :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchKernel`

        Notes
        -----
        In certain cases where cubins are created with no ABI (i.e., using `ptxas` `None` `no`), this function may serialize kernel launches. The CUDA driver retains asynchronous behavior by growing the per-thread stack as needed per launch and not shrinking it afterwards.
    """


def cuLaunchHostFunc(hStream, fn, userData):
    """
    cuLaunchHostFunc(hStream, fn, userData)
     Enqueues a host function call in a stream.

        Enqueues a host function to run in a stream. The function will be
        called after currently enqueued work and will block work added after
        it.

        The host function must not make any CUDA API calls. Attempting to use a
        CUDA API may result in :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, but this
        is not required. The host function must not perform any synchronization
        that may depend on outstanding CUDA work not mandated to run earlier.
        Host functions without a mandated order (such as in independent
        streams) execute in undefined order and may be serialized.

        For the purposes of Unified Memory, execution makes a number of
        guarantees:

        - The stream is considered idle for the duration of the function's
          execution. Thus, for example, the function may always use memory
          attached to the stream it was enqueued in.

        - The start of execution of the function has the same effect as
          synchronizing an event recorded in the same stream immediately prior
          to the function. It thus synchronizes streams which have been
          "joined" prior to the function.

        - Adding device work to any stream does not have the effect of making
          the stream active until all preceding host functions and stream
          callbacks have executed. Thus, for example, a function might use
          global attached memory even if work has been added to another stream,
          if the work has been ordered behind the function call with an event.

        - Completion of the function does not cause a stream to become active
          except as described above. The stream will remain idle if no device
          work follows the function, and will remain idle across consecutive
          host functions or stream callbacks without device work in between.
          Thus, for example, stream synchronization can be done by signaling
          from a host function at the end of the stream.

        Note that, in contrast to :py:obj:`~.cuStreamAddCallback`, the function
        will not be called in the event of an error in the CUDA context.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to enqueue function call in
        fn : :py:obj:`~.CUhostFn`
            The function to call once preceding stream operations are complete
        userData : Any
            User-specified data to be passed to the function

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cuStreamAttachMemAsync`, :py:obj:`~.cuStreamAddCallback`
    """


def cuLaunchKernel(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, hStream, kernelParams, extra):
    """
    cuLaunchKernel(f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hStream, kernelParams, void_ptr extra)
     Launches a CUDA function :py:obj:`~.CUfunction` or a CUDA kernel :py:obj:`~.CUkernel`.

        Invokes the function :py:obj:`~.CUfunction` or the kernel
        :py:obj:`~.CUkernel` `f` on a `gridDimX` x `gridDimY` x `gridDimZ` grid
        of blocks. Each block contains `blockDimX` x `blockDimY` x `blockDimZ`
        threads.

        `sharedMemBytes` sets the amount of dynamic shared memory that will be
        available to each thread block.

        Kernel parameters to `f` can be specified in one of two ways:

        1) Kernel parameters can be specified via `kernelParams`. If `f` has N
        parameters, then `kernelParams` needs to be an array of N pointers.
        Each of `kernelParams`[0] through `kernelParams`[N-1] must point to a
        region of memory from which the actual kernel parameter will be copied.
        The number of kernel parameters and their offsets and sizes do not need
        to be specified as that information is retrieved directly from the
        kernel's image.

        2) Kernel parameters can also be packaged by the application into a
        single buffer that is passed in via the `extra` parameter. This places
        the burden on the application of knowing each kernel parameter's size
        and alignment/padding within the buffer. Here is an example of using
        the `extra` parameter in this manner:

        **View CUDA Toolkit Documentation for a C++ code example**

        The `extra` parameter exists to allow :py:obj:`~.cuLaunchKernel` to
        take additional less commonly used arguments. `extra` specifies a list
        of names of extra settings and their corresponding values. Each extra
        setting name is immediately followed by the corresponding value. The
        list must be terminated with either NULL or
        :py:obj:`~.CU_LAUNCH_PARAM_END`.

        - :py:obj:`~.CU_LAUNCH_PARAM_END`, which indicates the end of the
          `extra` array;

        - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`, which specifies that the
          next value in `extra` will be a pointer to a buffer containing all
          the kernel parameters for launching kernel `f`;

        - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_SIZE`, which specifies that the
          next value in `extra` will be a pointer to a size_t containing the
          size of the buffer specified with
          :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`;

        The error :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned if
        kernel parameters are specified with both `kernelParams` and `extra`
        (i.e. both `kernelParams` and `extra` are non-NULL).

        Calling :py:obj:`~.cuLaunchKernel()` invalidates the persistent
        function state set through the following deprecated APIs:
        :py:obj:`~.cuFuncSetBlockShape()`, :py:obj:`~.cuFuncSetSharedSize()`,
        :py:obj:`~.cuParamSetSize()`, :py:obj:`~.cuParamSeti()`,
        :py:obj:`~.cuParamSetf()`, :py:obj:`~.cuParamSetv()`.

        Note that to use :py:obj:`~.cuLaunchKernel()`, the kernel `f` must
        either have been compiled with toolchain version 3.2 or later so that
        it will contain kernel parameter information, or have no kernel
        parameters. If either of these conditions is not met, then
        :py:obj:`~.cuLaunchKernel()` will return
        :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`.

        Note that the API can also be used to launch context-less kernel
        :py:obj:`~.CUkernel` by querying the handle using
        :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
        casting to :py:obj:`~.CUfunction`. Here, the context to launch the
        kernel on will either be taken from the specified stream `hStream` or
        the current context in case of NULL stream.

        Parameters
        ----------
        f : :py:obj:`~.CUfunction`
            Function :py:obj:`~.CUfunction` or Kernel :py:obj:`~.CUkernel` to
            launch
        gridDimX : unsigned int
            Width of grid in blocks
        gridDimY : unsigned int
            Height of grid in blocks
        gridDimZ : unsigned int
            Depth of grid in blocks
        blockDimX : unsigned int
            X dimension of each thread block
        blockDimY : unsigned int
            Y dimension of each thread block
        blockDimZ : unsigned int
            Z dimension of each thread block
        sharedMemBytes : unsigned int
            Dynamic shared-memory size per thread block in bytes
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier
        kernelParams : Any
            Array of pointers to kernel parameters
        extra : List[Any]
            Extra options

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`

        See Also
        --------
        :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cudaLaunchKernel`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuKernelSetCacheConfig`, :py:obj:`~.cuKernelGetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    """


def cuLaunchKernelEx(config: 'Optional[CUlaunchConfig]', f, kernelParams, extra):
    """
    cuLaunchKernelEx(CUlaunchConfig config: Optional[CUlaunchConfig], f, kernelParams, void_ptr extra)
     Launches a CUDA function :py:obj:`~.CUfunction` or a CUDA kernel :py:obj:`~.CUkernel` with launch-time configuration.

        Invokes the function :py:obj:`~.CUfunction` or the kernel
        :py:obj:`~.CUkernel` `f` with the specified launch-time configuration
        `config`.

        The :py:obj:`~.CUlaunchConfig` structure is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - :py:obj:`~.CUlaunchConfig.gridDimX` is the width of the grid in
          blocks.

        - :py:obj:`~.CUlaunchConfig.gridDimY` is the height of the grid in
          blocks.

        - :py:obj:`~.CUlaunchConfig.gridDimZ` is the depth of the grid in
          blocks.

        - :py:obj:`~.CUlaunchConfig.blockDimX` is the X dimension of each
          thread block.

        - :py:obj:`~.CUlaunchConfig.blockDimX` is the Y dimension of each
          thread block.

        - :py:obj:`~.CUlaunchConfig.blockDimZ` is the Z dimension of each
          thread block.

        - :py:obj:`~.CUlaunchConfig.sharedMemBytes` is the dynamic shared-
          memory size per thread block in bytes.

        - :py:obj:`~.CUlaunchConfig.hStream` is the handle to the stream to
          perform the launch in. The CUDA context associated with this stream
          must match that associated with function f.

        - :py:obj:`~.CUlaunchConfig.attrs` is an array of
          :py:obj:`~.CUlaunchConfig.numAttrs` continguous
          :py:obj:`~.CUlaunchAttribute` elements. The value of this pointer is
          not considered if :py:obj:`~.CUlaunchConfig.numAttrs` is zero.
          However, in that case, it is recommended to set the pointer to NULL.

        - :py:obj:`~.CUlaunchConfig.numAttrs` is the number of attributes
          populating the first :py:obj:`~.CUlaunchConfig.numAttrs` positions of
          the :py:obj:`~.CUlaunchConfig.attrs` array.

        Launch-time configuration is specified by adding entries to
        :py:obj:`~.CUlaunchConfig.attrs`. Each entry is an attribute ID and a
        corresponding attribute value.

        The :py:obj:`~.CUlaunchAttribute` structure is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - :py:obj:`~.CUlaunchAttribute.id` is a unique enum identifying the
          attribute.

        - :py:obj:`~.CUlaunchAttribute.value` is a union that hold the
          attribute value.

        An example of using the `config` parameter:

        **View CUDA Toolkit Documentation for a C++ code example**

        The :py:obj:`~.CUlaunchAttributeID` enum is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        and the corresponding :py:obj:`~.CUlaunchAttributeValue` union as :

        **View CUDA Toolkit Documentation for a C++ code example**

        Setting :py:obj:`~.CU_LAUNCH_ATTRIBUTE_COOPERATIVE` to a non-zero value
        causes the kernel launch to be a cooperative launch, with exactly the
        same usage and semantics of :py:obj:`~.cuLaunchCooperativeKernel`.

        Setting
        :py:obj:`~.CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION` to a
        non-zero values causes the kernel to use programmatic means to resolve
        its stream dependency -- enabling the CUDA runtime to opportunistically
        allow the grid's execution to overlap with the previous kernel in the
        stream, if that kernel requests the overlap.

        :py:obj:`~.CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT` records an event
        along with the kernel launch. Event recorded through this launch
        attribute is guaranteed to only trigger after all block in the
        associated kernel trigger the event. A block can trigger the event
        through PTX launchdep.release or CUDA builtin function
        cudaTriggerProgrammaticLaunchCompletion(). A trigger can also be
        inserted at the beginning of each block's execution if
        triggerAtBlockStart is set to non-0. Note that dependents (including
        the CPU thread calling :py:obj:`~.cuEventSynchronize()`) are not
        guaranteed to observe the release precisely when it is released. For
        example, :py:obj:`~.cuEventSynchronize()` may only observe the event
        trigger long after the associated kernel has completed. This recording
        type is primarily meant for establishing programmatic dependency
        between device tasks. The event supplied must not be an interprocess or
        interop event. The event must disable timing (i.e. created with
        :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag set).

        :py:obj:`~.CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT` records an
        event along with the kernel launch. Nominally, the event is triggered
        once all blocks of the kernel have begun execution. Currently this is a
        best effort. If a kernel B has a launch completion dependency on a
        kernel A, B may wait until A is complete. Alternatively, blocks of B
        may begin before all blocks of A have begun, for example:

        - If B can claim execution resources unavaiable to A, for example if
          they run on different GPUs.

        - If B is a higher priority than A.

        Exercise caution if such an ordering inversion could lead to deadlock.
        The event supplied must not be an interprocess or interop event. The
        event must disable timing (i.e. must be created with the
        :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag set).

        Setting :py:obj:`~.CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE` to
        1 on a captured launch causes the resulting kernel node to be device-
        updatable. This attribute is specific to graphs, and passing it to a
        launch in a non-capturing stream results in an error. Passing a value
        other than 0 or 1 is not allowed.

        On success, a handle will be returned via
        :py:obj:`~.CUlaunchAttributeValue`::deviceUpdatableKernelNode::devNode
        which can be passed to the various device-side update functions to
        update the node's kernel parameters from within another kernel. For
        more information on the types of device updates that can be made, as
        well as the relevant limitations thereof, see
        :py:obj:`~.cudaGraphKernelNodeUpdatesApply`.

        Kernel nodes which are device-updatable have additional restrictions
        compared to regular kernel nodes. Firstly, device-updatable nodes
        cannot be removed from their graph via :py:obj:`~.cuGraphDestroyNode`.
        Additionally, once opted-in to this functionality, a node cannot opt
        out, and any attempt to set the attribute to 0 will result in an error.
        Graphs containing one or more device-updatable node also do not allow
        multiple instantiation.

        :py:obj:`~.CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION` allows the
        kernel launch to specify a preferred substitute cluster dimension.
        Blocks may be grouped according to either the dimensions specified with
        this attribute (grouped into a "preferred substitute cluster"), or the
        one specified with :py:obj:`~.CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION`
        attribute (grouped into a "regular cluster"). The cluster dimensions of
        a "preferred substitute cluster" shall be an integer multiple greater
        than zero of the regular cluster dimensions. The device will attempt -
        on a best-effort basis - to group thread blocks into preferred clusters
        over grouping them into regular clusters. When it deems necessary
        (primarily when the device temporarily runs out of physical resources
        to launch the larger preferred clusters), the device may switch to
        launch the regular clusters instead to attempt to utilize as much of
        the physical device resources as possible.

        Each type of cluster will have its enumeration / coordinate setup as if
        the grid consists solely of its type of cluster. For example, if the
        preferred substitute cluster dimensions double the regular cluster
        dimensions, there might be simultaneously a regular cluster indexed at
        (1,0,0), and a preferred cluster indexed at (1,0,0). In this example,
        the preferred substitute cluster (1,0,0) replaces regular clusters
        (2,0,0) and (3,0,0) and groups their blocks.

        This attribute will only take effect when a regular cluster dimension
        has been specified. The preferred substitute The preferred substitute
        cluster dimension must be an integer multiple greater than zero of the
        regular cluster dimension and must divide the grid. It must also be no
        more than `maxBlocksPerCluster`, if it is set in the kernel's
        `__launch_bounds__`. Otherwise it must be less than the maximum value
        the driver can support. Otherwise, setting this attribute to a value
        physically unable to fit on any particular device is permitted.

        The effect of other attributes is consistent with their effect when set
        via persistent APIs.

        See :py:obj:`~.cuStreamSetAttribute` for

        - :py:obj:`~.CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW`

        - :py:obj:`~.CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY`

        See :py:obj:`~.cuFuncSetAttribute` for

        - :py:obj:`~.CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION`

        - :py:obj:`~.CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE`

        Kernel parameters to `f` can be specified in the same ways that they
        can be using :py:obj:`~.cuLaunchKernel`.

        Note that the API can also be used to launch context-less kernel
        :py:obj:`~.CUkernel` by querying the handle using
        :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
        casting to :py:obj:`~.CUfunction`. Here, the context to launch the
        kernel on will either be taken from the specified stream
        :py:obj:`~.CUlaunchConfig.hStream` or the current context in case of
        NULL stream.

        Parameters
        ----------
        config : :py:obj:`~.CUlaunchConfig`
            Config to launch
        f : :py:obj:`~.CUfunction`
            Function :py:obj:`~.CUfunction` or Kernel :py:obj:`~.CUkernel` to
            launch
        kernelParams : Any
            Array of pointers to kernel parameters
        extra : List[Any]
            Extra options

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`

        See Also
        --------
        :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cudaLaunchKernel`, :py:obj:`~.cudaLaunchKernelEx`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuKernelSetCacheConfig`, :py:obj:`~.cuKernelGetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    """


def cuLibraryEnumerateKernels(numKernels, lib):
    """
    cuLibraryEnumerateKernels(unsigned int numKernels, lib)
     Retrieve the kernel handles within a library.

        Returns in `kernels` a maximum number of `numKernels` kernel handles
        within `lib`. The returned kernel handle becomes invalid when the
        library is unloaded.

        Parameters
        ----------
        numKernels : unsigned int
            Maximum number of kernel handles may be returned to the buffer
        lib : :py:obj:`~.CUlibrary`
            Library to query from

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        kernels : List[:py:obj:`~.CUkernel`]
            Buffer where the kernel handles are returned to

        See Also
        --------
        :py:obj:`~.cuLibraryGetKernelCount`
    """


def cuLibraryGetGlobal(library, name):
    """
    cuLibraryGetGlobal(library, char *name)
     Returns a global device pointer.

        Returns in `*dptr` and `*bytes` the base pointer and size of the global
        with name `name` for the requested library `library` and the current
        context. If no global for the requested name `name` exists, the call
        returns :py:obj:`~.CUDA_ERROR_NOT_FOUND`. One of the parameters `dptr`
        or `numbytes` (not both) can be NULL in which case it is ignored.

        Parameters
        ----------
        library : :py:obj:`~.CUlibrary`
            Library to retrieve global from
        name : bytes
            Name of global to retrieve

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`
        dptr : :py:obj:`~.CUdeviceptr`
            Returned global device pointer for the requested context
        numbytes : int
            Returned global size in bytes

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetGlobal`
    """


def cuLibraryGetKernel(library, name):
    """
    cuLibraryGetKernel(library, char *name)
     Returns a kernel handle.

        Returns in `pKernel` the handle of the kernel with name `name` located
        in library `library`. If kernel handle is not found, the call returns
        :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

        Parameters
        ----------
        library : :py:obj:`~.CUlibrary`
            Library to retrieve kernel from
        name : bytes
            Name of kernel to retrieve

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
        pKernel : :py:obj:`~.CUkernel`
            Returned kernel handle

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuKernelGetFunction`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetFunction`
    """


def cuLibraryGetKernelCount(lib):
    """
    cuLibraryGetKernelCount(lib)
     Returns the number of kernels within a library.

        Returns in `count` the number of kernels in `lib`.

        Parameters
        ----------
        lib : :py:obj:`~.CUlibrary`
            Library to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        count : unsigned int
            Number of kernels found within the library
    """


def cuLibraryGetManaged(library, name):
    """
    cuLibraryGetManaged(library, char *name)
     Returns a pointer to managed memory.

        Returns in `*dptr` and `*bytes` the base pointer and size of the
        managed memory with name `name` for the requested library `library`. If
        no managed memory with the requested name `name` exists, the call
        returns :py:obj:`~.CUDA_ERROR_NOT_FOUND`. One of the parameters `dptr`
        or `numbytes` (not both) can be NULL in which case it is ignored. Note
        that managed memory for library `library` is shared across devices and
        is registered when the library is loaded into atleast one context.

        Parameters
        ----------
        library : :py:obj:`~.CUlibrary`
            Library to retrieve managed memory from
        name : bytes
            Name of managed memory to retrieve

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
        dptr : :py:obj:`~.CUdeviceptr`
            Returned pointer to the managed memory
        numbytes : int
            Returned memory size in bytes

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`
    """


def cuLibraryGetModule(library):
    """
    cuLibraryGetModule(library)
     Returns a module handle.

        Returns in `pMod` the module handle associated with the current context
        located in library `library`. If module handle is not found, the call
        returns :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

        Parameters
        ----------
        library : :py:obj:`~.CUlibrary`
            Library to retrieve module from

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`
        pMod : :py:obj:`~.CUmodule`
            Returned module handle

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuModuleGetFunction`
    """


def cuLibraryGetUnifiedFunction(library, symbol):
    """
    cuLibraryGetUnifiedFunction(library, char *symbol)
     Returns a pointer to a unified function.

        Returns in `*fptr` the function pointer to a unified function denoted
        by `symbol`. If no unified function with name `symbol` exists, the call
        returns :py:obj:`~.CUDA_ERROR_NOT_FOUND`. If there is no device with
        attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS`
        present in the system, the call may return
        :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

        Parameters
        ----------
        library : :py:obj:`~.CUlibrary`
            Library to retrieve function pointer memory from
        symbol : bytes
            Name of function pointer to retrieve

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
        fptr : Any
            Returned pointer to a unified function

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`
    """


def cuLibraryLoadData(code, jitOptions: 'Optional[Tuple[CUjit_option] | List[CUjit_option]]', jitOptionsValues: 'Optional[Tuple[Any] | List[Any]]', numJitOptions, libraryOptions: 'Optional[Tuple[CUlibraryOption] | List[CUlibraryOption]]', libraryOptionValues: 'Optional[Tuple[Any] | List[Any]]', numLibraryOptions):
    """
    cuLibraryLoadData(code, jitOptions: Optional[Tuple[CUjit_option] | List[CUjit_option]], jitOptionsValues: Optional[Tuple[Any] | List[Any]], unsigned int numJitOptions, libraryOptions: Optional[Tuple[CUlibraryOption] | List[CUlibraryOption]], libraryOptionValues: Optional[Tuple[Any] | List[Any]], unsigned int numLibraryOptions)
     Load a library with specified code and options.

        Takes a pointer `code` and loads the corresponding library `library`
        based on the application defined library loading mode:

        - If module loading is set to EAGER, via the environment variables
          described in "Module loading", `library` is loaded eagerly into all
          contexts at the time of the call and future contexts at the time of
          creation until the library is unloaded with
          :py:obj:`~.cuLibraryUnload()`.

        - If the environment variables are set to LAZY, `library` is not
          immediately loaded onto all existent contexts and will only be loaded
          when a function is needed for that context, such as a kernel launch.

        These environment variables are described in the CUDA programming guide
        under the "CUDA environment variables" section.

        The `code` may be a `cubin` or `fatbin` as output by nvcc, or a NULL-
        terminated `PTX`, either as output by nvcc or hand-written. A fatbin
        should also contain relocatable code when doing separate compilation.

        Options are passed as an array via `jitOptions` and any corresponding
        parameters are passed in `jitOptionsValues`. The number of total JIT
        options is supplied via `numJitOptions`. Any outputs will be returned
        via `jitOptionsValues`.

        Library load options are passed as an array via `libraryOptions` and
        any corresponding parameters are passed in `libraryOptionValues`. The
        number of total library load options is supplied via
        `numLibraryOptions`.

        Parameters
        ----------
        code : Any
            Code to load
        jitOptions : List[:py:obj:`~.CUjit_option`]
            Options for JIT
        jitOptionsValues : List[Any]
            Option values for JIT
        numJitOptions : unsigned int
            Number of options
        libraryOptions : List[:py:obj:`~.CUlibraryOption`]
            Options for loading
        libraryOptionValues : List[Any]
            Option values for loading
        numLibraryOptions : unsigned int
            Number of options for loading

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        library : :py:obj:`~.CUlibrary`
            Returned library

        See Also
        --------
        :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`

        Notes
        -----
        If the library contains managed variables and no device in the system supports managed variables this call is expected to return :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    """


def cuLibraryLoadFromFile(fileName, jitOptions: 'Optional[Tuple[CUjit_option] | List[CUjit_option]]', jitOptionsValues: 'Optional[Tuple[Any] | List[Any]]', numJitOptions, libraryOptions: 'Optional[Tuple[CUlibraryOption] | List[CUlibraryOption]]', libraryOptionValues: 'Optional[Tuple[Any] | List[Any]]', numLibraryOptions):
    """
    cuLibraryLoadFromFile(char *fileName, jitOptions: Optional[Tuple[CUjit_option] | List[CUjit_option]], jitOptionsValues: Optional[Tuple[Any] | List[Any]], unsigned int numJitOptions, libraryOptions: Optional[Tuple[CUlibraryOption] | List[CUlibraryOption]], libraryOptionValues: Optional[Tuple[Any] | List[Any]], unsigned int numLibraryOptions)
     Load a library with specified file and options.

        Takes a pointer `code` and loads the corresponding library `library`
        based on the application defined library loading mode:

        - If module loading is set to EAGER, via the environment variables
          described in "Module loading", `library` is loaded eagerly into all
          contexts at the time of the call and future contexts at the time of
          creation until the library is unloaded with
          :py:obj:`~.cuLibraryUnload()`.

        - If the environment variables are set to LAZY, `library` is not
          immediately loaded onto all existent contexts and will only be loaded
          when a function is needed for that context, such as a kernel launch.

        These environment variables are described in the CUDA programming guide
        under the "CUDA environment variables" section.

        The file should be a `cubin` file as output by nvcc, or a `PTX` file
        either as output by nvcc or handwritten, or a `fatbin` file as output
        by nvcc. A fatbin should also contain relocatable code when doing
        separate compilation.

        Options are passed as an array via `jitOptions` and any corresponding
        parameters are passed in `jitOptionsValues`. The number of total
        options is supplied via `numJitOptions`. Any outputs will be returned
        via `jitOptionsValues`.

        Library load options are passed as an array via `libraryOptions` and
        any corresponding parameters are passed in `libraryOptionValues`. The
        number of total library load options is supplied via
        `numLibraryOptions`.

        Parameters
        ----------
        fileName : bytes
            File to load from
        jitOptions : List[:py:obj:`~.CUjit_option`]
            Options for JIT
        jitOptionsValues : List[Any]
            Option values for JIT
        numJitOptions : unsigned int
            Number of options
        libraryOptions : List[:py:obj:`~.CUlibraryOption`]
            Options for loading
        libraryOptionValues : List[Any]
            Option values for loading
        numLibraryOptions : unsigned int
            Number of options for loading

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        library : :py:obj:`~.CUlibrary`
            Returned library

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`

        Notes
        -----
        If the library contains managed variables and no device in the system supports managed variables this call is expected to return :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    """


def cuLibraryUnload(library):
    """
    cuLibraryUnload(library)
     Unloads a library.

        Unloads the library specified with `library`

        Parameters
        ----------
        library : :py:obj:`~.CUlibrary`
            Library to unload

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuModuleUnload`
    """


def cuLinkAddData(state, typename: 'CUjitInputType', data, size, name, numOptions, options: 'Optional[Tuple[CUjit_option] | List[CUjit_option]]', optionValues: 'Optional[Tuple[Any] | List[Any]]'):
    """
    cuLinkAddData(state, typename: CUjitInputType, data, size_t size, char *name, unsigned int numOptions, options: Optional[Tuple[CUjit_option] | List[CUjit_option]], optionValues: Optional[Tuple[Any] | List[Any]])
     Add an input to a pending linker invocation.

        Ownership of `data` is retained by the caller. No reference is retained
        to any inputs after this call returns.

        This method accepts only compiler options, which are used if the data
        must be compiled from PTX, and does not accept any of
        :py:obj:`~.CU_JIT_WALL_TIME`, :py:obj:`~.CU_JIT_INFO_LOG_BUFFER`,
        :py:obj:`~.CU_JIT_ERROR_LOG_BUFFER`,
        :py:obj:`~.CU_JIT_TARGET_FROM_CUCONTEXT`, or :py:obj:`~.CU_JIT_TARGET`.

        Parameters
        ----------
        state : :py:obj:`~.CUlinkState`
            A pending linker action.
        typename : :py:obj:`~.CUjitInputType`
            The type of the input data.
        data : Any
            The input data. PTX must be NULL-terminated.
        size : size_t
            The length of the input data.
        name : bytes
            An optional name for this input in log messages.
        numOptions : unsigned int
            Size of options.
        options : List[:py:obj:`~.CUjit_option`]
            Options to be applied only for this input (overrides options from
            :py:obj:`~.cuLinkCreate`).
        optionValues : List[Any]
            Array of option values, each cast to void *.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`

        See Also
        --------
        :py:obj:`~.cuLinkCreate`, :py:obj:`~.cuLinkAddFile`, :py:obj:`~.cuLinkComplete`, :py:obj:`~.cuLinkDestroy`

        Notes
        -----
        For LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted
    """


def cuLinkAddFile(state, typename: 'CUjitInputType', path, numOptions, options: 'Optional[Tuple[CUjit_option] | List[CUjit_option]]', optionValues: 'Optional[Tuple[Any] | List[Any]]'):
    """
    cuLinkAddFile(state, typename: CUjitInputType, char *path, unsigned int numOptions, options: Optional[Tuple[CUjit_option] | List[CUjit_option]], optionValues: Optional[Tuple[Any] | List[Any]])
     Add a file input to a pending linker invocation.

        No reference is retained to any inputs after this call returns.

        This method accepts only compiler options, which are used if the input
        must be compiled from PTX, and does not accept any of
        :py:obj:`~.CU_JIT_WALL_TIME`, :py:obj:`~.CU_JIT_INFO_LOG_BUFFER`,
        :py:obj:`~.CU_JIT_ERROR_LOG_BUFFER`,
        :py:obj:`~.CU_JIT_TARGET_FROM_CUCONTEXT`, or :py:obj:`~.CU_JIT_TARGET`.

        This method is equivalent to invoking :py:obj:`~.cuLinkAddData` on the
        contents of the file.

        Parameters
        ----------
        state : :py:obj:`~.CUlinkState`
            A pending linker action
        typename : :py:obj:`~.CUjitInputType`
            The type of the input data
        path : bytes
            Path to the input file
        numOptions : unsigned int
            Size of options
        options : List[:py:obj:`~.CUjit_option`]
            Options to be applied only for this input (overrides options from
            :py:obj:`~.cuLinkCreate`)
        optionValues : List[Any]
            Array of option values, each cast to void *

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_FILE_NOT_FOUND` :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`

        See Also
        --------
        :py:obj:`~.cuLinkCreate`, :py:obj:`~.cuLinkAddData`, :py:obj:`~.cuLinkComplete`, :py:obj:`~.cuLinkDestroy`

        Notes
        -----
        For LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted
    """


def cuLinkComplete(state):
    """
    cuLinkComplete(state)
     Complete a pending linker invocation.

        Completes the pending linker action and returns the cubin image for the
        linked device code, which can be used with
        :py:obj:`~.cuModuleLoadData`. The cubin is owned by `state`, so it
        should be loaded before `state` is destroyed via
        :py:obj:`~.cuLinkDestroy`. This call does not destroy `state`.

        Parameters
        ----------
        state : :py:obj:`~.CUlinkState`
            A pending linker invocation

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        cubinOut : Any
            On success, this will point to the output image
        sizeOut : int
            Optional parameter to receive the size of the generated image

        See Also
        --------
        :py:obj:`~.cuLinkCreate`, :py:obj:`~.cuLinkAddData`, :py:obj:`~.cuLinkAddFile`, :py:obj:`~.cuLinkDestroy`, :py:obj:`~.cuModuleLoadData`
    """


def cuLinkCreate(numOptions, options: 'Optional[Tuple[CUjit_option] | List[CUjit_option]]', optionValues: 'Optional[Tuple[Any] | List[Any]]'):
    """
    cuLinkCreate(unsigned int numOptions, options: Optional[Tuple[CUjit_option] | List[CUjit_option]], optionValues: Optional[Tuple[Any] | List[Any]])
     Creates a pending JIT linker invocation.

        If the call is successful, the caller owns the returned CUlinkState,
        which should eventually be destroyed with :py:obj:`~.cuLinkDestroy`.
        The device code machine size (32 or 64 bit) will match the calling
        application.

        Both linker and compiler options may be specified. Compiler options
        will be applied to inputs to this linker action which must be compiled
        from PTX. The options :py:obj:`~.CU_JIT_WALL_TIME`,
        :py:obj:`~.CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES`, and
        :py:obj:`~.CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES` will accumulate data
        until the CUlinkState is destroyed.

        The data passed in via :py:obj:`~.cuLinkAddData` and
        :py:obj:`~.cuLinkAddFile` will be treated as relocatable (-rdc=true to
        nvcc) when linking the final cubin during :py:obj:`~.cuLinkComplete`
        and will have similar consequences as offline relocatable device code
        linking.

        `optionValues` must remain valid for the life of the CUlinkState if
        output options are used. No other references to inputs are maintained
        after this call returns.

        Parameters
        ----------
        numOptions : unsigned int
            Size of options arrays
        options : List[:py:obj:`~.CUjit_option`]
            Array of linker and compiler options
        optionValues : List[Any]
            Array of option values, each cast to void *

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
        stateOut : :py:obj:`~.CUlinkState`
            On success, this will contain a CUlinkState to specify and complete
            this action

        See Also
        --------
        :py:obj:`~.cuLinkAddData`, :py:obj:`~.cuLinkAddFile`, :py:obj:`~.cuLinkComplete`, :py:obj:`~.cuLinkDestroy`

        Notes
        -----
        For LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted
    """


def cuLinkDestroy(state):
    """
    cuLinkDestroy(state)
     Destroys state for a JIT linker invocation.

        Parameters
        ----------
        state : :py:obj:`~.CUlinkState`
            State object for the linker invocation

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuLinkCreate`
    """


def cuMemAddressFree(ptr, size):
    """
    cuMemAddressFree(ptr, size_t size)
     Free an address range reservation.

        Frees a virtual address range reserved by cuMemAddressReserve. The size
        must match what was given to memAddressReserve and the ptr given must
        match what was returned from memAddressReserve.

        Parameters
        ----------
        ptr : :py:obj:`~.CUdeviceptr`
            Starting address of the virtual address range to free
        size : size_t
            Size of the virtual address region to free

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuMemAddressReserve`
    """


def cuMemAddressReserve(size, alignment, addr, flags):
    """
    cuMemAddressReserve(size_t size, size_t alignment, addr, unsigned long long flags)
     Allocate an address range reservation.

        Reserves a virtual address range based on the given parameters, giving
        the starting address of the range in `ptr`. This API requires a system
        that supports UVA. The size and address parameters must be a multiple
        of the host page size and the alignment must be a power of two or zero
        for default alignment.

        Parameters
        ----------
        size : size_t
            Size of the reserved virtual address range requested
        alignment : size_t
            Alignment of the reserved virtual address range requested
        addr : :py:obj:`~.CUdeviceptr`
            Fixed starting address range requested
        flags : unsigned long long
            Currently unused, must be zero

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        ptr : :py:obj:`~.CUdeviceptr`
            Resulting pointer to start of virtual address range allocated

        See Also
        --------
        :py:obj:`~.cuMemAddressFree`
    """


def cuMemAdvise(devPtr, count, advice: 'CUmem_advise', device):
    """
    cuMemAdvise(devPtr, size_t count, advice: CUmem_advise, device)
     Advise about the usage of a given memory range.

        Note there is a later version of this API, :py:obj:`~.cuMemAdvise_v2`.
        It will supplant this version in 13.0, which is retained for minor
        version compatibility.

        Advise the Unified Memory subsystem about the usage pattern for the
        memory range starting at `devPtr` with a size of `count` bytes. The
        start address and end address of the memory range will be rounded down
        and rounded up respectively to be aligned to CPU page size before the
        advice is applied. The memory range must refer to managed memory
        allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
        variables. The memory range could also refer to system-allocated
        pageable memory provided it represents a valid, host-accessible region
        of memory and all additional constraints imposed by `advice` as
        outlined below are also satisfied. Specifying an invalid system-
        allocated pageable memory range results in an error being returned.

        The `advice` parameter can take the following values:

        - :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY`: This implies that the data
          is mostly going to be read from and only occasionally written to. Any
          read accesses from any processor to this region will create a read-
          only copy of at least the accessed pages in that processor's memory.
          Additionally, if :py:obj:`~.cuMemPrefetchAsync` is called on this
          region, it will create a read-only copy of the data on the
          destination processor. If any processor writes to this region, all
          copies of the corresponding page will be invalidated except for the
          one where the write occurred. The `device` argument is ignored for
          this advice. Note that for a page to be read-duplicated, the
          accessing processor must either be the CPU or a GPU that has a non-
          zero value for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Also, if a
          context is created on a device that does not have the device
          attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`
          set, then read-duplication will not occur until all such contexts are
          destroyed. If the memory region refers to valid system-allocated
          pageable memory, then the accessing device must have a non-zero value
          for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS` for a read-
          only copy to be created on that device. Note however that if the
          accessing device also has a non-zero value for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
          then setting this advice will not create a read-only copy when that
          device accesses this memory region.

        - :py:obj:`~.CU_MEM_ADVISE_UNSET_READ_MOSTLY`: Undoes the effect of
          :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` and also prevents the
          Unified Memory driver from attempting heuristic read-duplication on
          the memory range. Any read-duplicated copies of the data will be
          collapsed into a single copy. The location for the collapsed copy
          will be the preferred location if the page has a preferred location
          and one of the read-duplicated copies was resident at that location.
          Otherwise, the location chosen is arbitrary.

        - :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION`: This advice sets
          the preferred location for the data to be the memory belonging to
          `device`. Passing in CU_DEVICE_CPU for `device` sets the preferred
          location as host memory. If `device` is a GPU, then it must have a
          non-zero value for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Setting
          the preferred location does not cause data to migrate to that
          location immediately. Instead, it guides the migration policy when a
          fault occurs on that memory region. If the data is already in its
          preferred location and the faulting processor can establish a mapping
          without requiring the data to be migrated, then data migration will
          be avoided. On the other hand, if the data is not in its preferred
          location or if a direct mapping cannot be established, then it will
          be migrated to the processor accessing it. It is important to note
          that setting the preferred location does not prevent data prefetching
          done using :py:obj:`~.cuMemPrefetchAsync`. Having a preferred
          location can override the page thrash detection and resolution logic
          in the Unified Memory driver. Normally, if a page is detected to be
          constantly thrashing between for example host and device memory, the
          page may eventually be pinned to host memory by the Unified Memory
          driver. But if the preferred location is set as device memory, then
          the page will continue to thrash indefinitely. If
          :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` is also set on this memory
          region or any subset of it, then the policies associated with that
          advice will override the policies of this advice, unless read
          accesses from `device` will not result in a read-only copy being
          created on that device as outlined in description for the advice
          :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY`. If the memory region
          refers to valid system-allocated pageable memory, then `device` must
          have a non-zero value for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`.

        - :py:obj:`~.CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION`: Undoes the effect
          of :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` and changes the
          preferred location to none.

        - :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY`: This advice implies that
          the data will be accessed by `device`. Passing in
          :py:obj:`~.CU_DEVICE_CPU` for `device` will set the advice for the
          CPU. If `device` is a GPU, then the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` must be
          non-zero. This advice does not cause data migration and has no impact
          on the location of the data per se. Instead, it causes the data to
          always be mapped in the specified processor's page tables, as long as
          the location of the data permits a mapping to be established. If the
          data gets migrated for any reason, the mappings are updated
          accordingly. This advice is recommended in scenarios where data
          locality is not important, but avoiding faults is. Consider for
          example a system containing multiple GPUs with peer-to-peer access
          enabled, where the data located on one GPU is occasionally accessed
          by peer GPUs. In such scenarios, migrating data over to the other
          GPUs is not as important because the accesses are infrequent and the
          overhead of migration may be too high. But preventing faults can
          still help improve performance, and so having a mapping set up in
          advance is useful. Note that on CPU access of this data, the data may
          be migrated to host memory because the CPU typically cannot access
          device memory directly. Any GPU that had the
          :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` flag set for this data will
          now have its mapping updated to point to the page in host memory. If
          :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` is also set on this memory
          region or any subset of it, then the policies associated with that
          advice will override the policies of this advice. Additionally, if
          the preferred location of this memory region or any subset of it is
          also `device`, then the policies associated with
          :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` will override the
          policies of this advice. If the memory region refers to valid system-
          allocated pageable memory, then `device` must have a non-zero value
          for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`. Additionally,
          if `device` has a non-zero value for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
          then this call has no effect.

        - :py:obj:`~.CU_MEM_ADVISE_UNSET_ACCESSED_BY`: Undoes the effect of
          :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY`. Any mappings to the data
          from `device` may be removed at any time causing accesses to result
          in non-fatal page faults. If the memory region refers to valid
          system-allocated pageable memory, then `device` must have a non-zero
          value for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`. Additionally,
          if `device` has a non-zero value for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
          then this call has no effect.

        Parameters
        ----------
        devPtr : :py:obj:`~.CUdeviceptr`
            Pointer to memory to set the advice for
        count : size_t
            Size in bytes of the memory range
        advice : :py:obj:`~.CUmem_advise`
            Advice to be applied for the specified memory range
        device : :py:obj:`~.CUdevice`
            Device to apply the advice for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

        See Also
        --------
        :py:obj:`~.cuMemcpy`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cuMemPrefetchAsync`, :py:obj:`~.cuMemAdvise_v2` :py:obj:`~.cudaMemAdvise`
    """


def cuMemAdvise_v2(devPtr, count, advice: 'CUmem_advise', location: 'CUmemLocation'):
    """
    cuMemAdvise_v2(devPtr, size_t count, advice: CUmem_advise, CUmemLocation location: CUmemLocation)
     Advise about the usage of a given memory range.

        Advise the Unified Memory subsystem about the usage pattern for the
        memory range starting at `devPtr` with a size of `count` bytes. The
        start address and end address of the memory range will be rounded down
        and rounded up respectively to be aligned to CPU page size before the
        advice is applied. The memory range must refer to managed memory
        allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
        variables. The memory range could also refer to system-allocated
        pageable memory provided it represents a valid, host-accessible region
        of memory and all additional constraints imposed by `advice` as
        outlined below are also satisfied. Specifying an invalid system-
        allocated pageable memory range results in an error being returned.

        The `advice` parameter can take the following values:

        - :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY`: This implies that the data
          is mostly going to be read from and only occasionally written to. Any
          read accesses from any processor to this region will create a read-
          only copy of at least the accessed pages in that processor's memory.
          Additionally, if :py:obj:`~.cuMemPrefetchAsync` or
          :py:obj:`~.cuMemPrefetchAsync_v2` is called on this region, it will
          create a read-only copy of the data on the destination processor. If
          the target location for :py:obj:`~.cuMemPrefetchAsync_v2` is a host
          NUMA node and a read-only copy already exists on another host NUMA
          node, that copy will be migrated to the targeted host NUMA node. If
          any processor writes to this region, all copies of the corresponding
          page will be invalidated except for the one where the write occurred.
          If the writing processor is the CPU and the preferred location of the
          page is a host NUMA node, then the page will also be migrated to that
          host NUMA node. The `location` argument is ignored for this advice.
          Note that for a page to be read-duplicated, the accessing processor
          must either be the CPU or a GPU that has a non-zero value for the
          device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Also, if a
          context is created on a device that does not have the device
          attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`
          set, then read-duplication will not occur until all such contexts are
          destroyed. If the memory region refers to valid system-allocated
          pageable memory, then the accessing device must have a non-zero value
          for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS` for a read-
          only copy to be created on that device. Note however that if the
          accessing device also has a non-zero value for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
          then setting this advice will not create a read-only copy when that
          device accesses this memory region.

        - :py:obj:`~.CU_MEM_ADVISE_UNSET_READ_MOSTLY`: Undoes the effect of
          :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` and also prevents the
          Unified Memory driver from attempting heuristic read-duplication on
          the memory range. Any read-duplicated copies of the data will be
          collapsed into a single copy. The location for the collapsed copy
          will be the preferred location if the page has a preferred location
          and one of the read-duplicated copies was resident at that location.
          Otherwise, the location chosen is arbitrary. Note: The `location`
          argument is ignored for this advice.

        - :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION`: This advice sets
          the preferred location for the data to be the memory belonging to
          `location`. When :py:obj:`~.CUmemLocation.type` is
          :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST`, :py:obj:`~.CUmemLocation.id`
          is ignored and the preferred location is set to be host memory. To
          set the preferred location to a specific host NUMA node, applications
          must set :py:obj:`~.CUmemLocation.type` to
          :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` and
          :py:obj:`~.CUmemLocation.id` must specify the NUMA ID of the host
          NUMA node. If :py:obj:`~.CUmemLocation.type` is set to
          :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT`,
          :py:obj:`~.CUmemLocation.id` will be ignored and the the host NUMA
          node closest to the calling thread's CPU will be used as the
          preferred location. If :py:obj:`~.CUmemLocation.type` is a
          :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE`, then
          :py:obj:`~.CUmemLocation.id` must be a valid device ordinal and the
          device must have a non-zero value for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Setting
          the preferred location does not cause data to migrate to that
          location immediately. Instead, it guides the migration policy when a
          fault occurs on that memory region. If the data is already in its
          preferred location and the faulting processor can establish a mapping
          without requiring the data to be migrated, then data migration will
          be avoided. On the other hand, if the data is not in its preferred
          location or if a direct mapping cannot be established, then it will
          be migrated to the processor accessing it. It is important to note
          that setting the preferred location does not prevent data prefetching
          done using :py:obj:`~.cuMemPrefetchAsync`. Having a preferred
          location can override the page thrash detection and resolution logic
          in the Unified Memory driver. Normally, if a page is detected to be
          constantly thrashing between for example host and device memory, the
          page may eventually be pinned to host memory by the Unified Memory
          driver. But if the preferred location is set as device memory, then
          the page will continue to thrash indefinitely. If
          :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` is also set on this memory
          region or any subset of it, then the policies associated with that
          advice will override the policies of this advice, unless read
          accesses from `location` will not result in a read-only copy being
          created on that procesor as outlined in description for the advice
          :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY`. If the memory region
          refers to valid system-allocated pageable memory, and
          :py:obj:`~.CUmemLocation.type` is CU_MEM_LOCATION_TYPE_DEVICE then
          :py:obj:`~.CUmemLocation.id` must be a valid device that has a non-
          zero alue for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`.

        - :py:obj:`~.CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION`: Undoes the effect
          of :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` and changes the
          preferred location to none. The `location` argument is ignored for
          this advice.

        - :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY`: This advice implies that
          the data will be accessed by processor `location`. The
          :py:obj:`~.CUmemLocation.type` must be either
          :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` with
          :py:obj:`~.CUmemLocation.id` representing a valid device ordinal or
          :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` and
          :py:obj:`~.CUmemLocation.id` will be ignored. All other location
          types are invalid. If :py:obj:`~.CUmemLocation.id` is a GPU, then the
          device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` must be
          non-zero. This advice does not cause data migration and has no impact
          on the location of the data per se. Instead, it causes the data to
          always be mapped in the specified processor's page tables, as long as
          the location of the data permits a mapping to be established. If the
          data gets migrated for any reason, the mappings are updated
          accordingly. This advice is recommended in scenarios where data
          locality is not important, but avoiding faults is. Consider for
          example a system containing multiple GPUs with peer-to-peer access
          enabled, where the data located on one GPU is occasionally accessed
          by peer GPUs. In such scenarios, migrating data over to the other
          GPUs is not as important because the accesses are infrequent and the
          overhead of migration may be too high. But preventing faults can
          still help improve performance, and so having a mapping set up in
          advance is useful. Note that on CPU access of this data, the data may
          be migrated to host memory because the CPU typically cannot access
          device memory directly. Any GPU that had the
          :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` flag set for this data will
          now have its mapping updated to point to the page in host memory. If
          :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` is also set on this memory
          region or any subset of it, then the policies associated with that
          advice will override the policies of this advice. Additionally, if
          the preferred location of this memory region or any subset of it is
          also `location`, then the policies associated with
          :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` will override the
          policies of this advice. If the memory region refers to valid system-
          allocated pageable memory, and :py:obj:`~.CUmemLocation.type` is
          :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` then device in
          :py:obj:`~.CUmemLocation.id` must have a non-zero value for the
          device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`. Additionally,
          if :py:obj:`~.CUmemLocation.id` has a non-zero value for the device
          attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
          then this call has no effect.

        - :py:obj:`~.CU_MEM_ADVISE_UNSET_ACCESSED_BY`: Undoes the effect of
          :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY`. Any mappings to the data
          from `location` may be removed at any time causing accesses to result
          in non-fatal page faults. If the memory region refers to valid
          system-allocated pageable memory, and :py:obj:`~.CUmemLocation.type`
          is :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` then device in
          :py:obj:`~.CUmemLocation.id` must have a non-zero value for the
          device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`. Additionally,
          if :py:obj:`~.CUmemLocation.id` has a non-zero value for the device
          attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
          then this call has no effect.

        Parameters
        ----------
        devPtr : :py:obj:`~.CUdeviceptr`
            Pointer to memory to set the advice for
        count : size_t
            Size in bytes of the memory range
        advice : :py:obj:`~.CUmem_advise`
            Advice to be applied for the specified memory range
        location : :py:obj:`~.CUmemLocation`
            location to apply the advice for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

        See Also
        --------
        :py:obj:`~.cuMemcpy`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cuMemPrefetchAsync`, :py:obj:`~.cuMemAdvise` :py:obj:`~.cudaMemAdvise`
    """


def cuMemAlloc(bytesize):
    """
    cuMemAlloc(size_t bytesize)
     Allocates device memory.

        Allocates `bytesize` bytes of linear memory on the device and returns
        in `*dptr` a pointer to the allocated memory. The allocated memory is
        suitably aligned for any kind of variable. The memory is not cleared.
        If `bytesize` is 0, :py:obj:`~.cuMemAlloc()` returns
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

        Parameters
        ----------
        bytesize : size_t
            Requested allocation size in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        dptr : :py:obj:`~.CUdeviceptr`
            Returned device pointer

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMalloc`
    """


def cuMemAllocAsync(bytesize, hStream):
    """
    cuMemAllocAsync(size_t bytesize, hStream)
     Allocates memory with stream ordered semantics.

        Inserts an allocation operation into `hStream`. A pointer to the
        allocated memory is returned immediately in *dptr. The allocation must
        not be accessed until the the allocation operation completes. The
        allocation comes from the memory pool current to the stream's device.

        Parameters
        ----------
        bytesize : size_t
            Number of bytes to allocate
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream establishing the stream ordering contract and the memory
            pool to allocate from

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` (default stream specified with no current context), :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        dptr : :py:obj:`~.CUdeviceptr`
            Returned device pointer

        See Also
        --------
        :py:obj:`~.cuMemAllocFromPoolAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuMemPoolSetAttribute`

        Notes
        -----
        The default memory pool of a device contains device memory from that device.

        Basic stream ordering allows future work submitted into the same stream to use the allocation. Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation operation completes before work submitted in a separate stream runs.

        During stream capture, this function results in the creation of an allocation node. In this case, the allocation is owned by the graph instead of the memory pool. The memory pool's properties are used to set the node's creation parameters.
    """


def cuMemAllocFromPoolAsync(bytesize, pool, hStream):
    """
    cuMemAllocFromPoolAsync(size_t bytesize, pool, hStream)
     Allocates memory from a specified pool with stream ordered semantics.

        Inserts an allocation operation into `hStream`. A pointer to the
        allocated memory is returned immediately in *dptr. The allocation must
        not be accessed until the the allocation operation completes. The
        allocation comes from the specified memory pool.

        Parameters
        ----------
        bytesize : size_t
            Number of bytes to allocate
        pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
            The pool to allocate from
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream establishing the stream ordering semantic

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` (default stream specified with no current context), :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        dptr : :py:obj:`~.CUdeviceptr`
            Returned device pointer

        See Also
        --------
        :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuMemPoolSetAttribute`

        Notes
        -----
        During stream capture, this function results in the creation of an allocation node. In this case, the allocation is owned by the graph instead of the memory pool. The memory pool's properties are used to set the node's creation parameters.
    """


def cuMemAllocHost(bytesize):
    """
    cuMemAllocHost(size_t bytesize)
     Allocates page-locked host memory.

        Allocates `bytesize` bytes of host memory that is page-locked and
        accessible to the device. The driver tracks the virtual memory ranges
        allocated with this function and automatically accelerates calls to
        functions such as :py:obj:`~.cuMemcpy()`. Since the memory can be
        accessed directly by the device, it can be read or written with much
        higher bandwidth than pageable memory obtained with functions such as
        :py:obj:`~.malloc()`.

        On systems where
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`
        is true, :py:obj:`~.cuMemAllocHost` may not page-lock the allocated
        memory.

        Page-locking excessive amounts of memory with
        :py:obj:`~.cuMemAllocHost()` may degrade system performance, since it
        reduces the amount of memory available to the system for paging. As a
        result, this function is best used sparingly to allocate staging areas
        for data exchange between host and device.

        Note all host memory allocated using :py:obj:`~.cuMemAllocHost()` will
        automatically be immediately accessible to all contexts on all devices
        which support unified addressing (as may be queried using
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING`). The device pointer
        that may be used to access this host memory from those contexts is
        always equal to the returned host pointer `*pp`. See :py:obj:`~.Unified
        Addressing` for additional details.

        Parameters
        ----------
        bytesize : size_t
            Requested allocation size in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        pp : Any
            Returned pointer to host memory

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMallocHost`
    """


def cuMemAllocManaged(bytesize, flags):
    """
    cuMemAllocManaged(size_t bytesize, unsigned int flags)
     Allocates memory that will be automatically managed by the Unified Memory system.

        Allocates `bytesize` bytes of managed memory on the device and returns
        in `*dptr` a pointer to the allocated memory. If the device doesn't
        support allocating managed memory, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        is returned. Support for managed memory can be queried using the device
        attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY`. The allocated
        memory is suitably aligned for any kind of variable. The memory is not
        cleared. If `bytesize` is 0, :py:obj:`~.cuMemAllocManaged` returns
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE`. The pointer is valid on the CPU
        and on all GPUs in the system that support managed memory. All accesses
        to this pointer must obey the Unified Memory programming model.

        `flags` specifies the default stream association for this allocation.
        `flags` must be one of :py:obj:`~.CU_MEM_ATTACH_GLOBAL` or
        :py:obj:`~.CU_MEM_ATTACH_HOST`. If :py:obj:`~.CU_MEM_ATTACH_GLOBAL` is
        specified, then this memory is accessible from any stream on any
        device. If :py:obj:`~.CU_MEM_ATTACH_HOST` is specified, then the
        allocation should not be accessed from devices that have a zero value
        for the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`; an explicit
        call to :py:obj:`~.cuStreamAttachMemAsync` will be required to enable
        access on such devices.

        If the association is later changed via
        :py:obj:`~.cuStreamAttachMemAsync` to a single stream, the default
        association as specified during :py:obj:`~.cuMemAllocManaged` is
        restored when that stream is destroyed. For managed variables, the
        default association is always :py:obj:`~.CU_MEM_ATTACH_GLOBAL`. Note
        that destroying a stream is an asynchronous operation, and as a result,
        the change to default association won't happen until all work in the
        stream has completed.

        Memory allocated with :py:obj:`~.cuMemAllocManaged` should be released
        with :py:obj:`~.cuMemFree`.

        Device memory oversubscription is possible for GPUs that have a non-
        zero value for the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Managed
        memory on such GPUs may be evicted from device memory to host memory at
        any time by the Unified Memory driver in order to make room for other
        allocations.

        In a system where all GPUs have a non-zero value for the device
        attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`,
        managed memory may not be populated when this API returns and instead
        may be populated on access. In such systems, managed memory can migrate
        to any processor's memory at any time. The Unified Memory driver will
        employ heuristics to maintain data locality and prevent excessive page
        faults to the extent possible. The application can also guide the
        driver about memory usage patterns via :py:obj:`~.cuMemAdvise`. The
        application can also explicitly migrate memory to a desired processor's
        memory via :py:obj:`~.cuMemPrefetchAsync`.

        In a multi-GPU system where all of the GPUs have a zero value for the
        device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` and all the
        GPUs have peer-to-peer support with each other, the physical storage
        for managed memory is created on the GPU which is active at the time
        :py:obj:`~.cuMemAllocManaged` is called. All other GPUs will reference
        the data at reduced bandwidth via peer mappings over the PCIe bus. The
        Unified Memory driver does not migrate memory among such GPUs.

        In a multi-GPU system where not all GPUs have peer-to-peer support with
        each other and where the value of the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` is zero for
        at least one of those GPUs, the location chosen for physical storage of
        managed memory is system-dependent.

        - On Linux, the location chosen will be device memory as long as the
          current set of active contexts are on devices that either have peer-
          to-peer support with each other or have a non-zero value for the
          device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. If there
          is an active context on a GPU that does not have a non-zero value for
          that device attribute and it does not have peer-to-peer support with
          the other devices that have active contexts on them, then the
          location for physical storage will be 'zero-copy' or host memory.
          Note that this means that managed memory that is located in device
          memory is migrated to host memory if a new context is created on a
          GPU that doesn't have a non-zero value for the device attribute and
          does not support peer-to-peer with at least one of the other devices
          that has an active context. This in turn implies that context
          creation may fail if there is insufficient host memory to migrate all
          managed allocations.

        - On Windows, the physical storage is always created in 'zero-copy' or
          host memory. All GPUs will reference the data at reduced bandwidth
          over the PCIe bus. In these circumstances, use of the environment
          variable CUDA_VISIBLE_DEVICES is recommended to restrict CUDA to only
          use those GPUs that have peer-to-peer support. Alternatively, users
          can also set CUDA_MANAGED_FORCE_DEVICE_ALLOC to a non-zero value to
          force the driver to always use device memory for physical storage.
          When this environment variable is set to a non-zero value, all
          contexts created in that process on devices that support managed
          memory have to be peer-to-peer compatible with each other. Context
          creation will fail if a context is created on a device that supports
          managed memory and is not peer-to-peer compatible with any of the
          other managed memory supporting devices on which contexts were
          previously created, even if those contexts have been destroyed. These
          environment variables are described in the CUDA programming guide
          under the "CUDA environment variables" section.

        - On ARM, managed memory is not available on discrete gpu with Drive
          PX-2.

        Parameters
        ----------
        bytesize : size_t
            Requested allocation size in bytes
        flags : unsigned int
            Must be one of :py:obj:`~.CU_MEM_ATTACH_GLOBAL` or
            :py:obj:`~.CU_MEM_ATTACH_HOST`

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        dptr : :py:obj:`~.CUdeviceptr`
            Returned device pointer

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuStreamAttachMemAsync`, :py:obj:`~.cudaMallocManaged`
    """


def cuMemAllocPitch(WidthInBytes, Height, ElementSizeBytes):
    """
    cuMemAllocPitch(size_t WidthInBytes, size_t Height, unsigned int ElementSizeBytes)
     Allocates pitched device memory.

        Allocates at least `WidthInBytes` * `Height` bytes of linear memory on
        the device and returns in `*dptr` a pointer to the allocated memory.
        The function may pad the allocation to ensure that corresponding
        pointers in any given row will continue to meet the alignment
        requirements for coalescing as the address is updated from row to row.
        `ElementSizeBytes` specifies the size of the largest reads and writes
        that will be performed on the memory range. `ElementSizeBytes` may be
        4, 8 or 16 (since coalesced memory transactions are not possible on
        other data sizes). If `ElementSizeBytes` is smaller than the actual
        read/write size of a kernel, the kernel will run correctly, but
        possibly at reduced speed. The pitch returned in `*pPitch` by
        :py:obj:`~.cuMemAllocPitch()` is the width in bytes of the allocation.
        The intended usage of pitch is as a separate parameter of the
        allocation, used to compute addresses within the 2D array. Given the
        row and column of an array element of type T, the address is computed
        as:

        **View CUDA Toolkit Documentation for a C++ code example**

        The pitch returned by :py:obj:`~.cuMemAllocPitch()` is guaranteed to
        work with :py:obj:`~.cuMemcpy2D()` under all circumstances. For
        allocations of 2D arrays, it is recommended that programmers consider
        performing pitch allocations using :py:obj:`~.cuMemAllocPitch()`. Due
        to alignment restrictions in the hardware, this is especially true if
        the application will be performing 2D memory copies between different
        regions of device memory (whether linear memory or CUDA arrays).

        The byte alignment of the pitch returned by
        :py:obj:`~.cuMemAllocPitch()` is guaranteed to match or exceed the
        alignment requirement for texture binding with
        :py:obj:`~.cuTexRefSetAddress2D()`.

        Parameters
        ----------
        WidthInBytes : size_t
            Requested allocation width in bytes
        Height : size_t
            Requested allocation height in rows
        ElementSizeBytes : unsigned int
            Size of largest reads/writes for range

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        dptr : :py:obj:`~.CUdeviceptr`
            Returned device pointer
        pPitch : int
            Returned pitch of allocation in bytes

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMallocPitch`
    """


def cuMemBatchDecompressAsync(paramsArray: 'Optional[CUmemDecompressParams]', count, flags, stream):
    """
    cuMemBatchDecompressAsync(CUmemDecompressParams paramsArray: Optional[CUmemDecompressParams], size_t count, unsigned int flags, stream)
     Submit a batch of `count` independent decompression operations.

        Each of the `count` decompression operations is described by a single
        entry in the `paramsArray` array. Once the batch has been submitted,
        the function will return, and decompression will happen asynchronously
        w.r.t. the CPU. To the work completion tracking mechanisms in the CUDA
        driver, the batch will be considered a single unit of work and
        processed according to stream semantics, i.e., it is not possible to
        query the completion of individual decompression operations within a
        batch.

        The memory pointed to by each of :py:obj:`~.CUmemDecompressParams.src`,
        :py:obj:`~.CUmemDecompressParams.dst`, and
        :py:obj:`~.CUmemDecompressParams.dstActBytes`, must be capable of usage
        with the hardware decompress feature. That is, for each of said
        pointers, the pointer attribute
        :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_MEM_DECOMPRESS_CAPABLE` should give
        a non-zero value. To ensure this, the memory backing the pointers
        should have been allocated using one of the following CUDA memory
        allocators:

        - :py:obj:`~.cuMemAlloc()`

        - :py:obj:`~.cuMemCreate()` with the usage flag
          :py:obj:`~.CU_MEM_CREATE_USAGE_HW_DECOMPRESS`

        - :py:obj:`~.cuMemAllocFromPoolAsync()` from a pool that was created
          with the usage flag
          :py:obj:`~.CU_MEM_POOL_CREATE_USAGE_HW_DECOMPRESS` Additionally,
          :py:obj:`~.CUmemDecompressParams.src`,
          :py:obj:`~.CUmemDecompressParams.dst`, and
          :py:obj:`~.CUmemDecompressParams.dstActBytes`, must all be accessible
          from the device associated with the context where `stream` was
          created. For information on how to ensure this, see the documentation
          for the allocator of interest.

        Parameters
        ----------
        paramsArray : :py:obj:`~.CUmemDecompressParams`
            The array of structures describing the independent decompression
            operations.
        count : size_t
            The number of entries in `paramsArray` array.
        flags : unsigned int
            Must be 0.
        stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream where the work will be enqueued.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
        errorIndex : int
            The index into `paramsArray` of the decompression operation for
            which the error returned by this function pertains to. If `index`
            is SIZE_MAX and the value returned is not :py:obj:`~.CUDA_SUCCESS`,
            then the error returned by this function should be considered a
            general error that does not pertain to a particular decompression
            operation. May be `NULL`, in which case, no index will be recorded
            in the event of error.

        See Also
        --------
        :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemAllocFromPoolAsync`
    """


def cuMemCreate(size, prop: 'Optional[CUmemAllocationProp]', flags):
    """
    cuMemCreate(size_t size, CUmemAllocationProp prop: Optional[CUmemAllocationProp], unsigned long long flags)
     Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.

        This creates a memory allocation on the target device specified through
        the `prop` structure. The created allocation will not have any device
        or host mappings. The generic memory `handle` for the allocation can be
        mapped to the address space of calling process via
        :py:obj:`~.cuMemMap`. This handle cannot be transmitted directly to
        other processes (see :py:obj:`~.cuMemExportToShareableHandle`). On
        Windows, the caller must also pass an LPSECURITYATTRIBUTE in `prop` to
        be associated with this handle which limits or allows access to this
        handle for a recipient process (see
        :py:obj:`~.CUmemAllocationProp.win32HandleMetaData` for more). The
        `size` of this allocation must be a multiple of the the value given via
        :py:obj:`~.cuMemGetAllocationGranularity` with the
        :py:obj:`~.CU_MEM_ALLOC_GRANULARITY_MINIMUM` flag. To create a CPU
        allocation targeting a specific host NUMA node, applications must set
        :py:obj:`~.CUmemAllocationProp`::CUmemLocation::type to
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` and
        :py:obj:`~.CUmemAllocationProp`::CUmemLocation::id must specify the
        NUMA ID of the CPU. On systems where NUMA is not available
        :py:obj:`~.CUmemAllocationProp`::CUmemLocation::id must be set to 0.
        Specifying :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT` or
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` as the
        :py:obj:`~.CUmemLocation.type` will result in
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

        Applications that intend to use :py:obj:`~.CU_MEM_HANDLE_TYPE_FABRIC`
        based memory sharing must ensure: (1) `nvidia-caps-imex-channels`
        character device is created by the driver and is listed under
        /proc/devices (2) have at least one IMEX channel file accessible by the
        user launching the application.

        When exporter and importer CUDA processes have been granted access to
        the same IMEX channel, they can securely share memory.

        The IMEX channel security model works on a per user basis. Which means
        all processes under a user can share memory if the user has access to a
        valid IMEX channel. When multi-user isolation is desired, a separate
        IMEX channel is required for each user.

        These channel files exist in /dev/nvidia-caps-imex-channels/channel*
        and can be created using standard OS native calls like mknod on Linux.
        For example: To create channel0 with the major number from
        /proc/devices users can execute the following command: `mknod
        /dev/nvidia-caps-imex-channels/channel0 c <major number> 0`

        If :py:obj:`~.CUmemAllocationProp`::allocFlags::usage contains
        :py:obj:`~.CU_MEM_CREATE_USAGE_TILE_POOL` flag then the memory
        allocation is intended only to be used as backing tile pool for sparse
        CUDA arrays and sparse CUDA mipmapped arrays. (see
        :py:obj:`~.cuMemMapArrayAsync`).

        Parameters
        ----------
        size : size_t
            Size of the allocation requested
        prop : :py:obj:`~.CUmemAllocationProp`
            Properties of the allocation to create.
        flags : unsigned long long
            flags for future use, must be zero now.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        handle : :py:obj:`~.CUmemGenericAllocationHandle`
            Value of handle returned. All operations on this allocation are to
            be performed using this handle.

        See Also
        --------
        :py:obj:`~.cuMemRelease`, :py:obj:`~.cuMemExportToShareableHandle`, :py:obj:`~.cuMemImportFromShareableHandle`
    """


def cuMemExportToShareableHandle(handle, handleType: 'CUmemAllocationHandleType', flags):
    """
    cuMemExportToShareableHandle(handle, handleType: CUmemAllocationHandleType, unsigned long long flags)
     Exports an allocation to a requested shareable handle type.

        Given a CUDA memory handle, create a shareable memory allocation handle
        that can be used to share the memory with other processes. The
        recipient process can convert the shareable handle back into a CUDA
        memory handle using :py:obj:`~.cuMemImportFromShareableHandle` and map
        it with :py:obj:`~.cuMemMap`. The implementation of what this handle is
        and how it can be transferred is defined by the requested handle type
        in `handleType`

        Once all shareable handles are closed and the allocation is released,
        the allocated memory referenced will be released back to the OS and
        uses of the CUDA handle afterward will lead to undefined behavior.

        This API can also be used in conjunction with other APIs (e.g. Vulkan,
        OpenGL) that support importing memory from the shareable type

        Parameters
        ----------
        handle : :py:obj:`~.CUmemGenericAllocationHandle`
            CUDA handle for the memory allocation
        handleType : :py:obj:`~.CUmemAllocationHandleType`
            Type of shareable handle requested (defines type and size of the
            `shareableHandle` output parameter)
        flags : unsigned long long
            Reserved, must be zero

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        shareableHandle : Any
            Pointer to the location in which to store the requested handle type

        See Also
        --------
        :py:obj:`~.cuMemImportFromShareableHandle`
    """


def cuMemFree(dptr):
    """
    cuMemFree(dptr)
     Frees device memory.

        Frees the memory space pointed to by `dptr`, which must have been
        returned by a previous call to one of the following memory allocation
        APIs - :py:obj:`~.cuMemAlloc()`, :py:obj:`~.cuMemAllocPitch()`,
        :py:obj:`~.cuMemAllocManaged()`, :py:obj:`~.cuMemAllocAsync()`,
        :py:obj:`~.cuMemAllocFromPoolAsync()`

        Note - This API will not perform any implict synchronization when the
        pointer was allocated with :py:obj:`~.cuMemAllocAsync` or
        :py:obj:`~.cuMemAllocFromPoolAsync`. Callers must ensure that all
        accesses to these pointer have completed before invoking
        :py:obj:`~.cuMemFree`. For best performance and memory reuse, users
        should use :py:obj:`~.cuMemFreeAsync` to free memory allocated via the
        stream ordered memory allocator. For all other pointers, this API may
        perform implicit synchronization.

        Parameters
        ----------
        dptr : :py:obj:`~.CUdeviceptr`
            Pointer to memory to free

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemAllocFromPoolAsync`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaFree`
    """


def cuMemFreeAsync(dptr, hStream):
    """
    cuMemFreeAsync(dptr, hStream)
     Frees memory with stream ordered semantics.

        Inserts a free operation into `hStream`. The allocation must not be
        accessed after stream execution reaches the free. After this API
        returns, accessing the memory from any subsequent work launched on the
        GPU or querying its pointer attributes results in undefined behavior.

        Parameters
        ----------
        dptr : :py:obj:`~.CUdeviceptr`
            memory to free
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream establishing the stream ordering contract.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` (default stream specified with no current context), :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        Notes
        -----
        During stream capture, this function results in the creation of a free node and must therefore be passed the address of a graph allocation.
    """


def cuMemFreeHost(p):
    """
    cuMemFreeHost(p)
     Frees page-locked host memory.

        Frees the memory space pointed to by `p`, which must have been returned
        by a previous call to :py:obj:`~.cuMemAllocHost()`.

        Parameters
        ----------
        p : Any
            Pointer to memory to free

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaFreeHost`
    """


def cuMemGetAccess(location: 'Optional[CUmemLocation]', ptr):
    """
    cuMemGetAccess(CUmemLocation location: Optional[CUmemLocation], ptr)
     Get the access `flags` set for the given `location` and `ptr`.

        Parameters
        ----------
        location : :py:obj:`~.CUmemLocation`
            Location in which to check the flags for
        ptr : :py:obj:`~.CUdeviceptr`
            Address in which to check the access flags for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        flags : unsigned long long
            Flags set for this location

        See Also
        --------
        :py:obj:`~.cuMemSetAccess`
    """


def cuMemGetAddressRange(dptr):
    """
    cuMemGetAddressRange(dptr)
     Get information on memory allocations.

        Returns the base address in `*pbase` and size in `*psize` of the
        allocation by :py:obj:`~.cuMemAlloc()` or :py:obj:`~.cuMemAllocPitch()`
        that contains the input pointer `dptr`. Both parameters `pbase` and
        `psize` are optional. If one of them is NULL, it is ignored.

        Parameters
        ----------
        dptr : :py:obj:`~.CUdeviceptr`
            Device pointer to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pbase : :py:obj:`~.CUdeviceptr`
            Returned base address
        psize : int
            Returned size of device memory allocation

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`
    """


def cuMemGetAllocationGranularity(prop: 'Optional[CUmemAllocationProp]', option: 'CUmemAllocationGranularity_flags'):
    """
    cuMemGetAllocationGranularity(CUmemAllocationProp prop: Optional[CUmemAllocationProp], option: CUmemAllocationGranularity_flags)
     Calculates either the minimal or recommended granularity.

        Calculates either the minimal or recommended granularity for a given
        allocation specification and returns it in granularity. This
        granularity can be used as a multiple for alignment, size, or address
        mapping.

        Parameters
        ----------
        prop : :py:obj:`~.CUmemAllocationProp`
            Property for which to determine the granularity for
        option : :py:obj:`~.CUmemAllocationGranularity_flags`
            Determines which granularity to return

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        granularity : int
            Returned granularity.

        See Also
        --------
        :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemMap`
    """


def cuMemGetAllocationPropertiesFromHandle(handle):
    """
    cuMemGetAllocationPropertiesFromHandle(handle)
     Retrieve the contents of the property structure defining properties for this handle.

        Parameters
        ----------
        handle : :py:obj:`~.CUmemGenericAllocationHandle`
            Handle which to perform the query on

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        prop : :py:obj:`~.CUmemAllocationProp`
            Pointer to a properties structure which will hold the information
            about this handle

        See Also
        --------
        :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemImportFromShareableHandle`
    """


def cuMemGetHandleForAddressRange(dptr, size, handleType: 'CUmemRangeHandleType', flags):
    """
    cuMemGetHandleForAddressRange(dptr, size_t size, handleType: CUmemRangeHandleType, unsigned long long flags)
     Retrieve handle for an address range.

        Get a handle of the specified type to an address range. The address
        range must have been obtained by a prior call to either
        :py:obj:`~.cuMemAlloc` or :py:obj:`~.cuMemAddressReserve`. If the
        address range was obtained via :py:obj:`~.cuMemAddressReserve`, it must
        also be fully mapped via :py:obj:`~.cuMemMap`. The address range must
        have been obtained by a prior call to either :py:obj:`~.cuMemAllocHost`
        or :py:obj:`~.cuMemHostAlloc` on Tegra.

        Users must ensure the `dptr` and `size` are aligned to the host page
        size.

        When requesting
        CUmemRangeHandleType::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD, users are
        expected to query for dma_buf support for the platform by using
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED` device attribute
        before calling this API. The `handle` will be interpreted as a pointer
        to an integer to store the dma_buf file descriptor. Users must ensure
        the entire address range is backed and mapped when the address range is
        allocated by :py:obj:`~.cuMemAddressReserve`. All the physical
        allocations backing the address range must be resident on the same
        device and have identical allocation properties. Users are also
        expected to retrieve a new handle every time the underlying physical
        allocation(s) corresponding to a previously queried VA range are
        changed.

        For CUmemRangeHandleType::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD, users
        may set flags to
        :py:obj:`~.CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE`. Which when set
        on a supported platform, will give a DMA_BUF handle mapped via PCIE
        BAR1 or will return an error otherwise.

        Parameters
        ----------
        dptr : :py:obj:`~.CUdeviceptr`
            Pointer to a valid CUDA device allocation. Must be aligned to host
            page size.
        size : size_t
            Length of the address range. Must be aligned to host page size.
        handleType : :py:obj:`~.CUmemRangeHandleType`
            Type of handle requested (defines type and size of the `handle`
            output parameter)
        flags : unsigned long long
            When requesting
            CUmemRangeHandleType::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD the value
            could be :py:obj:`~.CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE`,
            otherwise 0.

        Returns
        -------
        CUresult
            CUDA_SUCCESS CUDA_ERROR_INVALID_VALUE CUDA_ERROR_NOT_SUPPORTED
        handle : Any
            Pointer to the location where the returned handle will be stored.
    """


def cuMemGetInfo():
    """
    cuMemGetInfo()
     Gets free and total memory.

        Returns in `*total` the total amount of memory available to the the
        current context. Returns in `*free` the amount of memory on the device
        that is free according to the OS. CUDA is not guaranteed to be able to
        allocate all of the memory that the OS reports as free. In a multi-
        tenet situation, free estimate returned is prone to race condition
        where a new allocation/free done by a different process or a different
        thread in the same process between the time when free memory was
        estimated and reported, will result in deviation in free value reported
        and actual free memory.

        The integrated GPU on Tegra shares memory with CPU and other component
        of the SoC. The free and total values returned by the API excludes the
        SWAP memory space maintained by the OS on some platforms. The OS may
        move some of the memory pages into swap area as the GPU or CPU allocate
        or access memory. See Tegra app note on how to calculate total and free
        memory on Tegra.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        free : int
            Returned free memory in bytes
        total : int
            Returned total memory in bytes

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemGetInfo`
    """


def cuMemHostAlloc(bytesize, Flags):
    """
    cuMemHostAlloc(size_t bytesize, unsigned int Flags)
     Allocates page-locked host memory.

        Allocates `bytesize` bytes of host memory that is page-locked and
        accessible to the device. The driver tracks the virtual memory ranges
        allocated with this function and automatically accelerates calls to
        functions such as :py:obj:`~.cuMemcpyHtoD()`. Since the memory can be
        accessed directly by the device, it can be read or written with much
        higher bandwidth than pageable memory obtained with functions such as
        :py:obj:`~.malloc()`.

        On systems where
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`
        is true, :py:obj:`~.cuMemHostAlloc` may not page-lock the allocated
        memory.

        Page-locking excessive amounts of memory may degrade system
        performance, since it reduces the amount of memory available to the
        system for paging. As a result, this function is best used sparingly to
        allocate staging areas for data exchange between host and device.

        The `Flags` parameter enables different options to be specified that
        affect the allocation, as follows.

        - :py:obj:`~.CU_MEMHOSTALLOC_PORTABLE`: The memory returned by this
          call will be considered as pinned memory by all CUDA contexts, not
          just the one that performed the allocation.

        - :py:obj:`~.CU_MEMHOSTALLOC_DEVICEMAP`: Maps the allocation into the
          CUDA address space. The device pointer to the memory may be obtained
          by calling :py:obj:`~.cuMemHostGetDevicePointer()`.

        - :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED`: Allocates the memory as
          write-combined (WC). WC memory can be transferred across the PCI
          Express bus more quickly on some system configurations, but cannot be
          read efficiently by most CPUs. WC memory is a good option for buffers
          that will be written by the CPU and read by the GPU via mapped pinned
          memory or host->device transfers.

        All of these flags are orthogonal to one another: a developer may
        allocate memory that is portable, mapped and/or write-combined with no
        restrictions.

        The :py:obj:`~.CU_MEMHOSTALLOC_DEVICEMAP` flag may be specified on CUDA
        contexts for devices that do not support mapped pinned memory. The
        failure is deferred to :py:obj:`~.cuMemHostGetDevicePointer()` because
        the memory may be mapped into other CUDA contexts via the
        :py:obj:`~.CU_MEMHOSTALLOC_PORTABLE` flag.

        The memory allocated by this function must be freed with
        :py:obj:`~.cuMemFreeHost()`.

        Note all host memory allocated using :py:obj:`~.cuMemHostAlloc()` will
        automatically be immediately accessible to all contexts on all devices
        which support unified addressing (as may be queried using
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING`). Unless the flag
        :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED` is specified, the device
        pointer that may be used to access this host memory from those contexts
        is always equal to the returned host pointer `*pp`. If the flag
        :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED` is specified, then the
        function :py:obj:`~.cuMemHostGetDevicePointer()` must be used to query
        the device pointer, even if the context supports unified addressing.
        See :py:obj:`~.Unified Addressing` for additional details.

        Parameters
        ----------
        bytesize : size_t
            Requested allocation size in bytes
        Flags : unsigned int
            Flags for allocation request

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        pp : Any
            Returned pointer to host memory

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaHostAlloc`
    """


def cuMemHostGetDevicePointer(p, Flags):
    """
    cuMemHostGetDevicePointer(p, unsigned int Flags)
     Passes back device pointer of mapped pinned memory.

        Passes back the device pointer `pdptr` corresponding to the mapped,
        pinned host buffer `p` allocated by :py:obj:`~.cuMemHostAlloc`.

        :py:obj:`~.cuMemHostGetDevicePointer()` will fail if the
        :py:obj:`~.CU_MEMHOSTALLOC_DEVICEMAP` flag was not specified at the
        time the memory was allocated, or if the function is called on a GPU
        that does not support mapped pinned memory.

        For devices that have a non-zero value for the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM`,
        the memory can also be accessed from the device using the host pointer
        `p`. The device pointer returned by
        :py:obj:`~.cuMemHostGetDevicePointer()` may or may not match the
        original host pointer `p` and depends on the devices visible to the
        application. If all devices visible to the application have a non-zero
        value for the device attribute, the device pointer returned by
        :py:obj:`~.cuMemHostGetDevicePointer()` will match the original pointer
        `p`. If any device visible to the application has a zero value for the
        device attribute, the device pointer returned by
        :py:obj:`~.cuMemHostGetDevicePointer()` will not match the original
        host pointer `p`, but it will be suitable for use on all devices
        provided Unified Virtual Addressing is enabled. In such systems, it is
        valid to access the memory using either pointer on devices that have a
        non-zero value for the device attribute. Note however that such devices
        should access the memory using only one of the two pointers and not
        both.

        `Flags` provides for future releases. For now, it must be set to 0.

        Parameters
        ----------
        p : Any
            Host pointer
        Flags : unsigned int
            Options (must be 0)

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pdptr : :py:obj:`~.CUdeviceptr`
            Returned device pointer

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaHostGetDevicePointer`
    """


def cuMemHostGetFlags(p):
    """
    cuMemHostGetFlags(p)
     Passes back flags that were used for a pinned allocation.

        Passes back the flags `pFlags` that were specified when allocating the
        pinned host buffer `p` allocated by :py:obj:`~.cuMemHostAlloc`.

        :py:obj:`~.cuMemHostGetFlags()` will fail if the pointer does not
        reside in an allocation performed by :py:obj:`~.cuMemAllocHost()` or
        :py:obj:`~.cuMemHostAlloc()`.

        Parameters
        ----------
        p : Any
            Host pointer

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pFlags : unsigned int
            Returned flags word

        See Also
        --------
        :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cudaHostGetFlags`
    """


def cuMemHostRegister(p, bytesize, Flags):
    """
    cuMemHostRegister(p, size_t bytesize, unsigned int Flags)
     Registers an existing host memory range for use by CUDA.

        Page-locks the memory range specified by `p` and `bytesize` and maps it
        for the device(s) as specified by `Flags`. This memory range also is
        added to the same tracking mechanism as :py:obj:`~.cuMemHostAlloc` to
        automatically accelerate calls to functions such as
        :py:obj:`~.cuMemcpyHtoD()`. Since the memory can be accessed directly
        by the device, it can be read or written with much higher bandwidth
        than pageable memory that has not been registered. Page-locking
        excessive amounts of memory may degrade system performance, since it
        reduces the amount of memory available to the system for paging. As a
        result, this function is best used sparingly to register staging areas
        for data exchange between host and device.

        On systems where
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`
        is true, :py:obj:`~.cuMemHostRegister` will not page-lock the memory
        range specified by `ptr` but only populate unpopulated pages.

        The `Flags` parameter enables different options to be specified that
        affect the allocation, as follows.

        - :py:obj:`~.CU_MEMHOSTREGISTER_PORTABLE`: The memory returned by this
          call will be considered as pinned memory by all CUDA contexts, not
          just the one that performed the allocation.

        - :py:obj:`~.CU_MEMHOSTREGISTER_DEVICEMAP`: Maps the allocation into
          the CUDA address space. The device pointer to the memory may be
          obtained by calling :py:obj:`~.cuMemHostGetDevicePointer()`.

        - :py:obj:`~.CU_MEMHOSTREGISTER_IOMEMORY`: The pointer is treated as
          pointing to some I/O memory space, e.g. the PCI Express resource of a
          3rd party device.

        - :py:obj:`~.CU_MEMHOSTREGISTER_READ_ONLY`: The pointer is treated as
          pointing to memory that is considered read-only by the device. On
          platforms without
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
          this flag is required in order to register memory mapped to the CPU
          as read-only. Support for the use of this flag can be queried from
          the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED`.
          Using this flag with a current context associated with a device that
          does not have this attribute set will cause
          :py:obj:`~.cuMemHostRegister` to error with CUDA_ERROR_NOT_SUPPORTED.

        All of these flags are orthogonal to one another: a developer may page-
        lock memory that is portable or mapped with no restrictions.

        The :py:obj:`~.CU_MEMHOSTREGISTER_DEVICEMAP` flag may be specified on
        CUDA contexts for devices that do not support mapped pinned memory. The
        failure is deferred to :py:obj:`~.cuMemHostGetDevicePointer()` because
        the memory may be mapped into other CUDA contexts via the
        :py:obj:`~.CU_MEMHOSTREGISTER_PORTABLE` flag.

        For devices that have a non-zero value for the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM`,
        the memory can also be accessed from the device using the host pointer
        `p`. The device pointer returned by
        :py:obj:`~.cuMemHostGetDevicePointer()` may or may not match the
        original host pointer `ptr` and depends on the devices visible to the
        application. If all devices visible to the application have a non-zero
        value for the device attribute, the device pointer returned by
        :py:obj:`~.cuMemHostGetDevicePointer()` will match the original pointer
        `ptr`. If any device visible to the application has a zero value for
        the device attribute, the device pointer returned by
        :py:obj:`~.cuMemHostGetDevicePointer()` will not match the original
        host pointer `ptr`, but it will be suitable for use on all devices
        provided Unified Virtual Addressing is enabled. In such systems, it is
        valid to access the memory using either pointer on devices that have a
        non-zero value for the device attribute. Note however that such devices
        should access the memory using only of the two pointers and not both.

        The memory page-locked by this function must be unregistered with
        :py:obj:`~.cuMemHostUnregister()`.

        Parameters
        ----------
        p : Any
            Host pointer to memory to page-lock
        bytesize : size_t
            Size in bytes of the address range to page-lock
        Flags : unsigned int
            Flags for allocation request

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuMemHostUnregister`, :py:obj:`~.cuMemHostGetFlags`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cudaHostRegister`
    """


def cuMemHostUnregister(p):
    """
    cuMemHostUnregister(p)
     Unregisters a memory range that was registered with cuMemHostRegister.

        Unmaps the memory range whose base address is specified by `p`, and
        makes it pageable again.

        The base address must be the same one specified to
        :py:obj:`~.cuMemHostRegister()`.

        Parameters
        ----------
        p : Any
            Host pointer to memory to unregister

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED`,

        See Also
        --------
        :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cudaHostUnregister`
    """


def cuMemImportFromShareableHandle(osHandle, shHandleType: 'CUmemAllocationHandleType'):
    """
    cuMemImportFromShareableHandle(osHandle, shHandleType: CUmemAllocationHandleType)
     Imports an allocation from a requested shareable handle type.

        If the current process cannot support the memory described by this
        shareable handle, this API will error as
        :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`.

        If `shHandleType` is :py:obj:`~.CU_MEM_HANDLE_TYPE_FABRIC` and the
        importer process has not been granted access to the same IMEX channel
        as the exporter process, this API will error as
        :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`.

        Parameters
        ----------
        osHandle : Any
            Shareable Handle representing the memory allocation that is to be
            imported.
        shHandleType : :py:obj:`~.CUmemAllocationHandleType`
            handle type of the exported handle
            :py:obj:`~.CUmemAllocationHandleType`.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        handle : :py:obj:`~.CUmemGenericAllocationHandle`
            CUDA Memory handle for the memory allocation.

        See Also
        --------
        :py:obj:`~.cuMemExportToShareableHandle`, :py:obj:`~.cuMemMap`, :py:obj:`~.cuMemRelease`

        Notes
        -----
        Importing shareable handles exported from some graphics APIs(VUlkan, OpenGL, etc) created on devices under an SLI group may not be supported, and thus this API will return CUDA_ERROR_NOT_SUPPORTED. There is no guarantee that the contents of `handle` will be the same CUDA memory handle for the same given OS shareable handle, or the same underlying allocation.
    """


def cuMemMap(ptr, size, offset, handle, flags):
    """
    cuMemMap(ptr, size_t size, size_t offset, handle, unsigned long long flags)
     Maps an allocation handle to a reserved virtual address range.

        Maps bytes of memory represented by `handle` starting from byte
        `offset` to `size` to address range [`addr`, `addr` + `size`]. This
        range must be an address reservation previously reserved with
        :py:obj:`~.cuMemAddressReserve`, and `offset` + `size` must be less
        than the size of the memory allocation. Both `ptr`, `size`, and
        `offset` must be a multiple of the value given via
        :py:obj:`~.cuMemGetAllocationGranularity` with the
        :py:obj:`~.CU_MEM_ALLOC_GRANULARITY_MINIMUM` flag. If `handle`
        represents a multicast object, `ptr`, `size` and `offset` must be
        aligned to the value returned by :py:obj:`~.cuMulticastGetGranularity`
        with the flag :py:obj:`~.CU_MULTICAST_MINIMUM_GRANULARITY`. For best
        performance however, it is recommended that `ptr`, `size` and `offset`
        be aligned to the value returned by
        :py:obj:`~.cuMulticastGetGranularity` with the flag
        :py:obj:`~.CU_MULTICAST_RECOMMENDED_GRANULARITY`.

        Please note calling :py:obj:`~.cuMemMap` does not make the address
        accessible, the caller needs to update accessibility of a contiguous
        mapped VA range by calling :py:obj:`~.cuMemSetAccess`.

        Once a recipient process obtains a shareable memory handle from
        :py:obj:`~.cuMemImportFromShareableHandle`, the process must use
        :py:obj:`~.cuMemMap` to map the memory into its address ranges before
        setting accessibility with :py:obj:`~.cuMemSetAccess`.

        :py:obj:`~.cuMemMap` can only create mappings on VA range reservations
        that are not currently mapped.

        Parameters
        ----------
        ptr : :py:obj:`~.CUdeviceptr`
            Address where memory will be mapped.
        size : size_t
            Size of the memory mapping.
        offset : size_t
            Offset into the memory represented by
        handle : :py:obj:`~.CUmemGenericAllocationHandle`
            Handle to a shareable memory
        flags : unsigned long long
            flags for future use, must be zero now.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuMemUnmap`, :py:obj:`~.cuMemSetAccess`, :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemAddressReserve`, :py:obj:`~.cuMemImportFromShareableHandle`
    """


def cuMemMapArrayAsync(mapInfoList: 'Optional[Tuple[CUarrayMapInfo] | List[CUarrayMapInfo]]', count, hStream):
    """
    cuMemMapArrayAsync(mapInfoList: Optional[Tuple[CUarrayMapInfo] | List[CUarrayMapInfo]], unsigned int count, hStream)
     Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.

        Performs map or unmap operations on subregions of sparse CUDA arrays
        and sparse CUDA mipmapped arrays. Each operation is specified by a
        :py:obj:`~.CUarrayMapInfo` entry in the `mapInfoList` array of size
        `count`. The structure :py:obj:`~.CUarrayMapInfo` is defined as follow:

        **View CUDA Toolkit Documentation for a C++ code example**

        where :py:obj:`~.CUarrayMapInfo.resourceType` specifies the type of
        resource to be operated on. If :py:obj:`~.CUarrayMapInfo.resourceType`
        is set to :py:obj:`~.CUresourcetype`::CU_RESOURCE_TYPE_ARRAY then
        :py:obj:`~.CUarrayMapInfo`::resource::array must be set to a valid
        sparse CUDA array handle. The CUDA array must be either a 2D, 2D
        layered or 3D CUDA array and must have been allocated using
        :py:obj:`~.cuArrayCreate` or :py:obj:`~.cuArray3DCreate` with the flag
        :py:obj:`~.CUDA_ARRAY3D_SPARSE` or
        :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`. For CUDA arrays obtained
        using :py:obj:`~.cuMipmappedArrayGetLevel`,
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned. If
        :py:obj:`~.CUarrayMapInfo.resourceType` is set to
        :py:obj:`~.CUresourcetype`::CU_RESOURCE_TYPE_MIPMAPPED_ARRAY then
        :py:obj:`~.CUarrayMapInfo`::resource::mipmap must be set to a valid
        sparse CUDA mipmapped array handle. The CUDA mipmapped array must be
        either a 2D, 2D layered or 3D CUDA mipmapped array and must have been
        allocated using :py:obj:`~.cuMipmappedArrayCreate` with the flag
        :py:obj:`~.CUDA_ARRAY3D_SPARSE` or
        :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`.

        :py:obj:`~.CUarrayMapInfo.subresourceType` specifies the type of
        subresource within the resource.
        :py:obj:`~.CUarraySparseSubresourceType_enum` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where
        :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL
        indicates a sparse-miplevel which spans at least one tile in every
        dimension. The remaining miplevels which are too small to span at least
        one tile in any dimension constitute the mip tail region as indicated
        by
        :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL
        subresource type.

        If :py:obj:`~.CUarrayMapInfo.subresourceType` is set to
        :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL
        then :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel struct must
        contain valid array subregion offsets and extents. The
        :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetX,
        :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetY and
        :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetZ must
        specify valid X, Y and Z offsets respectively. The
        :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentWidth,
        :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentHeight and
        :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentDepth must
        specify valid width, height and depth extents respectively. These
        offsets and extents must be aligned to the corresponding tile
        dimension. For CUDA mipmapped arrays
        :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::level must
        specify a valid mip level index. Otherwise, must be zero. For layered
        CUDA arrays and layered CUDA mipmapped arrays
        :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::layer must
        specify a valid layer index. Otherwise, must be zero.
        :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetZ must be
        zero and
        :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentDepth must
        be set to 1 for 2D and 2D layered CUDA arrays and CUDA mipmapped
        arrays. Tile extents can be obtained by calling
        :py:obj:`~.cuArrayGetSparseProperties` and
        :py:obj:`~.cuMipmappedArrayGetSparseProperties`

        If :py:obj:`~.CUarrayMapInfo.subresourceType` is set to
        :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL
        then :py:obj:`~.CUarrayMapInfo`::subresource::miptail struct must
        contain valid mip tail offset in
        :py:obj:`~.CUarrayMapInfo`::subresource::miptail::offset and size in
        :py:obj:`~.CUarrayMapInfo`::subresource::miptail::size. Both, mip tail
        offset and mip tail size must be aligned to the tile size. For layered
        CUDA mipmapped arrays which don't have the flag
        :py:obj:`~.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL` set in
        :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.flags` as returned by
        :py:obj:`~.cuMipmappedArrayGetSparseProperties`,
        :py:obj:`~.CUarrayMapInfo`::subresource::miptail::layer must specify a
        valid layer index. Otherwise, must be zero.

        If :py:obj:`~.CUarrayMapInfo`::resource::array or
        :py:obj:`~.CUarrayMapInfo`::resource::mipmap was created with
        :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING` flag set the
        :py:obj:`~.CUarrayMapInfo.subresourceType` and the contents of
        :py:obj:`~.CUarrayMapInfo`::subresource will be ignored.

        :py:obj:`~.CUarrayMapInfo.memOperationType` specifies the type of
        operation. :py:obj:`~.CUmemOperationType` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        If :py:obj:`~.CUarrayMapInfo.memOperationType` is set to
        :py:obj:`~.CUmemOperationType`::CU_MEM_OPERATION_TYPE_MAP then the
        subresource will be mapped onto the tile pool memory specified by
        :py:obj:`~.CUarrayMapInfo`::memHandle at offset
        :py:obj:`~.CUarrayMapInfo.offset`. The tile pool allocation has to be
        created by specifying the :py:obj:`~.CU_MEM_CREATE_USAGE_TILE_POOL`
        flag when calling :py:obj:`~.cuMemCreate`. Also,
        :py:obj:`~.CUarrayMapInfo.memHandleType` must be set to
        :py:obj:`~.CUmemHandleType`::CU_MEM_HANDLE_TYPE_GENERIC.

        If :py:obj:`~.CUarrayMapInfo.memOperationType` is set to
        :py:obj:`~.CUmemOperationType`::CU_MEM_OPERATION_TYPE_UNMAP then an
        unmapping operation is performed. :py:obj:`~.CUarrayMapInfo`::memHandle
        must be NULL.

        :py:obj:`~.CUarrayMapInfo.deviceBitMask` specifies the list of devices
        that must map or unmap physical memory. Currently, this mask must have
        exactly one bit set, and the corresponding device must match the device
        associated with the stream. If
        :py:obj:`~.CUarrayMapInfo.memOperationType` is set to
        :py:obj:`~.CUmemOperationType`::CU_MEM_OPERATION_TYPE_MAP, the device
        must also match the device associated with the tile pool memory
        allocation as specified by :py:obj:`~.CUarrayMapInfo`::memHandle.

        :py:obj:`~.CUarrayMapInfo.flags` and
        :py:obj:`~.CUarrayMapInfo.reserved`[] are unused and must be set to
        zero.

        Parameters
        ----------
        mapInfoList : List[:py:obj:`~.CUarrayMapInfo`]
            List of :py:obj:`~.CUarrayMapInfo`
        count : unsigned int
            Count of :py:obj:`~.CUarrayMapInfo` in `mapInfoList`
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier for the stream to use for map or unmap operations

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuMipmappedArrayCreate`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuMemCreate`, :py:obj:`~.cuArrayGetSparseProperties`, :py:obj:`~.cuMipmappedArrayGetSparseProperties`
    """


def cuMemPoolCreate(poolProps: 'Optional[CUmemPoolProps]'):
    """
    cuMemPoolCreate(CUmemPoolProps poolProps: Optional[CUmemPoolProps])
     Creates a memory pool.

        Creates a CUDA memory pool and returns the handle in `pool`. The
        `poolProps` determines the properties of the pool such as the backing
        device and IPC capabilities.

        To create a memory pool targeting a specific host NUMA node,
        applications must set :py:obj:`~.CUmemPoolProps`::CUmemLocation::type
        to :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` and
        :py:obj:`~.CUmemPoolProps`::CUmemLocation::id must specify the NUMA ID
        of the host memory node. Specifying
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT` or
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` as the
        :py:obj:`~.CUmemPoolProps`::CUmemLocation::type will result in
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE`. By default, the pool's memory
        will be accessible from the device it is allocated on. In the case of
        pools created with :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA`, their
        default accessibility will be from the host CPU. Applications can
        control the maximum size of the pool by specifying a non-zero value for
        :py:obj:`~.CUmemPoolProps.maxSize`. If set to 0, the maximum size of
        the pool will default to a system dependent value.

        Applications that intend to use :py:obj:`~.CU_MEM_HANDLE_TYPE_FABRIC`
        based memory sharing must ensure: (1) `nvidia-caps-imex-channels`
        character device is created by the driver and is listed under
        /proc/devices (2) have at least one IMEX channel file accessible by the
        user launching the application.

        When exporter and importer CUDA processes have been granted access to
        the same IMEX channel, they can securely share memory.

        The IMEX channel security model works on a per user basis. Which means
        all processes under a user can share memory if the user has access to a
        valid IMEX channel. When multi-user isolation is desired, a separate
        IMEX channel is required for each user.

        These channel files exist in /dev/nvidia-caps-imex-channels/channel*
        and can be created using standard OS native calls like mknod on Linux.
        For example: To create channel0 with the major number from
        /proc/devices users can execute the following command: `mknod
        /dev/nvidia-caps-imex-channels/channel0 c <major number> 0`

        Parameters
        ----------
        poolProps : :py:obj:`~.CUmemPoolProps`
            None

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        pool : :py:obj:`~.CUmemoryPool`
            None

        See Also
        --------
        :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuMemAllocFromPoolAsync`, :py:obj:`~.cuMemPoolExportToShareableHandle`

        Notes
        -----
        Specifying CU_MEM_HANDLE_TYPE_NONE creates a memory pool that will not support IPC.
    """


def cuMemPoolDestroy(pool):
    """
    cuMemPoolDestroy(pool)
     Destroys the specified memory pool.

        If any pointers obtained from this pool haven't been freed or the pool
        has free operations that haven't completed when
        :py:obj:`~.cuMemPoolDestroy` is invoked, the function will return
        immediately and the resources associated with the pool will be released
        automatically once there are no more outstanding allocations.

        Destroying the current mempool of a device sets the default mempool of
        that device as the current mempool for that device.

        Parameters
        ----------
        pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
            None

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuMemPoolCreate`

        Notes
        -----
        A device's default memory pool cannot be destroyed.
    """


def cuMemPoolExportPointer(ptr):
    """
    cuMemPoolExportPointer(ptr)
     Export data to share a memory pool allocation between processes.

        Constructs `shareData_out` for sharing a specific allocation from an
        already shared memory pool. The recipient process can import the
        allocation with the :py:obj:`~.cuMemPoolImportPointer` api. The data is
        not a handle and may be shared through any IPC mechanism.

        Parameters
        ----------
        ptr : :py:obj:`~.CUdeviceptr`
            pointer to memory being exported

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        shareData_out : :py:obj:`~.CUmemPoolPtrExportData`
            Returned export data

        See Also
        --------
        :py:obj:`~.cuMemPoolExportToShareableHandle`, :py:obj:`~.cuMemPoolImportFromShareableHandle`, :py:obj:`~.cuMemPoolImportPointer`
    """


def cuMemPoolExportToShareableHandle(pool, handleType: 'CUmemAllocationHandleType', flags):
    """
    cuMemPoolExportToShareableHandle(pool, handleType: CUmemAllocationHandleType, unsigned long long flags)
     Exports a memory pool to the requested handle type.

        Given an IPC capable mempool, create an OS handle to share the pool
        with another process. A recipient process can convert the shareable
        handle into a mempool with
        :py:obj:`~.cuMemPoolImportFromShareableHandle`. Individual pointers can
        then be shared with the :py:obj:`~.cuMemPoolExportPointer` and
        :py:obj:`~.cuMemPoolImportPointer` APIs. The implementation of what the
        shareable handle is and how it can be transferred is defined by the
        requested handle type.

        Parameters
        ----------
        pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
            pool to export
        handleType : :py:obj:`~.CUmemAllocationHandleType`
            the type of handle to create
        flags : unsigned long long
            must be 0

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        handle_out : Any
            Returned OS handle

        See Also
        --------
        :py:obj:`~.cuMemPoolImportFromShareableHandle`, :py:obj:`~.cuMemPoolExportPointer`, :py:obj:`~.cuMemPoolImportPointer`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuMemPoolSetAttribute`

        Notes
        -----
        : To create an IPC capable mempool, create a mempool with a CUmemAllocationHandleType other than CU_MEM_HANDLE_TYPE_NONE.
    """


def cuMemPoolGetAccess(memPool, location: 'Optional[CUmemLocation]'):
    """
    cuMemPoolGetAccess(memPool, CUmemLocation location: Optional[CUmemLocation])
     Returns the accessibility of a pool from a device.

        Returns the accessibility of the pool's memory from the specified
        location.

        Parameters
        ----------
        memPool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
            the pool being queried
        location : :py:obj:`~.CUmemLocation`
            the location accessing the pool

        Returns
        -------
        CUresult

        flags : :py:obj:`~.CUmemAccess_flags`
            the accessibility of the pool from the specified location

        See Also
        --------
        :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """


def cuMemPoolGetAttribute(pool, attr: 'CUmemPool_attribute'):
    """
    cuMemPoolGetAttribute(pool, attr: CUmemPool_attribute)
     Gets attributes of a memory pool.

        Supported attributes are:

        - :py:obj:`~.CU_MEMPOOL_ATTR_RELEASE_THRESHOLD`: (value type =
          cuuint64_t) Amount of reserved memory in bytes to hold onto before
          trying to release memory back to the OS. When more than the release
          threshold bytes of memory are held by the memory pool, the allocator
          will try to release memory back to the OS on the next call to stream,
          event or context synchronize. (default 0)

        - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES`: (value
          type = int) Allow :py:obj:`~.cuMemAllocAsync` to use memory
          asynchronously freed in another stream as long as a stream ordering
          dependency of the allocating stream on the free action exists. Cuda
          events and null stream interactions can create the required stream
          ordered dependencies. (default enabled)

        - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC`: (value type =
          int) Allow reuse of already completed frees when there is no
          dependency between the free and allocation. (default enabled)

        - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES`: (value
          type = int) Allow :py:obj:`~.cuMemAllocAsync` to insert new stream
          dependencies in order to establish the stream ordering required to
          reuse a piece of memory released by :py:obj:`~.cuMemFreeAsync`
          (default enabled).

        - :py:obj:`~.CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT`: (value type =
          cuuint64_t) Amount of backing memory currently allocated for the
          mempool

        - :py:obj:`~.CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH`: (value type =
          cuuint64_t) High watermark of backing memory allocated for the
          mempool since the last time it was reset.

        - :py:obj:`~.CU_MEMPOOL_ATTR_USED_MEM_CURRENT`: (value type =
          cuuint64_t) Amount of memory from the pool that is currently in use
          by the application.

        - :py:obj:`~.CU_MEMPOOL_ATTR_USED_MEM_HIGH`: (value type = cuuint64_t)
          High watermark of the amount of memory from the pool that was in use
          by the application.

        Parameters
        ----------
        pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
            The memory pool to get attributes of
        attr : :py:obj:`~.CUmemPool_attribute`
            The attribute to get

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        value : Any
            Retrieved value

        See Also
        --------
        :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """


def cuMemPoolImportFromShareableHandle(handle, handleType: 'CUmemAllocationHandleType', flags):
    """
    cuMemPoolImportFromShareableHandle(handle, handleType: CUmemAllocationHandleType, unsigned long long flags)
     imports a memory pool from a shared handle.

        Specific allocations can be imported from the imported pool with
        cuMemPoolImportPointer.

        If `handleType` is :py:obj:`~.CU_MEM_HANDLE_TYPE_FABRIC` and the
        importer process has not been granted access to the same IMEX channel
        as the exporter process, this API will error as
        :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`.

        Parameters
        ----------
        handle : Any
            OS handle of the pool to open
        handleType : :py:obj:`~.CUmemAllocationHandleType`
            The type of handle being imported
        flags : unsigned long long
            must be 0

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        pool_out : :py:obj:`~.CUmemoryPool`
            Returned memory pool

        See Also
        --------
        :py:obj:`~.cuMemPoolExportToShareableHandle`, :py:obj:`~.cuMemPoolExportPointer`, :py:obj:`~.cuMemPoolImportPointer`

        Notes
        -----
        Imported memory pools do not support creating new allocations. As such imported memory pools may not be used in cuDeviceSetMemPool or :py:obj:`~.cuMemAllocFromPoolAsync` calls.
    """


def cuMemPoolImportPointer(pool, shareData: 'Optional[CUmemPoolPtrExportData]'):
    """
    cuMemPoolImportPointer(pool, CUmemPoolPtrExportData shareData: Optional[CUmemPoolPtrExportData])
     Import a memory pool allocation from another process.

        Returns in `ptr_out` a pointer to the imported memory. The imported
        memory must not be accessed before the allocation operation completes
        in the exporting process. The imported memory must be freed from all
        importing processes before being freed in the exporting process. The
        pointer may be freed with cuMemFree or cuMemFreeAsync. If
        cuMemFreeAsync is used, the free must be completed on the importing
        process before the free operation on the exporting process.

        Parameters
        ----------
        pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
            pool from which to import
        shareData : :py:obj:`~.CUmemPoolPtrExportData`
            data specifying the memory to import

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        ptr_out : :py:obj:`~.CUdeviceptr`
            pointer to imported memory

        See Also
        --------
        :py:obj:`~.cuMemPoolExportToShareableHandle`, :py:obj:`~.cuMemPoolImportFromShareableHandle`, :py:obj:`~.cuMemPoolExportPointer`

        Notes
        -----
        The cuMemFreeAsync api may be used in the exporting process before the cuMemFreeAsync operation completes in its stream as long as the cuMemFreeAsync in the exporting process specifies a stream with a stream dependency on the importing process's cuMemFreeAsync.
    """


def cuMemPoolSetAccess(pool, map: 'Optional[Tuple[CUmemAccessDesc] | List[CUmemAccessDesc]]', count):
    """
    cuMemPoolSetAccess(pool, map: Optional[Tuple[CUmemAccessDesc] | List[CUmemAccessDesc]], size_t count)
     Controls visibility of pools between devices.

        Parameters
        ----------
        pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
            The pool being modified
        map : List[:py:obj:`~.CUmemAccessDesc`]
            Array of access descriptors. Each descriptor instructs the access
            to enable for a single gpu.
        count : size_t
            Number of descriptors in the map array.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """


def cuMemPoolSetAttribute(pool, attr: 'CUmemPool_attribute', value):
    """
    cuMemPoolSetAttribute(pool, attr: CUmemPool_attribute, value)
     Sets attributes of a memory pool.

        Supported attributes are:

        - :py:obj:`~.CU_MEMPOOL_ATTR_RELEASE_THRESHOLD`: (value type =
          cuuint64_t) Amount of reserved memory in bytes to hold onto before
          trying to release memory back to the OS. When more than the release
          threshold bytes of memory are held by the memory pool, the allocator
          will try to release memory back to the OS on the next call to stream,
          event or context synchronize. (default 0)

        - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES`: (value
          type = int) Allow :py:obj:`~.cuMemAllocAsync` to use memory
          asynchronously freed in another stream as long as a stream ordering
          dependency of the allocating stream on the free action exists. Cuda
          events and null stream interactions can create the required stream
          ordered dependencies. (default enabled)

        - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC`: (value type =
          int) Allow reuse of already completed frees when there is no
          dependency between the free and allocation. (default enabled)

        - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES`: (value
          type = int) Allow :py:obj:`~.cuMemAllocAsync` to insert new stream
          dependencies in order to establish the stream ordering required to
          reuse a piece of memory released by :py:obj:`~.cuMemFreeAsync`
          (default enabled).

        - :py:obj:`~.CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH`: (value type =
          cuuint64_t) Reset the high watermark that tracks the amount of
          backing memory that was allocated for the memory pool. It is illegal
          to set this attribute to a non-zero value.

        - :py:obj:`~.CU_MEMPOOL_ATTR_USED_MEM_HIGH`: (value type = cuuint64_t)
          Reset the high watermark that tracks the amount of used memory that
          was allocated for the memory pool.

        Parameters
        ----------
        pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
            The memory pool to modify
        attr : :py:obj:`~.CUmemPool_attribute`
            The attribute to modify
        value : Any
            Pointer to the value to assign

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """


def cuMemPoolTrimTo(pool, minBytesToKeep):
    """
    cuMemPoolTrimTo(pool, size_t minBytesToKeep)
     Tries to release memory back to the OS.

        Releases memory back to the OS until the pool contains fewer than
        minBytesToKeep reserved bytes, or there is no more memory that the
        allocator can safely release. The allocator cannot release OS
        allocations that back outstanding asynchronous allocations. The OS
        allocations may happen at different granularity from the user
        allocations.

        Parameters
        ----------
        pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
            The memory pool to trim
        minBytesToKeep : size_t
            If the pool has less than minBytesToKeep reserved, the TrimTo
            operation is a no-op. Otherwise the pool will be guaranteed to have
            at least minBytesToKeep bytes reserved after the operation.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`

        Notes
        -----
        : Allocations that have not been freed count as outstanding.

        : Allocations that have been asynchronously freed but whose completion has not been observed on the host (eg. by a synchronize) can count as outstanding.
    """


def cuMemPrefetchAsync(devPtr, count, dstDevice, hStream):
    """
    cuMemPrefetchAsync(devPtr, size_t count, dstDevice, hStream)
     Prefetches memory to the specified destination device.

        Note there is a later version of this API,
        :py:obj:`~.cuMemPrefetchAsync_v2`. It will supplant this version in
        13.0, which is retained for minor version compatibility.

        Prefetches memory to the specified destination device. `devPtr` is the
        base device pointer of the memory to be prefetched and `dstDevice` is
        the destination device. `count` specifies the number of bytes to copy.
        `hStream` is the stream in which the operation is enqueued. The memory
        range must refer to managed memory allocated via
        :py:obj:`~.cuMemAllocManaged` or declared via managed variables or it
        may also refer to system-allocated memory on systems with non-zero
        CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS.

        Passing in CU_DEVICE_CPU for `dstDevice` will prefetch the data to host
        memory. If `dstDevice` is a GPU, then the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` must be non-
        zero. Additionally, `hStream` must be associated with a device that has
        a non-zero value for the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`.

        The start address and end address of the memory range will be rounded
        down and rounded up respectively to be aligned to CPU page size before
        the prefetch operation is enqueued in the stream.

        If no physical memory has been allocated for this region, then this
        memory region will be populated and mapped on the destination device.
        If there's insufficient memory to prefetch the desired region, the
        Unified Memory driver may evict pages from other
        :py:obj:`~.cuMemAllocManaged` allocations to host memory in order to
        make room. Device memory allocated using :py:obj:`~.cuMemAlloc` or
        :py:obj:`~.cuArrayCreate` will not be evicted.

        By default, any mappings to the previous location of the migrated pages
        are removed and mappings for the new location are only setup on
        `dstDevice`. The exact behavior however also depends on the settings
        applied to this memory range via :py:obj:`~.cuMemAdvise` as described
        below:

        If :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` was set on any subset of
        this memory range, then that subset will create a read-only copy of the
        pages on `dstDevice`.

        If :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` was called on any
        subset of this memory range, then the pages will be migrated to
        `dstDevice` even if `dstDevice` is not the preferred location of any
        pages in the memory range.

        If :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` was called on any subset
        of this memory range, then mappings to those pages from all the
        appropriate processors are updated to refer to the new location if
        establishing such a mapping is possible. Otherwise, those mappings are
        cleared.

        Note that this API is not required for functionality and only serves to
        improve performance by allowing the application to migrate data to a
        suitable location before it is accessed. Memory accesses to this range
        are always coherent and are allowed even when the data is actively
        being migrated.

        Note that this function is asynchronous with respect to the host and
        all work on other devices.

        Parameters
        ----------
        devPtr : :py:obj:`~.CUdeviceptr`
            Pointer to be prefetched
        count : size_t
            Size in bytes
        dstDevice : :py:obj:`~.CUdevice`
            Destination device to prefetch to
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to enqueue prefetch operation

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

        See Also
        --------
        :py:obj:`~.cuMemcpy`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cuMemAdvise`, :py:obj:`~.cuMemPrefetchAsync` :py:obj:`~.cudaMemPrefetchAsync_v2`
    """


def cuMemPrefetchAsync_v2(devPtr, count, location: 'CUmemLocation', flags, hStream):
    """
    cuMemPrefetchAsync_v2(devPtr, size_t count, CUmemLocation location: CUmemLocation, unsigned int flags, hStream)
     Prefetches memory to the specified destination location.

        Prefetches memory to the specified destination location. `devPtr` is
        the base device pointer of the memory to be prefetched and `location`
        specifies the destination location. `count` specifies the number of
        bytes to copy. `hStream` is the stream in which the operation is
        enqueued. The memory range must refer to managed memory allocated via
        :py:obj:`~.cuMemAllocManaged` or declared via managed variables.

        Specifying :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` for
        :py:obj:`~.CUmemLocation.type` will prefetch memory to GPU specified by
        device ordinal :py:obj:`~.CUmemLocation.id` which must have non-zero
        value for the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`.
        Additionally, `hStream` must be associated with a device that has a
        non-zero value for the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Specifying
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` as :py:obj:`~.CUmemLocation.type`
        will prefetch data to host memory. Applications can request prefetching
        memory to a specific host NUMA node by specifying
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` for
        :py:obj:`~.CUmemLocation.type` and a valid host NUMA node id in
        :py:obj:`~.CUmemLocation.id` Users can also request prefetching memory
        to the host NUMA node closest to the current thread's CPU by specifying
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT` for
        :py:obj:`~.CUmemLocation.type`. Note when
        :py:obj:`~.CUmemLocation.type` is etiher
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` OR
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT`,
        :py:obj:`~.CUmemLocation.id` will be ignored.

        The start address and end address of the memory range will be rounded
        down and rounded up respectively to be aligned to CPU page size before
        the prefetch operation is enqueued in the stream.

        If no physical memory has been allocated for this region, then this
        memory region will be populated and mapped on the destination device.
        If there's insufficient memory to prefetch the desired region, the
        Unified Memory driver may evict pages from other
        :py:obj:`~.cuMemAllocManaged` allocations to host memory in order to
        make room. Device memory allocated using :py:obj:`~.cuMemAlloc` or
        :py:obj:`~.cuArrayCreate` will not be evicted.

        By default, any mappings to the previous location of the migrated pages
        are removed and mappings for the new location are only setup on the
        destination location. The exact behavior however also depends on the
        settings applied to this memory range via :py:obj:`~.cuMemAdvise` as
        described below:

        If :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` was set on any subset of
        this memory range, then that subset will create a read-only copy of the
        pages on destination location. If however the destination location is a
        host NUMA node, then any pages of that subset that are already in
        another host NUMA node will be transferred to the destination.

        If :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` was called on any
        subset of this memory range, then the pages will be migrated to
        `location` even if `location` is not the preferred location of any
        pages in the memory range.

        If :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` was called on any subset
        of this memory range, then mappings to those pages from all the
        appropriate processors are updated to refer to the new location if
        establishing such a mapping is possible. Otherwise, those mappings are
        cleared.

        Note that this API is not required for functionality and only serves to
        improve performance by allowing the application to migrate data to a
        suitable location before it is accessed. Memory accesses to this range
        are always coherent and are allowed even when the data is actively
        being migrated.

        Note that this function is asynchronous with respect to the host and
        all work on other devices.

        Parameters
        ----------
        devPtr : :py:obj:`~.CUdeviceptr`
            Pointer to be prefetched
        count : size_t
            Size in bytes
        dstDevice : :py:obj:`~.CUmemLocation`
            Destination device to prefetch to
        flags : unsigned int
            flags for future use, must be zero now.
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to enqueue prefetch operation

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

        See Also
        --------
        :py:obj:`~.cuMemcpy`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cuMemAdvise`, :py:obj:`~.cuMemPrefetchAsync` :py:obj:`~.cudaMemPrefetchAsync_v2`
    """


def cuMemRangeGetAttribute(dataSize, attribute: 'CUmem_range_attribute', devPtr, count):
    """
    cuMemRangeGetAttribute(size_t dataSize, attribute: CUmem_range_attribute, devPtr, size_t count)
     Query an attribute of a given memory range.

        Query an attribute about the memory range starting at `devPtr` with a
        size of `count` bytes. The memory range must refer to managed memory
        allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
        variables.

        The `attribute` parameter can take the following values:

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY`: If this attribute is
          specified, `data` will be interpreted as a 32-bit integer, and
          `dataSize` must be 4. The result returned will be 1 if all pages in
          the given memory range have read-duplication enabled, or 0 otherwise.

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION`: If this
          attribute is specified, `data` will be interpreted as a 32-bit
          integer, and `dataSize` must be 4. The result returned will be a GPU
          device id if all pages in the memory range have that GPU as their
          preferred location, or it will be CU_DEVICE_CPU if all pages in the
          memory range have the CPU as their preferred location, or it will be
          CU_DEVICE_INVALID if either all the pages don't have the same
          preferred location or some of the pages don't have a preferred
          location at all. Note that the actual location of the pages in the
          memory range at the time of the query may be different from the
          preferred location.

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY`: If this attribute is
          specified, `data` will be interpreted as an array of 32-bit integers,
          and `dataSize` must be a non-zero multiple of 4. The result returned
          will be a list of device ids that had
          :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` set for that entire memory
          range. If any device does not have that advice set for the entire
          memory range, that device will not be included. If `data` is larger
          than the number of devices that have that advice set for that memory
          range, CU_DEVICE_INVALID will be returned in all the extra space
          provided. For ex., if `dataSize` is 12 (i.e. `data` has 3 elements)
          and only device 0 has the advice set, then the result returned will
          be { 0, CU_DEVICE_INVALID, CU_DEVICE_INVALID }. If `data` is smaller
          than the number of devices that have that advice set, then only as
          many devices will be returned as can fit in the array. There is no
          guarantee on which specific devices will be returned, however.

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION`: If this
          attribute is specified, `data` will be interpreted as a 32-bit
          integer, and `dataSize` must be 4. The result returned will be the
          last location to which all pages in the memory range were prefetched
          explicitly via :py:obj:`~.cuMemPrefetchAsync`. This will either be a
          GPU id or CU_DEVICE_CPU depending on whether the last location for
          prefetch was a GPU or the CPU respectively. If any page in the memory
          range was never explicitly prefetched or if all pages were not
          prefetched to the same location, CU_DEVICE_INVALID will be returned.
          Note that this simply returns the last location that the application
          requested to prefetch the memory range to. It gives no indication as
          to whether the prefetch operation to that location has completed or
          even begun.

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE`: If this
          attribute is specified, `data` will be interpreted as a
          :py:obj:`~.CUmemLocationType`, and `dataSize` must be
          sizeof(CUmemLocationType). The :py:obj:`~.CUmemLocationType` returned
          will be :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` if all pages in the
          memory range have the same GPU as their preferred location, or
          :py:obj:`~.CUmemLocationType` will be
          :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` if all pages in the memory
          range have the CPU as their preferred location, or it will be
          :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` if all the pages in the
          memory range have the same host NUMA node ID as their preferred
          location or it will be :py:obj:`~.CU_MEM_LOCATION_TYPE_INVALID` if
          either all the pages don't have the same preferred location or some
          of the pages don't have a preferred location at all. Note that the
          actual location type of the pages in the memory range at the time of
          the query may be different from the preferred location type.

          - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID`: If this
            attribute is specified, `data` will be interpreted as a 32-bit
            integer, and `dataSize` must be 4. If the
            :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE` query
            for the same address range returns
            :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE`, it will be a valid device
            ordinal or if it returns
            :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA`, it will be a valid host
            NUMA node ID or if it returns any other location type, the id
            should be ignored.

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE`: If
          this attribute is specified, `data` will be interpreted as a
          :py:obj:`~.CUmemLocationType`, and `dataSize` must be
          sizeof(CUmemLocationType). The result returned will be the last
          location to which all pages in the memory range were prefetched
          explicitly via :py:obj:`~.cuMemPrefetchAsync`. The
          :py:obj:`~.CUmemLocationType` returned will be
          :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` if the last prefetch location
          was a GPU or :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` if it was the CPU
          or :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` if the last prefetch
          location was a specific host NUMA node. If any page in the memory
          range was never explicitly prefetched or if all pages were not
          prefetched to the same location, :py:obj:`~.CUmemLocationType` will
          be :py:obj:`~.CU_MEM_LOCATION_TYPE_INVALID`. Note that this simply
          returns the last location type that the application requested to
          prefetch the memory range to. It gives no indication as to whether
          the prefetch operation to that location has completed or even begun.

          - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID`: If
            this attribute is specified, `data` will be interpreted as a 32-bit
            integer, and `dataSize` must be 4. If the
            :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE`
            query for the same address range returns
            :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE`, it will be a valid device
            ordinal or if it returns
            :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA`, it will be a valid host
            NUMA node ID or if it returns any other location type, the id
            should be ignored.

        Parameters
        ----------
        dataSize : size_t
            Array containing the size of data
        attribute : :py:obj:`~.CUmem_range_attribute`
            The attribute to query
        devPtr : :py:obj:`~.CUdeviceptr`
            Start of the range to query
        count : size_t
            Size of the range to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        data : Any
            A pointers to a memory location where the result of each attribute
            query will be written to.

        See Also
        --------
        :py:obj:`~.cuMemRangeGetAttributes`, :py:obj:`~.cuMemPrefetchAsync`, :py:obj:`~.cuMemAdvise`, :py:obj:`~.cudaMemRangeGetAttribute`
    """


def cuMemRangeGetAttributes(dataSizes: 'Tuple[int] | List[int]', attributes: 'Optional[Tuple[CUmem_range_attribute] | List[CUmem_range_attribute]]', numAttributes, devPtr, count):
    """
    cuMemRangeGetAttributes(dataSizes: Tuple[int] | List[int], attributes: Optional[Tuple[CUmem_range_attribute] | List[CUmem_range_attribute]], size_t numAttributes, devPtr, size_t count)
     Query attributes of a given memory range.

        Query attributes of the memory range starting at `devPtr` with a size
        of `count` bytes. The memory range must refer to managed memory
        allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
        variables. The `attributes` array will be interpreted to have
        `numAttributes` entries. The `dataSizes` array will also be interpreted
        to have `numAttributes` entries. The results of the query will be
        stored in `data`.

        The list of supported attributes are given below. Please refer to
        :py:obj:`~.cuMemRangeGetAttribute` for attribute descriptions and
        restrictions.

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY`

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION`

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY`

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION`

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE`

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID`

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE`

        - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID`

        Parameters
        ----------
        dataSizes : List[int]
            Array containing the sizes of each result
        attributes : List[:py:obj:`~.CUmem_range_attribute`]
            An array of attributes to query (numAttributes and the number of
            attributes in this array should match)
        numAttributes : size_t
            Number of attributes to query
        devPtr : :py:obj:`~.CUdeviceptr`
            Start of the range to query
        count : size_t
            Size of the range to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        data : List[Any]
            A two-dimensional array containing pointers to memory locations
            where the result of each attribute query will be written to.

        See Also
        --------
        :py:obj:`~.cuMemRangeGetAttribute`, :py:obj:`~.cuMemAdvise`, :py:obj:`~.cuMemPrefetchAsync`, :py:obj:`~.cudaMemRangeGetAttributes`
    """


def cuMemRelease(handle):
    """
    cuMemRelease(handle)
     Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate.

        Frees the memory that was allocated on a device through cuMemCreate.

        The memory allocation will be freed when all outstanding mappings to
        the memory are unmapped and when all outstanding references to the
        handle (including it's shareable counterparts) are also released. The
        generic memory handle can be freed when there are still outstanding
        mappings made with this handle. Each time a recipient process imports a
        shareable handle, it needs to pair it with :py:obj:`~.cuMemRelease` for
        the handle to be freed. If `handle` is not a valid handle the behavior
        is undefined.

        Parameters
        ----------
        handle : :py:obj:`~.CUmemGenericAllocationHandle`
            Value of handle which was returned previously by cuMemCreate.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuMemCreate`
    """


def cuMemRetainAllocationHandle(addr):
    """
    cuMemRetainAllocationHandle(addr)
     Given an address `addr`, returns the allocation handle of the backing memory allocation.

        The handle is guaranteed to be the same handle value used to map the
        memory. If the address requested is not mapped, the function will fail.
        The returned handle must be released with corresponding number of calls
        to :py:obj:`~.cuMemRelease`.

        Parameters
        ----------
        addr : Any
            Memory address to query, that has been mapped previously.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        handle : :py:obj:`~.CUmemGenericAllocationHandle`
            CUDA Memory handle for the backing memory allocation.

        See Also
        --------
        :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemRelease`, :py:obj:`~.cuMemMap`

        Notes
        -----
        The address `addr`, can be any address in a range previously mapped by :py:obj:`~.cuMemMap`, and not necessarily the start address.
    """


def cuMemSetAccess(ptr, size, desc: 'Optional[Tuple[CUmemAccessDesc] | List[CUmemAccessDesc]]', count):
    """
    cuMemSetAccess(ptr, size_t size, desc: Optional[Tuple[CUmemAccessDesc] | List[CUmemAccessDesc]], size_t count)
     Set the access flags for each location specified in `desc` for the given virtual address range.

        Given the virtual address range via `ptr` and `size`, and the locations
        in the array given by `desc` and `count`, set the access flags for the
        target locations. The range must be a fully mapped address range
        containing all allocations created by :py:obj:`~.cuMemMap` /
        :py:obj:`~.cuMemCreate`. Users cannot specify
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` accessibility for
        allocations created on with other location types. Note: When
        :py:obj:`~.CUmemAccessDesc`::CUmemLocation::type is
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA`,
        :py:obj:`~.CUmemAccessDesc`::CUmemLocation::id is ignored. When setting
        the access flags for a virtual address range mapping a multicast
        object, `ptr` and `size` must be aligned to the value returned by
        :py:obj:`~.cuMulticastGetGranularity` with the flag
        :py:obj:`~.CU_MULTICAST_MINIMUM_GRANULARITY`. For best performance
        however, it is recommended that `ptr` and `size` be aligned to the
        value returned by :py:obj:`~.cuMulticastGetGranularity` with the flag
        :py:obj:`~.CU_MULTICAST_RECOMMENDED_GRANULARITY`.

        Parameters
        ----------
        ptr : :py:obj:`~.CUdeviceptr`
            Starting address for the virtual address range
        size : size_t
            Length of the virtual address range
        desc : List[:py:obj:`~.CUmemAccessDesc`]
            Array of :py:obj:`~.CUmemAccessDesc` that describe how to change
            the
        count : size_t
            Number of :py:obj:`~.CUmemAccessDesc` in `desc`

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuMemSetAccess`, :py:obj:`~.cuMemCreate`, :py:obj:`~.py`:obj:`~.cuMemMap`
    """


def cuMemUnmap(ptr, size):
    """
    cuMemUnmap(ptr, size_t size)
     Unmap the backing memory of a given address range.

        The range must be the entire contiguous address range that was mapped
        to. In other words, :py:obj:`~.cuMemUnmap` cannot unmap a sub-range of
        an address range mapped by :py:obj:`~.cuMemCreate` /
        :py:obj:`~.cuMemMap`. Any backing memory allocations will be freed if
        there are no existing mappings and there are no unreleased memory
        handles.

        When :py:obj:`~.cuMemUnmap` returns successfully the address range is
        converted to an address reservation and can be used for a future calls
        to :py:obj:`~.cuMemMap`. Any new mapping to this virtual address will
        need to have access granted through :py:obj:`~.cuMemSetAccess`, as all
        mappings start with no accessibility setup.

        Parameters
        ----------
        ptr : :py:obj:`~.CUdeviceptr`
            Starting address for the virtual address range to unmap
        size : size_t
            Size of the virtual address range to unmap

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemAddressReserve`
    """


def cuMemcpy(dst, src, ByteCount):
    """
    cuMemcpy(dst, src, size_t ByteCount)
     Copies memory.

        Copies data between two pointers. `dst` and `src` are base pointers of
        the destination and source, respectively. `ByteCount` specifies the
        number of bytes to copy. Note that this function infers the type of the
        transfer (host to host, host to device, device to device, or device to
        host) from the pointer values. This function is only allowed in
        contexts which support unified addressing.

        Parameters
        ----------
        dst : :py:obj:`~.CUdeviceptr`
            Destination unified virtual address space pointer
        src : :py:obj:`~.CUdeviceptr`
            Source unified virtual address space pointer
        ByteCount : size_t
            Size of memory copy in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`
    """


def cuMemcpy2D(pCopy: 'Optional[CUDA_MEMCPY2D]'):
    """
    cuMemcpy2D(CUDA_MEMCPY2D pCopy: Optional[CUDA_MEMCPY2D])
     Copies memory for 2D arrays.

        Perform a 2D memory copy according to the parameters specified in
        `pCopy`. The :py:obj:`~.CUDA_MEMCPY2D` structure is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
          type of memory of the source and destination, respectively;
          :py:obj:`~.CUmemorytype_enum` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
        :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
        virtual address space) base address of the source data and the bytes
        per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
        used only if unified addressing is supported in the calling context.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
        :py:obj:`~.srcHost` and :py:obj:`~.srcPitch` specify the (host) base
        address of the source data and the bytes per row to apply.
        :py:obj:`~.srcArray` is ignored.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
        :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (device)
        base address of the source data and the bytes per row to apply.
        :py:obj:`~.srcArray` is ignored.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
        :py:obj:`~.srcArray` specifies the handle of the source data.
        :py:obj:`~.srcHost`, :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` are
        ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
        :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
        address of the destination data and the bytes per row to apply.
        :py:obj:`~.dstArray` is ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
        :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
        virtual address space) base address of the source data and the bytes
        per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
        used only if unified addressing is supported in the calling context.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
        :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
        base address of the destination data and the bytes per row to apply.
        :py:obj:`~.dstArray` is ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
        :py:obj:`~.dstArray` specifies the handle of the destination data.
        :py:obj:`~.dstHost`, :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` are
        ignored.

        - :py:obj:`~.srcXInBytes` and :py:obj:`~.srcY` specify the base address
          of the source data for the copy.

        For host pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For device pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
        the array element size.

        - :py:obj:`~.dstXInBytes` and :py:obj:`~.dstY` specify the base address
          of the destination data for the copy.

        For host pointers, the base address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For device pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
        the array element size.

        - :py:obj:`~.WidthInBytes` and :py:obj:`~.Height` specify the width (in
          bytes) and height of the 2D copy being performed.

        - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
          :py:obj:`~.dstPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + dstXInBytes.

        :py:obj:`~.cuMemcpy2D()` returns an error if any pitch is greater than
        the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).
        :py:obj:`~.cuMemAllocPitch()` passes back pitches that always work with
        :py:obj:`~.cuMemcpy2D()`. On intra-device memory copies (device to
        device, CUDA array to device, CUDA array to CUDA array),
        :py:obj:`~.cuMemcpy2D()` may fail for pitches not computed by
        :py:obj:`~.cuMemAllocPitch()`. :py:obj:`~.cuMemcpy2DUnaligned()` does
        not have this restriction, but may run significantly slower in the
        cases where :py:obj:`~.cuMemcpy2D()` would have returned an error code.

        Parameters
        ----------
        pCopy : :py:obj:`~.CUDA_MEMCPY2D`
            Parameters for the memory copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`
    """


def cuMemcpy2DAsync(pCopy: 'Optional[CUDA_MEMCPY2D]', hStream):
    """
    cuMemcpy2DAsync(CUDA_MEMCPY2D pCopy: Optional[CUDA_MEMCPY2D], hStream)
     Copies memory for 2D arrays.

        Perform a 2D memory copy according to the parameters specified in
        `pCopy`. The :py:obj:`~.CUDA_MEMCPY2D` structure is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
          type of memory of the source and destination, respectively;
          :py:obj:`~.CUmemorytype_enum` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
        :py:obj:`~.srcHost` and :py:obj:`~.srcPitch` specify the (host) base
        address of the source data and the bytes per row to apply.
        :py:obj:`~.srcArray` is ignored.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
        :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
        virtual address space) base address of the source data and the bytes
        per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
        used only if unified addressing is supported in the calling context.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
        :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (device)
        base address of the source data and the bytes per row to apply.
        :py:obj:`~.srcArray` is ignored.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
        :py:obj:`~.srcArray` specifies the handle of the source data.
        :py:obj:`~.srcHost`, :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` are
        ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
        :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
        virtual address space) base address of the source data and the bytes
        per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
        used only if unified addressing is supported in the calling context.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
        :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
        address of the destination data and the bytes per row to apply.
        :py:obj:`~.dstArray` is ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
        :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
        base address of the destination data and the bytes per row to apply.
        :py:obj:`~.dstArray` is ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
        :py:obj:`~.dstArray` specifies the handle of the destination data.
        :py:obj:`~.dstHost`, :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` are
        ignored.

        - :py:obj:`~.srcXInBytes` and :py:obj:`~.srcY` specify the base address
          of the source data for the copy.

        For host pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For device pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
        the array element size.

        - :py:obj:`~.dstXInBytes` and :py:obj:`~.dstY` specify the base address
          of the destination data for the copy.

        For host pointers, the base address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For device pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
        the array element size.

        - :py:obj:`~.WidthInBytes` and :py:obj:`~.Height` specify the width (in
          bytes) and height of the 2D copy being performed.

        - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
          :py:obj:`~.dstPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + dstXInBytes.

        - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
          :py:obj:`~.dstPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + dstXInBytes.

        - If specified, :py:obj:`~.srcHeight` must be greater than or equal to
          :py:obj:`~.Height` + :py:obj:`~.srcY`, and :py:obj:`~.dstHeight` must
          be greater than or equal to :py:obj:`~.Height` + :py:obj:`~.dstY`.

        :py:obj:`~.cuMemcpy2DAsync()` returns an error if any pitch is greater
        than the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).
        :py:obj:`~.cuMemAllocPitch()` passes back pitches that always work with
        :py:obj:`~.cuMemcpy2D()`. On intra-device memory copies (device to
        device, CUDA array to device, CUDA array to CUDA array),
        :py:obj:`~.cuMemcpy2DAsync()` may fail for pitches not computed by
        :py:obj:`~.cuMemAllocPitch()`.

        Parameters
        ----------
        pCopy : :py:obj:`~.CUDA_MEMCPY2D`
            Parameters for the memory copy
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`
    """


def cuMemcpy2DUnaligned(pCopy: 'Optional[CUDA_MEMCPY2D]'):
    """
    cuMemcpy2DUnaligned(CUDA_MEMCPY2D pCopy: Optional[CUDA_MEMCPY2D])
     Copies memory for 2D arrays.

        Perform a 2D memory copy according to the parameters specified in
        `pCopy`. The :py:obj:`~.CUDA_MEMCPY2D` structure is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
          type of memory of the source and destination, respectively;
          :py:obj:`~.CUmemorytype_enum` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
        :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
        virtual address space) base address of the source data and the bytes
        per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
        used only if unified addressing is supported in the calling context.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
        :py:obj:`~.srcHost` and :py:obj:`~.srcPitch` specify the (host) base
        address of the source data and the bytes per row to apply.
        :py:obj:`~.srcArray` is ignored.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
        :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (device)
        base address of the source data and the bytes per row to apply.
        :py:obj:`~.srcArray` is ignored.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
        :py:obj:`~.srcArray` specifies the handle of the source data.
        :py:obj:`~.srcHost`, :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` are
        ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
        :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
        virtual address space) base address of the source data and the bytes
        per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
        used only if unified addressing is supported in the calling context.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
        :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
        address of the destination data and the bytes per row to apply.
        :py:obj:`~.dstArray` is ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
        :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
        base address of the destination data and the bytes per row to apply.
        :py:obj:`~.dstArray` is ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
        :py:obj:`~.dstArray` specifies the handle of the destination data.
        :py:obj:`~.dstHost`, :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` are
        ignored.

        - :py:obj:`~.srcXInBytes` and :py:obj:`~.srcY` specify the base address
          of the source data for the copy.

        For host pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For device pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
        the array element size.

        - :py:obj:`~.dstXInBytes` and :py:obj:`~.dstY` specify the base address
          of the destination data for the copy.

        For host pointers, the base address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For device pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
        the array element size.

        - :py:obj:`~.WidthInBytes` and :py:obj:`~.Height` specify the width (in
          bytes) and height of the 2D copy being performed.

        - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
          :py:obj:`~.dstPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + dstXInBytes.

        :py:obj:`~.cuMemcpy2D()` returns an error if any pitch is greater than
        the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).
        :py:obj:`~.cuMemAllocPitch()` passes back pitches that always work with
        :py:obj:`~.cuMemcpy2D()`. On intra-device memory copies (device to
        device, CUDA array to device, CUDA array to CUDA array),
        :py:obj:`~.cuMemcpy2D()` may fail for pitches not computed by
        :py:obj:`~.cuMemAllocPitch()`. :py:obj:`~.cuMemcpy2DUnaligned()` does
        not have this restriction, but may run significantly slower in the
        cases where :py:obj:`~.cuMemcpy2D()` would have returned an error code.

        Parameters
        ----------
        pCopy : :py:obj:`~.CUDA_MEMCPY2D`
            Parameters for the memory copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`
    """


def cuMemcpy3D(pCopy: 'Optional[CUDA_MEMCPY3D]'):
    """
    cuMemcpy3D(CUDA_MEMCPY3D pCopy: Optional[CUDA_MEMCPY3D])
     Copies memory for 3D arrays.

        Perform a 3D memory copy according to the parameters specified in
        `pCopy`. The :py:obj:`~.CUDA_MEMCPY3D` structure is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
          type of memory of the source and destination, respectively;
          :py:obj:`~.CUmemorytype_enum` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
        :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
        virtual address space) base address of the source data and the bytes
        per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
        used only if unified addressing is supported in the calling context.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
        :py:obj:`~.srcHost`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
        specify the (host) base address of the source data, the bytes per row,
        and the height of each 2D slice of the 3D array. :py:obj:`~.srcArray`
        is ignored.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
        :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
        specify the (device) base address of the source data, the bytes per
        row, and the height of each 2D slice of the 3D array.
        :py:obj:`~.srcArray` is ignored.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
        :py:obj:`~.srcArray` specifies the handle of the source data.
        :py:obj:`~.srcHost`, :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and
        :py:obj:`~.srcHeight` are ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
        :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
        virtual address space) base address of the source data and the bytes
        per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
        used only if unified addressing is supported in the calling context.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
        :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
        address of the destination data, the bytes per row, and the height of
        each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
        :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
        base address of the destination data, the bytes per row, and the height
        of each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
        :py:obj:`~.dstArray` specifies the handle of the destination data.
        :py:obj:`~.dstHost`, :py:obj:`~.dstDevice`, :py:obj:`~.dstPitch` and
        :py:obj:`~.dstHeight` are ignored.

        - :py:obj:`~.srcXInBytes`, :py:obj:`~.srcY` and :py:obj:`~.srcZ`
          specify the base address of the source data for the copy.

        For host pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For device pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
        the array element size.

        - dstXInBytes, :py:obj:`~.dstY` and :py:obj:`~.dstZ` specify the base
          address of the destination data for the copy.

        For host pointers, the base address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For device pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
        the array element size.

        - :py:obj:`~.WidthInBytes`, :py:obj:`~.Height` and :py:obj:`~.Depth`
          specify the width (in bytes), height and depth of the 3D copy being
          performed.

        - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
          :py:obj:`~.dstPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + dstXInBytes.

        - If specified, :py:obj:`~.srcHeight` must be greater than or equal to
          :py:obj:`~.Height` + :py:obj:`~.srcY`, and :py:obj:`~.dstHeight` must
          be greater than or equal to :py:obj:`~.Height` + :py:obj:`~.dstY`.

        :py:obj:`~.cuMemcpy3D()` returns an error if any pitch is greater than
        the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).

        The :py:obj:`~.srcLOD` and :py:obj:`~.dstLOD` members of the
        :py:obj:`~.CUDA_MEMCPY3D` structure must be set to 0.

        Parameters
        ----------
        pCopy : :py:obj:`~.CUDA_MEMCPY3D`
            Parameters for the memory copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy3D`
    """


def cuMemcpy3DAsync(pCopy: 'Optional[CUDA_MEMCPY3D]', hStream):
    """
    cuMemcpy3DAsync(CUDA_MEMCPY3D pCopy: Optional[CUDA_MEMCPY3D], hStream)
     Copies memory for 3D arrays.

        Perform a 3D memory copy according to the parameters specified in
        `pCopy`. The :py:obj:`~.CUDA_MEMCPY3D` structure is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
          type of memory of the source and destination, respectively;
          :py:obj:`~.CUmemorytype_enum` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
        :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
        virtual address space) base address of the source data and the bytes
        per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
        used only if unified addressing is supported in the calling context.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
        :py:obj:`~.srcHost`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
        specify the (host) base address of the source data, the bytes per row,
        and the height of each 2D slice of the 3D array. :py:obj:`~.srcArray`
        is ignored.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
        :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
        specify the (device) base address of the source data, the bytes per
        row, and the height of each 2D slice of the 3D array.
        :py:obj:`~.srcArray` is ignored.

        If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
        :py:obj:`~.srcArray` specifies the handle of the source data.
        :py:obj:`~.srcHost`, :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and
        :py:obj:`~.srcHeight` are ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
        :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
        virtual address space) base address of the source data and the bytes
        per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
        used only if unified addressing is supported in the calling context.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
        :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
        address of the destination data, the bytes per row, and the height of
        each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
        :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
        base address of the destination data, the bytes per row, and the height
        of each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

        If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
        :py:obj:`~.dstArray` specifies the handle of the destination data.
        :py:obj:`~.dstHost`, :py:obj:`~.dstDevice`, :py:obj:`~.dstPitch` and
        :py:obj:`~.dstHeight` are ignored.

        - :py:obj:`~.srcXInBytes`, :py:obj:`~.srcY` and :py:obj:`~.srcZ`
          specify the base address of the source data for the copy.

        For host pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For device pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
        the array element size.

        - dstXInBytes, :py:obj:`~.dstY` and :py:obj:`~.dstZ` specify the base
          address of the destination data for the copy.

        For host pointers, the base address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For device pointers, the starting address is

        **View CUDA Toolkit Documentation for a C++ code example**

        For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
        the array element size.

        - :py:obj:`~.WidthInBytes`, :py:obj:`~.Height` and :py:obj:`~.Depth`
          specify the width (in bytes), height and depth of the 3D copy being
          performed.

        - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
          :py:obj:`~.dstPitch` must be greater than or equal to
          :py:obj:`~.WidthInBytes` + dstXInBytes.

        - If specified, :py:obj:`~.srcHeight` must be greater than or equal to
          :py:obj:`~.Height` + :py:obj:`~.srcY`, and :py:obj:`~.dstHeight` must
          be greater than or equal to :py:obj:`~.Height` + :py:obj:`~.dstY`.

        :py:obj:`~.cuMemcpy3DAsync()` returns an error if any pitch is greater
        than the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).

        The :py:obj:`~.srcLOD` and :py:obj:`~.dstLOD` members of the
        :py:obj:`~.CUDA_MEMCPY3D` structure must be set to 0.

        Parameters
        ----------
        pCopy : :py:obj:`~.CUDA_MEMCPY3D`
            Parameters for the memory copy
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpy3DAsync`
    """


def cuMemcpy3DBatchAsync(numOps, opList: 'Optional[Tuple[CUDA_MEMCPY3D_BATCH_OP] | List[CUDA_MEMCPY3D_BATCH_OP]]', flags, hStream):
    """
    cuMemcpy3DBatchAsync(size_t numOps, opList: Optional[Tuple[CUDA_MEMCPY3D_BATCH_OP] | List[CUDA_MEMCPY3D_BATCH_OP]], unsigned long long flags, hStream)
     Performs a batch of 3D memory copies asynchronously.

        Performs a batch of memory copies. The batch as a whole executes in
        stream order but copies within a batch are not guaranteed to execute in
        any specific order. Note that this means specifying any dependent
        copies within a batch will result in undefined behavior.

        Performs memory copies as specified in the `opList` array. The length
        of this array is specified in `numOps`. Each entry in this array
        describes a copy operation. This includes among other things, the
        source and destination operands for the copy as specified in
        :py:obj:`~.CUDA_MEMCPY3D_BATCH_OP.src` and
        :py:obj:`~.CUDA_MEMCPY3D_BATCH_OP.dst` respectively. The source and
        destination operands of a copy can either be a pointer or a CUDA array.
        The width, height and depth of a copy is specified in
        :py:obj:`~.CUDA_MEMCPY3D_BATCH_OP.extent`. The width, height and depth
        of a copy are specified in elements and must not be zero. For pointer-
        to-pointer copies, the element size is considered to be 1. For pointer
        to CUDA array or vice versa copies, the element size is determined by
        the CUDA array. For CUDA array to CUDA array copies, the element size
        of the two CUDA arrays must match.

        For a given operand, if :py:obj:`~.CUmemcpy3DOperand`::type is
        specified as :py:obj:`~.CU_MEMCPY_OPERAND_TYPE_POINTER`, then
        :py:obj:`~.CUmemcpy3DOperand`::op::ptr will be used. The
        :py:obj:`~.CUmemcpy3DOperand`::op::ptr::ptr field must contain the
        pointer where the copy should begin. The
        :py:obj:`~.CUmemcpy3DOperand`::op::ptr::rowLength field specifies the
        length of each row in elements and must either be zero or be greater
        than or equal to the width of the copy specified in
        :py:obj:`~.CUDA_MEMCPY3D_BATCH_OP`::extent::width. The
        :py:obj:`~.CUmemcpy3DOperand`::op::ptr::layerHeight field specifies the
        height of each layer and must either be zero or be greater than or
        equal to the height of the copy specified in
        :py:obj:`~.CUDA_MEMCPY3D_BATCH_OP`::extent::height. When either of
        these values is zero, that aspect of the operand is considered to be
        tightly packed according to the copy extent. For managed memory
        pointers on devices where
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` is true or
        system-allocated pageable memory on devices where
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS` is true, the
        :py:obj:`~.CUmemcpy3DOperand`::op::ptr::locHint field can be used to
        hint the location of the operand.

        If an operand's type is specified as
        :py:obj:`~.CU_MEMCPY_OPERAND_TYPE_ARRAY`, then
        :py:obj:`~.CUmemcpy3DOperand`::op::array will be used. The
        :py:obj:`~.CUmemcpy3DOperand`::op::array::array field specifies the
        CUDA array and :py:obj:`~.CUmemcpy3DOperand`::op::array::offset
        specifies the 3D offset into that array where the copy begins.

        The :py:obj:`~.CUmemcpyAttributes.srcAccessOrder` indicates the source
        access ordering to be observed for copies associated with the
        attribute. If the source access order is set to
        :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_STREAM`, then the source will be
        accessed in stream order. If the source access order is set to
        :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL` then it
        indicates that access to the source pointer can be out of stream order
        and all accesses must be complete before the API call returns. This
        flag is suited for ephemeral sources (ex., stack variables) when it's
        known that no prior operations in the stream can be accessing the
        memory and also that the lifetime of the memory is limited to the scope
        that the source variable was declared in. Specifying this flag allows
        the driver to optimize the copy and removes the need for the user to
        synchronize the stream after the API call. If the source access order
        is set to :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_ANY` then it indicates
        that access to the source pointer can be out of stream order and the
        accesses can happen even after the API call returns. This flag is
        suited for host pointers allocated outside CUDA (ex., via malloc) when
        it's known that no prior operations in the stream can be accessing the
        memory. Specifying this flag allows the driver to optimize the copy on
        certain platforms. Each memcopy operation in `opList` must have a valid
        srcAccessOrder setting, otherwise this API will return
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

        The :py:obj:`~.CUmemcpyAttributes.flags` field can be used to specify
        certain flags for copies. Setting the
        :py:obj:`~.CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE` flag indicates
        that the associated copies should preferably overlap with any compute
        work. Note that this flag is a hint and can be ignored depending on the
        platform and other parameters of the copy.

        If any error is encountered while parsing the batch, the index within
        the batch where the error was encountered will be returned in
        `failIdx`.

        Parameters
        ----------
        numOps : size_t
            Total number of memcpy operations.
        opList : List[:py:obj:`~.CUDA_MEMCPY3D_BATCH_OP`]
            Array of size `numOps` containing the actual memcpy operations.
        flags : unsigned long long
            Flags for future use, must be zero now.
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream to enqueue the operations in. Must not be default NULL
            stream.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_DEINITIALIZED` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        failIdx : int
            Pointer to a location to return the index of the copy where a
            failure was encountered. The value will be SIZE_MAX if the error
            doesn't pertain to any specific copy.
    """


def cuMemcpy3DPeer(pCopy: 'Optional[CUDA_MEMCPY3D_PEER]'):
    """
    cuMemcpy3DPeer(CUDA_MEMCPY3D_PEER pCopy: Optional[CUDA_MEMCPY3D_PEER])
     Copies memory between contexts.

        Perform a 3D memory copy according to the parameters specified in
        `pCopy`. See the definition of the :py:obj:`~.CUDA_MEMCPY3D_PEER`
        structure for documentation of its parameters.

        Parameters
        ----------
        pCopy : :py:obj:`~.CUDA_MEMCPY3D_PEER`
            Parameters for the memory copy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyPeerAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpy3DPeer`
    """


def cuMemcpy3DPeerAsync(pCopy: 'Optional[CUDA_MEMCPY3D_PEER]', hStream):
    """
    cuMemcpy3DPeerAsync(CUDA_MEMCPY3D_PEER pCopy: Optional[CUDA_MEMCPY3D_PEER], hStream)
     Copies memory between contexts asynchronously.

        Perform a 3D memory copy according to the parameters specified in
        `pCopy`. See the definition of the :py:obj:`~.CUDA_MEMCPY3D_PEER`
        structure for documentation of its parameters.

        Parameters
        ----------
        pCopy : :py:obj:`~.CUDA_MEMCPY3D_PEER`
            Parameters for the memory copy
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyPeerAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpy3DPeerAsync`
    """


def cuMemcpyAsync(dst, src, ByteCount, hStream):
    """
    cuMemcpyAsync(dst, src, size_t ByteCount, hStream)
     Copies memory asynchronously.

        Copies data between two pointers. `dst` and `src` are base pointers of
        the destination and source, respectively. `ByteCount` specifies the
        number of bytes to copy. Note that this function infers the type of the
        transfer (host to host, host to device, device to device, or device to
        host) from the pointer values. This function is only allowed in
        contexts which support unified addressing.

        Parameters
        ----------
        dst : :py:obj:`~.CUdeviceptr`
            Destination unified virtual address space pointer
        src : :py:obj:`~.CUdeviceptr`
            Source unified virtual address space pointer
        ByteCount : size_t
            Size of memory copy in bytes
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`
    """


def cuMemcpyAtoA(dstArray, dstOffset, srcArray, srcOffset, ByteCount):
    """
    cuMemcpyAtoA(dstArray, size_t dstOffset, srcArray, size_t srcOffset, size_t ByteCount)
     Copies memory from Array to Array.

        Copies from one 1D CUDA array to another. `dstArray` and `srcArray`
        specify the handles of the destination and source CUDA arrays for the
        copy, respectively. `dstOffset` and `srcOffset` specify the destination
        and source offsets in bytes into the CUDA arrays. `ByteCount` is the
        number of bytes to be copied. The size of the elements in the CUDA
        arrays need not be the same format, but the elements must be the same
        size; and count must be evenly divisible by that size.

        Parameters
        ----------
        dstArray : :py:obj:`~.CUarray`
            Destination array
        dstOffset : size_t
            Offset in bytes of destination array
        srcArray : :py:obj:`~.CUarray`
            Source array
        srcOffset : size_t
            Offset in bytes of source array
        ByteCount : size_t
            Size of memory copy in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyArrayToArray`
    """


def cuMemcpyAtoD(dstDevice, srcArray, srcOffset, ByteCount):
    """
    cuMemcpyAtoD(dstDevice, srcArray, size_t srcOffset, size_t ByteCount)
     Copies memory from Array to Device.

        Copies from one 1D CUDA array to device memory. `dstDevice` specifies
        the base pointer of the destination and must be naturally aligned with
        the CUDA array elements. `srcArray` and `srcOffset` specify the CUDA
        array handle and the offset in bytes into the array where the copy is
        to begin. `ByteCount` specifies the number of bytes to copy and must be
        evenly divisible by the array element size.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        srcArray : :py:obj:`~.CUarray`
            Source array
        srcOffset : size_t
            Offset in bytes of source array
        ByteCount : size_t
            Size of memory copy in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyFromArray`
    """


def cuMemcpyAtoH(dstHost, srcArray, srcOffset, ByteCount):
    """
    cuMemcpyAtoH(dstHost, srcArray, size_t srcOffset, size_t ByteCount)
     Copies memory from Array to Host.

        Copies from one 1D CUDA array to host memory. `dstHost` specifies the
        base pointer of the destination. `srcArray` and `srcOffset` specify the
        CUDA array handle and starting offset in bytes of the source data.
        `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstHost : Any
            Destination device pointer
        srcArray : :py:obj:`~.CUarray`
            Source array
        srcOffset : size_t
            Offset in bytes of source array
        ByteCount : size_t
            Size of memory copy in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyFromArray`
    """


def cuMemcpyAtoHAsync(dstHost, srcArray, srcOffset, ByteCount, hStream):
    """
    cuMemcpyAtoHAsync(dstHost, srcArray, size_t srcOffset, size_t ByteCount, hStream)
     Copies memory from Array to Host.

        Copies from one 1D CUDA array to host memory. `dstHost` specifies the
        base pointer of the destination. `srcArray` and `srcOffset` specify the
        CUDA array handle and starting offset in bytes of the source data.
        `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstHost : Any
            Destination pointer
        srcArray : :py:obj:`~.CUarray`
            Source array
        srcOffset : size_t
            Offset in bytes of source array
        ByteCount : size_t
            Size of memory copy in bytes
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyFromArrayAsync`
    """


def cuMemcpyBatchAsync(dsts: 'Optional[Tuple[CUdeviceptr] | List[CUdeviceptr]]', srcs: 'Optional[Tuple[CUdeviceptr] | List[CUdeviceptr]]', sizes: 'Tuple[int] | List[int]', count, attrs: 'Optional[Tuple[CUmemcpyAttributes] | List[CUmemcpyAttributes]]', attrsIdxs: 'Tuple[int] | List[int]', numAttrs, hStream):
    """
    cuMemcpyBatchAsync(dsts: Optional[Tuple[CUdeviceptr] | List[CUdeviceptr]], srcs: Optional[Tuple[CUdeviceptr] | List[CUdeviceptr]], sizes: Tuple[int] | List[int], size_t count, attrs: Optional[Tuple[CUmemcpyAttributes] | List[CUmemcpyAttributes]], attrsIdxs: Tuple[int] | List[int], size_t numAttrs, hStream)
     Performs a batch of memory copies asynchronously.

        Performs a batch of memory copies. The batch as a whole executes in
        stream order but copies within a batch are not guaranteed to execute in
        any specific order. This API only supports pointer-to-pointer copies.
        For copies involving CUDA arrays, please see
        :py:obj:`~.cuMemcpy3DBatchAsync`.

        Performs memory copies from source buffers specified in `srcs` to
        destination buffers specified in `dsts`. The size of each copy is
        specified in `sizes`. All three arrays must be of the same length as
        specified by `count`. Since there are no ordering guarantees for copies
        within a batch, specifying any dependent copies within a batch will
        result in undefined behavior.

        Every copy in the batch has to be associated with a set of attributes
        specified in the `attrs` array. Each entry in this array can apply to
        more than one copy. This can be done by specifying in the `attrsIdxs`
        array, the index of the first copy that the corresponding entry in the
        `attrs` array applies to. Both `attrs` and `attrsIdxs` must be of the
        same length as specified by `numAttrs`. For example, if a batch has 10
        copies listed in dst/src/sizes, the first 6 of which have one set of
        attributes and the remaining 4 another, then `numAttrs` will be 2,
        `attrsIdxs` will be {0, 6} and `attrs` will contains the two sets of
        attributes. Note that the first entry in `attrsIdxs` must always be 0.
        Also, each entry must be greater than the previous entry and the last
        entry should be less than `count`. Furthermore, `numAttrs` must be
        lesser than or equal to `count`.

        The :py:obj:`~.CUmemcpyAttributes.srcAccessOrder` indicates the source
        access ordering to be observed for copies associated with the
        attribute. If the source access order is set to
        :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_STREAM`, then the source will be
        accessed in stream order. If the source access order is set to
        :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL` then it
        indicates that access to the source pointer can be out of stream order
        and all accesses must be complete before the API call returns. This
        flag is suited for ephemeral sources (ex., stack variables) when it's
        known that no prior operations in the stream can be accessing the
        memory and also that the lifetime of the memory is limited to the scope
        that the source variable was declared in. Specifying this flag allows
        the driver to optimize the copy and removes the need for the user to
        synchronize the stream after the API call. If the source access order
        is set to :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_ANY` then it indicates
        that access to the source pointer can be out of stream order and the
        accesses can happen even after the API call returns. This flag is
        suited for host pointers allocated outside CUDA (ex., via malloc) when
        it's known that no prior operations in the stream can be accessing the
        memory. Specifying this flag allows the driver to optimize the copy on
        certain platforms. Each memcpy operation in the batch must have a valid
        :py:obj:`~.CUmemcpyAttributes` corresponding to it including the
        appropriate srcAccessOrder setting, otherwise the API will return
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

        The :py:obj:`~.CUmemcpyAttributes.srcLocHint` and
        :py:obj:`~.CUmemcpyAttributes.dstLocHint` allows applications to
        specify hint locations for operands of a copy when the operand doesn't
        have a fixed location. That is, these hints are only applicable for
        managed memory pointers on devices where
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` is true or
        system-allocated pageable memory on devices where
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS` is true. For
        other cases, these hints are ignored.

        The :py:obj:`~.CUmemcpyAttributes.flags` field can be used to specify
        certain flags for copies. Setting the
        :py:obj:`~.CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE` flag indicates
        that the associated copies should preferably overlap with any compute
        work. Note that this flag is a hint and can be ignored depending on the
        platform and other parameters of the copy.

        If any error is encountered while parsing the batch, the index within
        the batch where the error was encountered will be returned in
        `failIdx`.

        Parameters
        ----------
        dsts : List[:py:obj:`~.CUdeviceptr`]
            Array of destination pointers.
        srcs : List[:py:obj:`~.CUdeviceptr`]
            Array of memcpy source pointers.
        sizes : List[int]
            Array of sizes for memcpy operations.
        count : size_t
            Size of `dsts`, `srcs` and `sizes` arrays
        attrs : List[:py:obj:`~.CUmemcpyAttributes`]
            Array of memcpy attributes.
        attrsIdxs : List[int]
            Array of indices to specify which copies each entry in the `attrs`
            array applies to. The attributes specified in attrs[k] will be
            applied to copies starting from attrsIdxs[k] through attrsIdxs[k+1]
            - 1. Also attrs[numAttrs-1] will apply to copies starting from
            attrsIdxs[numAttrs-1] through count - 1.
        numAttrs : size_t
            Size of `attrs` and `attrsIdxs` arrays.
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream to enqueue the operations in. Must not be legacy NULL
            stream.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_DEINITIALIZED` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        failIdx : int
            Pointer to a location to return the index of the copy where a
            failure was encountered. The value will be SIZE_MAX if the error
            doesn't pertain to any specific copy.
    """


def cuMemcpyDtoA(dstArray, dstOffset, srcDevice, ByteCount):
    """
    cuMemcpyDtoA(dstArray, size_t dstOffset, srcDevice, size_t ByteCount)
     Copies memory from Device to Array.

        Copies from device memory to a 1D CUDA array. `dstArray` and
        `dstOffset` specify the CUDA array handle and starting index of the
        destination data. `srcDevice` specifies the base pointer of the source.
        `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstArray : :py:obj:`~.CUarray`
            Destination array
        dstOffset : size_t
            Offset in bytes of destination array
        srcDevice : :py:obj:`~.CUdeviceptr`
            Source device pointer
        ByteCount : size_t
            Size of memory copy in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyToArray`
    """


def cuMemcpyDtoD(dstDevice, srcDevice, ByteCount):
    """
    cuMemcpyDtoD(dstDevice, srcDevice, size_t ByteCount)
     Copies memory from Device to Device.

        Copies from device memory to device memory. `dstDevice` and `srcDevice`
        are the base pointers of the destination and source, respectively.
        `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        srcDevice : :py:obj:`~.CUdeviceptr`
            Source device pointer
        ByteCount : size_t
            Size of memory copy in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`
    """


def cuMemcpyDtoDAsync(dstDevice, srcDevice, ByteCount, hStream):
    """
    cuMemcpyDtoDAsync(dstDevice, srcDevice, size_t ByteCount, hStream)
     Copies memory from Device to Device.

        Copies from device memory to device memory. `dstDevice` and `srcDevice`
        are the base pointers of the destination and source, respectively.
        `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        srcDevice : :py:obj:`~.CUdeviceptr`
            Source device pointer
        ByteCount : size_t
            Size of memory copy in bytes
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`
    """


def cuMemcpyDtoH(dstHost, srcDevice, ByteCount):
    """
    cuMemcpyDtoH(dstHost, srcDevice, size_t ByteCount)
     Copies memory from Device to Host.

        Copies from device to host memory. `dstHost` and `srcDevice` specify
        the base pointers of the destination and source, respectively.
        `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstHost : Any
            Destination host pointer
        srcDevice : :py:obj:`~.CUdeviceptr`
            Source device pointer
        ByteCount : size_t
            Size of memory copy in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyFromSymbol`
    """


def cuMemcpyDtoHAsync(dstHost, srcDevice, ByteCount, hStream):
    """
    cuMemcpyDtoHAsync(dstHost, srcDevice, size_t ByteCount, hStream)
     Copies memory from Device to Host.

        Copies from device to host memory. `dstHost` and `srcDevice` specify
        the base pointers of the destination and source, respectively.
        `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstHost : Any
            Destination host pointer
        srcDevice : :py:obj:`~.CUdeviceptr`
            Source device pointer
        ByteCount : size_t
            Size of memory copy in bytes
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`
    """


def cuMemcpyHtoA(dstArray, dstOffset, srcHost, ByteCount):
    """
    cuMemcpyHtoA(dstArray, size_t dstOffset, srcHost, size_t ByteCount)
     Copies memory from Host to Array.

        Copies from host memory to a 1D CUDA array. `dstArray` and `dstOffset`
        specify the CUDA array handle and starting offset in bytes of the
        destination data. `pSrc` specifies the base address of the source.
        `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstArray : :py:obj:`~.CUarray`
            Destination array
        dstOffset : size_t
            Offset in bytes of destination array
        srcHost : Any
            Source host pointer
        ByteCount : size_t
            Size of memory copy in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyToArray`
    """


def cuMemcpyHtoAAsync(dstArray, dstOffset, srcHost, ByteCount, hStream):
    """
    cuMemcpyHtoAAsync(dstArray, size_t dstOffset, srcHost, size_t ByteCount, hStream)
     Copies memory from Host to Array.

        Copies from host memory to a 1D CUDA array. `dstArray` and `dstOffset`
        specify the CUDA array handle and starting offset in bytes of the
        destination data. `srcHost` specifies the base address of the source.
        `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstArray : :py:obj:`~.CUarray`
            Destination array
        dstOffset : size_t
            Offset in bytes of destination array
        srcHost : Any
            Source host pointer
        ByteCount : size_t
            Size of memory copy in bytes
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyToArrayAsync`
    """


def cuMemcpyHtoD(dstDevice, srcHost, ByteCount):
    """
    cuMemcpyHtoD(dstDevice, srcHost, size_t ByteCount)
     Copies memory from Host to Device.

        Copies from host memory to device memory. `dstDevice` and `srcHost` are
        the base addresses of the destination and source, respectively.
        `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        srcHost : Any
            Source host pointer
        ByteCount : size_t
            Size of memory copy in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyToSymbol`
    """


def cuMemcpyHtoDAsync(dstDevice, srcHost, ByteCount, hStream):
    """
    cuMemcpyHtoDAsync(dstDevice, srcHost, size_t ByteCount, hStream)
     Copies memory from Host to Device.

        Copies from host memory to device memory. `dstDevice` and `srcHost` are
        the base addresses of the destination and source, respectively.
        `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        srcHost : Any
            Source host pointer
        ByteCount : size_t
            Size of memory copy in bytes
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`
    """


def cuMemcpyPeer(dstDevice, dstContext, srcDevice, srcContext, ByteCount):
    """
    cuMemcpyPeer(dstDevice, dstContext, srcDevice, srcContext, size_t ByteCount)
     Copies device memory between two contexts.

        Copies from device memory in one context to device memory in another
        context. `dstDevice` is the base device pointer of the destination
        memory and `dstContext` is the destination context. `srcDevice` is the
        base device pointer of the source memory and `srcContext` is the source
        pointer. `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        dstContext : :py:obj:`~.CUcontext`
            Destination context
        srcDevice : :py:obj:`~.CUdeviceptr`
            Source device pointer
        srcContext : :py:obj:`~.CUcontext`
            Source context
        ByteCount : size_t
            Size of memory copy in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpy3DPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyPeerAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpyPeer`
    """


def cuMemcpyPeerAsync(dstDevice, dstContext, srcDevice, srcContext, ByteCount, hStream):
    """
    cuMemcpyPeerAsync(dstDevice, dstContext, srcDevice, srcContext, size_t ByteCount, hStream)
     Copies device memory between two contexts asynchronously.

        Copies from device memory in one context to device memory in another
        context. `dstDevice` is the base device pointer of the destination
        memory and `dstContext` is the destination context. `srcDevice` is the
        base device pointer of the source memory and `srcContext` is the source
        pointer. `ByteCount` specifies the number of bytes to copy.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        dstContext : :py:obj:`~.CUcontext`
            Destination context
        srcDevice : :py:obj:`~.CUdeviceptr`
            Source device pointer
        srcContext : :py:obj:`~.CUcontext`
            Source context
        ByteCount : size_t
            Size of memory copy in bytes
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpy3DPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpyPeerAsync`
    """


def cuMemsetD16(dstDevice, us, N):
    """
    cuMemsetD16(dstDevice, unsigned short us, size_t N)
     Initializes device memory.

        Sets the memory range of `N` 16-bit values to the specified value `us`.
        The `dstDevice` pointer must be two byte aligned.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        us : unsigned short
            Value to set
        N : size_t
            Number of elements

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset`
    """


def cuMemsetD16Async(dstDevice, us, N, hStream):
    """
    cuMemsetD16Async(dstDevice, unsigned short us, size_t N, hStream)
     Sets device memory.

        Sets the memory range of `N` 16-bit values to the specified value `us`.
        The `dstDevice` pointer must be two byte aligned.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        us : unsigned short
            Value to set
        N : size_t
            Number of elements
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemsetAsync`
    """


def cuMemsetD2D16(dstDevice, dstPitch, us, Width, Height):
    """
    cuMemsetD2D16(dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height)
     Initializes device memory.

        Sets the 2D memory range of `Width` 16-bit values to the specified
        value `us`. `Height` specifies the number of rows to set, and
        `dstPitch` specifies the number of bytes between each row. The
        `dstDevice` pointer and `dstPitch` offset must be two byte aligned.
        This function performs fastest when the pitch is one that has been
        passed back by :py:obj:`~.cuMemAllocPitch()`.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        dstPitch : size_t
            Pitch of destination device pointer(Unused if `Height` is 1)
        us : unsigned short
            Value to set
        Width : size_t
            Width of row
        Height : size_t
            Number of rows

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2D`
    """


def cuMemsetD2D16Async(dstDevice, dstPitch, us, Width, Height, hStream):
    """
    cuMemsetD2D16Async(dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, hStream)
     Sets device memory.

        Sets the 2D memory range of `Width` 16-bit values to the specified
        value `us`. `Height` specifies the number of rows to set, and
        `dstPitch` specifies the number of bytes between each row. The
        `dstDevice` pointer and `dstPitch` offset must be two byte aligned.
        This function performs fastest when the pitch is one that has been
        passed back by :py:obj:`~.cuMemAllocPitch()`.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        dstPitch : size_t
            Pitch of destination device pointer(Unused if `Height` is 1)
        us : unsigned short
            Value to set
        Width : size_t
            Width of row
        Height : size_t
            Number of rows
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2DAsync`
    """


def cuMemsetD2D32(dstDevice, dstPitch, ui, Width, Height):
    """
    cuMemsetD2D32(dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height)
     Initializes device memory.

        Sets the 2D memory range of `Width` 32-bit values to the specified
        value `ui`. `Height` specifies the number of rows to set, and
        `dstPitch` specifies the number of bytes between each row. The
        `dstDevice` pointer and `dstPitch` offset must be four byte aligned.
        This function performs fastest when the pitch is one that has been
        passed back by :py:obj:`~.cuMemAllocPitch()`.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        dstPitch : size_t
            Pitch of destination device pointer(Unused if `Height` is 1)
        ui : unsigned int
            Value to set
        Width : size_t
            Width of row
        Height : size_t
            Number of rows

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2D`
    """


def cuMemsetD2D32Async(dstDevice, dstPitch, ui, Width, Height, hStream):
    """
    cuMemsetD2D32Async(dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height, hStream)
     Sets device memory.

        Sets the 2D memory range of `Width` 32-bit values to the specified
        value `ui`. `Height` specifies the number of rows to set, and
        `dstPitch` specifies the number of bytes between each row. The
        `dstDevice` pointer and `dstPitch` offset must be four byte aligned.
        This function performs fastest when the pitch is one that has been
        passed back by :py:obj:`~.cuMemAllocPitch()`.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        dstPitch : size_t
            Pitch of destination device pointer(Unused if `Height` is 1)
        ui : unsigned int
            Value to set
        Width : size_t
            Width of row
        Height : size_t
            Number of rows
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2DAsync`
    """


def cuMemsetD2D8(dstDevice, dstPitch, uc, Width, Height):
    """
    cuMemsetD2D8(dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height)
     Initializes device memory.

        Sets the 2D memory range of `Width` 8-bit values to the specified value
        `uc`. `Height` specifies the number of rows to set, and `dstPitch`
        specifies the number of bytes between each row. This function performs
        fastest when the pitch is one that has been passed back by
        :py:obj:`~.cuMemAllocPitch()`.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        dstPitch : size_t
            Pitch of destination device pointer(Unused if `Height` is 1)
        uc : unsigned char
            Value to set
        Width : size_t
            Width of row
        Height : size_t
            Number of rows

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2D`
    """


def cuMemsetD2D8Async(dstDevice, dstPitch, uc, Width, Height, hStream):
    """
    cuMemsetD2D8Async(dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, hStream)
     Sets device memory.

        Sets the 2D memory range of `Width` 8-bit values to the specified value
        `uc`. `Height` specifies the number of rows to set, and `dstPitch`
        specifies the number of bytes between each row. This function performs
        fastest when the pitch is one that has been passed back by
        :py:obj:`~.cuMemAllocPitch()`.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        dstPitch : size_t
            Pitch of destination device pointer(Unused if `Height` is 1)
        uc : unsigned char
            Value to set
        Width : size_t
            Width of row
        Height : size_t
            Number of rows
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2DAsync`
    """


def cuMemsetD32(dstDevice, ui, N):
    """
    cuMemsetD32(dstDevice, unsigned int ui, size_t N)
     Initializes device memory.

        Sets the memory range of `N` 32-bit values to the specified value `ui`.
        The `dstDevice` pointer must be four byte aligned.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        ui : unsigned int
            Value to set
        N : size_t
            Number of elements

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset`
    """


def cuMemsetD32Async(dstDevice, ui, N, hStream):
    """
    cuMemsetD32Async(dstDevice, unsigned int ui, size_t N, hStream)
     Sets device memory.

        Sets the memory range of `N` 32-bit values to the specified value `ui`.
        The `dstDevice` pointer must be four byte aligned.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        ui : unsigned int
            Value to set
        N : size_t
            Number of elements
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemsetAsync`
    """


def cuMemsetD8(dstDevice, uc, N):
    """
    cuMemsetD8(dstDevice, unsigned char uc, size_t N)
     Initializes device memory.

        Sets the memory range of `N` 8-bit values to the specified value `uc`.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        uc : unsigned char
            Value to set
        N : size_t
            Number of elements

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset`
    """


def cuMemsetD8Async(dstDevice, uc, N, hStream):
    """
    cuMemsetD8Async(dstDevice, unsigned char uc, size_t N, hStream)
     Sets device memory.

        Sets the memory range of `N` 8-bit values to the specified value `uc`.

        Parameters
        ----------
        dstDevice : :py:obj:`~.CUdeviceptr`
            Destination device pointer
        uc : unsigned char
            Value to set
        N : size_t
            Number of elements
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream identifier

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemsetAsync`
    """


def cuMipmappedArrayCreate(pMipmappedArrayDesc: 'Optional[CUDA_ARRAY3D_DESCRIPTOR]', numMipmapLevels):
    """
    cuMipmappedArrayCreate(CUDA_ARRAY3D_DESCRIPTOR pMipmappedArrayDesc: Optional[CUDA_ARRAY3D_DESCRIPTOR], unsigned int numMipmapLevels)
     Creates a CUDA mipmapped array.

        Creates a CUDA mipmapped array according to the
        :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` structure `pMipmappedArrayDesc` and
        returns a handle to the new CUDA mipmapped array in `*pHandle`.
        `numMipmapLevels` specifies the number of mipmap levels to be
        allocated. This value is clamped to the range [1, 1 +
        floor(log2(max(width, height, depth)))].

        The :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - `Width`, `Height`, and `Depth` are the width, height, and depth of
          the CUDA array (in elements); the following types of CUDA arrays can
          be allocated:

          - A 1D mipmapped array is allocated if `Height` and `Depth` extents
            are both zero.

          - A 2D mipmapped array is allocated if only `Depth` extent is zero.

          - A 3D mipmapped array is allocated if all three extents are non-
            zero.

          - A 1D layered CUDA mipmapped array is allocated if only `Height` is
            zero and the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set. Each
            layer is a 1D array. The number of layers is determined by the
            depth extent.

          - A 2D layered CUDA mipmapped array is allocated if all three extents
            are non-zero and the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set.
            Each layer is a 2D array. The number of layers is determined by the
            depth extent.

          - A cubemap CUDA mipmapped array is allocated if all three extents
            are non-zero and the :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` flag is set.
            `Width` must be equal to `Height`, and `Depth` must be six. A
            cubemap is a special type of 2D layered CUDA array, where the six
            layers represent the six faces of a cube. The order of the six
            layers in memory is the same as that listed in
            :py:obj:`~.CUarray_cubemap_face`.

          - A cubemap layered CUDA mipmapped array is allocated if all three
            extents are non-zero, and both, :py:obj:`~.CUDA_ARRAY3D_CUBEMAP`
            and :py:obj:`~.CUDA_ARRAY3D_LAYERED` flags are set. `Width` must be
            equal to `Height`, and `Depth` must be a multiple of six. A cubemap
            layered CUDA array is a special type of 2D layered CUDA array that
            consists of a collection of cubemaps. The first six layers
            represent the first cubemap, the next six layers form the second
            cubemap, and so on.

        - :py:obj:`~.Format` specifies the format of the elements;
          :py:obj:`~.CUarray_format` is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - `NumChannels` specifies the number of packed components per CUDA
          array element; it may be 1, 2, or 4;

        - :py:obj:`~.Flags` may be set to

          - :py:obj:`~.CUDA_ARRAY3D_LAYERED` to enable creation of layered CUDA
            mipmapped arrays. If this flag is set, `Depth` specifies the number
            of layers, not the depth of a 3D array.

          - :py:obj:`~.CUDA_ARRAY3D_SURFACE_LDST` to enable surface references
            to be bound to individual mipmap levels of the CUDA mipmapped
            array. If this flag is not set, :py:obj:`~.cuSurfRefSetArray` will
            fail when attempting to bind a mipmap level of the CUDA mipmapped
            array to a surface reference.

        - :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` to enable creation of mipmapped
        cubemaps. If this flag is set, `Width` must be equal to `Height`, and
        `Depth` must be six. If the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is
        also set, then `Depth` must be a multiple of six.

          - :py:obj:`~.CUDA_ARRAY3D_TEXTURE_GATHER` to indicate that the CUDA
            mipmapped array will be used for texture gather. Texture gather can
            only be performed on 2D CUDA mipmapped arrays.

        `Width`, `Height` and `Depth` must meet certain size requirements as
        listed in the following table. All values are specified in elements.
        Note that for brevity's sake, the full name of the device attribute is
        not specified. For ex., TEXTURE1D_MIPMAPPED_WIDTH refers to the device
        attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH`.

        **View CUDA Toolkit Documentation for a table example**

        Parameters
        ----------
        pMipmappedArrayDesc : :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR`
            mipmapped array descriptor
        numMipmapLevels : unsigned int
            Number of mipmap levels

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        pHandle : :py:obj:`~.CUmipmappedArray`
            Returned mipmapped array

        See Also
        --------
        :py:obj:`~.cuMipmappedArrayDestroy`, :py:obj:`~.cuMipmappedArrayGetLevel`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaMallocMipmappedArray`
    """


def cuMipmappedArrayDestroy(hMipmappedArray):
    """
    cuMipmappedArrayDestroy(hMipmappedArray)
     Destroys a CUDA mipmapped array.

        Destroys the CUDA mipmapped array `hMipmappedArray`.

        Parameters
        ----------
        hMipmappedArray : :py:obj:`~.CUmipmappedArray`
            Mipmapped array to destroy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ARRAY_IS_MAPPED`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`

        See Also
        --------
        :py:obj:`~.cuMipmappedArrayCreate`, :py:obj:`~.cuMipmappedArrayGetLevel`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaFreeMipmappedArray`
    """


def cuMipmappedArrayGetLevel(hMipmappedArray, level):
    """
    cuMipmappedArrayGetLevel(hMipmappedArray, unsigned int level)
     Gets a mipmap level of a CUDA mipmapped array.

        Returns in `*pLevelArray` a CUDA array that represents a single mipmap
        level of the CUDA mipmapped array `hMipmappedArray`.

        If `level` is greater than the maximum number of levels in this
        mipmapped array, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

        Parameters
        ----------
        hMipmappedArray : :py:obj:`~.CUmipmappedArray`
            CUDA mipmapped array
        level : unsigned int
            Mipmap level

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
        pLevelArray : :py:obj:`~.CUarray`
            Returned mipmap level CUDA array

        See Also
        --------
        :py:obj:`~.cuMipmappedArrayCreate`, :py:obj:`~.cuMipmappedArrayDestroy`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaGetMipmappedArrayLevel`
    """


def cuMipmappedArrayGetMemoryRequirements(mipmap, device):
    """
    cuMipmappedArrayGetMemoryRequirements(mipmap, device)
     Returns the memory requirements of a CUDA mipmapped array.

        Returns the memory requirements of a CUDA mipmapped array in
        `memoryRequirements` If the CUDA mipmapped array is not allocated with
        flag :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned.

        The returned value in :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.size`
        represents the total size of the CUDA mipmapped array. The returned
        value in :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.alignment`
        represents the alignment necessary for mapping the CUDA mipmapped
        array.

        Parameters
        ----------
        mipmap : :py:obj:`~.CUmipmappedArray`
            CUDA mipmapped array to get the memory requirements of
        device : :py:obj:`~.CUdevice`
            Device to get the memory requirements for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        memoryRequirements : :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`
            Pointer to :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`

        See Also
        --------
        :py:obj:`~.cuArrayGetMemoryRequirements`, :py:obj:`~.cuMemMapArrayAsync`
    """


def cuMipmappedArrayGetSparseProperties(mipmap):
    """
    cuMipmappedArrayGetSparseProperties(mipmap)
     Returns the layout properties of a sparse CUDA mipmapped array.

        Returns the sparse array layout properties in `sparseProperties` If the
        CUDA mipmapped array is not allocated with flag
        :py:obj:`~.CUDA_ARRAY3D_SPARSE` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        will be returned.

        For non-layered CUDA mipmapped arrays,
        :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` returns the size
        of the mip tail region. The mip tail region includes all mip levels
        whose width, height or depth is less than that of the tile. For layered
        CUDA mipmapped arrays, if
        :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.flags` contains
        :py:obj:`~.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL`, then
        :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` specifies the size
        of the mip tail of all layers combined. Otherwise,
        :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` specifies mip tail
        size per layer. The returned value of
        :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailFirstLevel` is valid
        only if :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` is non-
        zero.

        Parameters
        ----------
        mipmap : :py:obj:`~.CUmipmappedArray`
            CUDA mipmapped array to get the sparse properties of

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        sparseProperties : :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`
            Pointer to :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`

        See Also
        --------
        :py:obj:`~.cuArrayGetSparseProperties`, :py:obj:`~.cuMemMapArrayAsync`
    """


def cuModuleEnumerateFunctions(numFunctions, mod):
    """
    cuModuleEnumerateFunctions(unsigned int numFunctions, mod)
     Returns the function handles within a module.

        Returns in `functions` a maximum number of `numFunctions` function
        handles within `mod`. When function loading mode is set to LAZY the
        function retrieved may be partially loaded. The loading state of a
        function can be queried using :py:obj:`~.cuFunctionIsLoaded`. CUDA APIs
        may load the function automatically when called with partially loaded
        function handle which may incur additional latency. Alternatively,
        :py:obj:`~.cuFunctionLoad` can be used to explicitly load a function.
        The returned function handles become invalid when the module is
        unloaded.

        Parameters
        ----------
        numFunctions : unsigned int
            Maximum number of function handles may be returned to the buffer
        mod : :py:obj:`~.CUmodule`
            Module to query from

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        functions : List[:py:obj:`~.CUfunction`]
            Buffer where the function handles are returned to

        See Also
        --------
        :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetFunctionCount`, :py:obj:`~.cuFuncIsLoaded`, :py:obj:`~.cuFuncLoad`
    """


def cuModuleGetFunction(hmod, name):
    """
    cuModuleGetFunction(hmod, char *name)
     Returns a function handle.

        Returns in `*hfunc` the handle of the function of name `name` located
        in module `hmod`. If no function of that name exists,
        :py:obj:`~.cuModuleGetFunction()` returns
        :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

        Parameters
        ----------
        hmod : :py:obj:`~.CUmodule`
            Module to retrieve function from
        name : bytes
            Name of function to retrieve

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
        hfunc : :py:obj:`~.CUfunction`
            Returned function handle

        See Also
        --------
        :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """


def cuModuleGetFunctionCount(mod):
    """
    cuModuleGetFunctionCount(mod)
     Returns the number of functions within a module.

        Returns in `count` the number of functions in `mod`.

        Parameters
        ----------
        mod : :py:obj:`~.CUmodule`
            Module to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        count : unsigned int
            Number of functions found within the module
    """


def cuModuleGetGlobal(hmod, name):
    """
    cuModuleGetGlobal(hmod, char *name)
     Returns a global pointer from a module.

        Returns in `*dptr` and `*bytes` the base pointer and size of the global
        of name `name` located in module `hmod`. If no variable of that name
        exists, :py:obj:`~.cuModuleGetGlobal()` returns
        :py:obj:`~.CUDA_ERROR_NOT_FOUND`. One of the parameters `dptr` or
        `numbytes` (not both) can be NULL in which case it is ignored.

        Parameters
        ----------
        hmod : :py:obj:`~.CUmodule`
            Module to retrieve global from
        name : bytes
            Name of global to retrieve

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
        dptr : :py:obj:`~.CUdeviceptr`
            Returned global device pointer
        numbytes : int
            Returned global size in bytes

        See Also
        --------
        :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`, :py:obj:`~.cudaGetSymbolAddress`, :py:obj:`~.cudaGetSymbolSize`
    """


def cuModuleGetLoadingMode():
    """
    cuModuleGetLoadingMode()
     Query lazy loading mode.

        Returns lazy loading mode Module loading mode is controlled by
        CUDA_MODULE_LOADING env variable

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
        mode : :py:obj:`~.CUmoduleLoadingMode`
            Returns the lazy loading mode

        See Also
        --------
        :py:obj:`~.cuModuleLoad`,
    """


def cuModuleGetSurfRef(hmod, name):
    """
    cuModuleGetSurfRef(hmod, char *name)
     Returns a handle to a surface reference.

        [Deprecated]

        Returns in `*pSurfRef` the handle of the surface reference of name
        `name` in the module `hmod`. If no surface reference of that name
        exists, :py:obj:`~.cuModuleGetSurfRef()` returns
        :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

        Parameters
        ----------
        hmod : :py:obj:`~.CUmodule`
            Module to retrieve surface reference from
        name : bytes
            Name of surface reference to retrieve

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
        pSurfRef : :py:obj:`~.CUsurfref`
            Returned surface reference

        See Also
        --------
        :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """


def cuModuleGetTexRef(hmod, name):
    """
    cuModuleGetTexRef(hmod, char *name)
     Returns a handle to a texture reference.

        [Deprecated]

        Returns in `*pTexRef` the handle of the texture reference of name
        `name` in the module `hmod`. If no texture reference of that name
        exists, :py:obj:`~.cuModuleGetTexRef()` returns
        :py:obj:`~.CUDA_ERROR_NOT_FOUND`. This texture reference handle should
        not be destroyed, since it will be destroyed when the module is
        unloaded.

        Parameters
        ----------
        hmod : :py:obj:`~.CUmodule`
            Module to retrieve texture reference from
        name : bytes
            Name of texture reference to retrieve

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
        pTexRef : :py:obj:`~.CUtexref`
            Returned texture reference

        See Also
        --------
        :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetSurfRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """


def cuModuleLoad(fname):
    """
    cuModuleLoad(char *fname)
     Loads a compute module.

        Takes a filename `fname` and loads the corresponding module `module`
        into the current context. The CUDA driver API does not attempt to
        lazily allocate the resources needed by a module; if the memory for
        functions and data (constant and global) needed by the module cannot be
        allocated, :py:obj:`~.cuModuleLoad()` fails. The file should be a
        `cubin` file as output by nvcc, or a `PTX` file either as output by
        nvcc or handwritten, or a `fatbin` file as output by nvcc from
        toolchain 4.0 or later.

        Parameters
        ----------
        fname : bytes
            Filename of module to load

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_FILE_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
        module : :py:obj:`~.CUmodule`
            Returned module

        See Also
        --------
        :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """


def cuModuleLoadData(image):
    """
    cuModuleLoadData(image)
     Load a module's data.

        Takes a pointer `image` and loads the corresponding module `module`
        into the current context. The `image` may be a `cubin` or `fatbin` as
        output by nvcc, or a NULL-terminated `PTX`, either as output by nvcc or
        hand-written.

        Parameters
        ----------
        image : Any
            Module data to load

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
        module : :py:obj:`~.CUmodule`
            Returned module

        See Also
        --------
        :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """


def cuModuleLoadDataEx(image, numOptions, options: 'Optional[Tuple[CUjit_option] | List[CUjit_option]]', optionValues: 'Optional[Tuple[Any] | List[Any]]'):
    """
    cuModuleLoadDataEx(image, unsigned int numOptions, options: Optional[Tuple[CUjit_option] | List[CUjit_option]], optionValues: Optional[Tuple[Any] | List[Any]])
     Load a module's data with options.

        Takes a pointer `image` and loads the corresponding module `module`
        into the current context. The `image` may be a `cubin` or `fatbin` as
        output by nvcc, or a NULL-terminated `PTX`, either as output by nvcc or
        hand-written.

        Parameters
        ----------
        image : Any
            Module data to load
        numOptions : unsigned int
            Number of options
        options : List[:py:obj:`~.CUjit_option`]
            Options for JIT
        optionValues : List[Any]
            Option values for JIT

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
        module : :py:obj:`~.CUmodule`
            Returned module

        See Also
        --------
        :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """


def cuModuleLoadFatBinary(fatCubin):
    """
    cuModuleLoadFatBinary(fatCubin)
     Load a module's data.

        Takes a pointer `fatCubin` and loads the corresponding module `module`
        into the current context. The pointer represents a `fat binary` object,
        which is a collection of different `cubin` and/or `PTX` files, all
        representing the same device code, but compiled and optimized for
        different architectures.

        Prior to CUDA 4.0, there was no documented API for constructing and
        using fat binary objects by programmers. Starting with CUDA 4.0, fat
        binary objects can be constructed by providing the `-fatbin option` to
        nvcc. More information can be found in the nvcc document.

        Parameters
        ----------
        fatCubin : Any
            Fat binary to load

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
        module : :py:obj:`~.CUmodule`
            Returned module

        See Also
        --------
        :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleUnload`
    """


def cuModuleUnload(hmod):
    """
    cuModuleUnload(hmod)
     Unloads a module.

        Unloads a module `hmod` from the current context. Attempting to unload
        a module which was obtained from the Library Management API such as
        :py:obj:`~.cuLibraryGetModule` will return
        :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`.

        Parameters
        ----------
        hmod : :py:obj:`~.CUmodule`
            Module to unload

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`

        See Also
        --------
        :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`
    """


def cuMulticastAddDevice(mcHandle, dev):
    """
    cuMulticastAddDevice(mcHandle, dev)
     Associate a device to a multicast object.

        Associates a device to a multicast object. The added device will be a
        part of the multicast team of size specified by
        :py:obj:`~.CUmulticastObjectProp.numDevices` during
        :py:obj:`~.cuMulticastCreate`. The association of the device to the
        multicast object is permanent during the life time of the multicast
        object. All devices must be added to the multicast team before any
        memory can be bound to any device in the team. Any calls to
        :py:obj:`~.cuMulticastBindMem` or :py:obj:`~.cuMulticastBindAddr` will
        block until all devices have been added. Similarly all devices must be
        added to the multicast team before a virtual address range can be
        mapped to the multicast object. A call to :py:obj:`~.cuMemMap` will
        block until all devices have been added.

        Parameters
        ----------
        mcHandle : :py:obj:`~.CUmemGenericAllocationHandle`
            Handle representing a multicast object.
        dev : :py:obj:`~.CUdevice`
            Device that will be associated to the multicast object.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuMulticastCreate`, :py:obj:`~.cuMulticastBindMem`, :py:obj:`~.cuMulticastBindAddr`
    """


def cuMulticastBindAddr(mcHandle, mcOffset, memptr, size, flags):
    """
    cuMulticastBindAddr(mcHandle, size_t mcOffset, memptr, size_t size, unsigned long long flags)
     Bind a memory allocation represented by a virtual address to a multicast object.

        Binds a memory allocation specified by its mapped address `memptr` to a
        multicast object represented by `mcHandle`. The memory must have been
        allocated via :py:obj:`~.cuMemCreate` or :py:obj:`~.cudaMallocAsync`.
        The intended `size` of the bind, the offset in the multicast range
        `mcOffset` and `memptr` must be a multiple of the value returned by
        :py:obj:`~.cuMulticastGetGranularity` with the flag
        :py:obj:`~.CU_MULTICAST_GRANULARITY_MINIMUM`. For best performance
        however, `size`, `mcOffset` and `memptr` should be aligned to the value
        returned by :py:obj:`~.cuMulticastGetGranularity` with the flag
        :py:obj:`~.CU_MULTICAST_GRANULARITY_RECOMMENDED`.

        The `size` cannot be larger than the size of the allocated memory.
        Similarly the `size` + `mcOffset` cannot be larger than the total size
        of the multicast object. The memory allocation must have beeen created
        on one of the devices that was added to the multicast team via
        :py:obj:`~.cuMulticastAddDevice`. Externally shareable as well as
        imported multicast objects can be bound only to externally shareable
        memory. Note that this call will return CUDA_ERROR_OUT_OF_MEMORY if
        there are insufficient resources required to perform the bind. This
        call may also return CUDA_ERROR_SYSTEM_NOT_READY if the necessary
        system software is not initialized or running.

        Parameters
        ----------
        mcHandle : :py:obj:`~.CUmemGenericAllocationHandle`
            Handle representing a multicast object.
        mcOffset : size_t
            Offset into multicast va range for attachment.
        memptr : :py:obj:`~.CUdeviceptr`
            Virtual address of the memory allocation.
        size : size_t
            Size of memory that will be bound to the multicast object.
        flags : unsigned long long
            Flags for future use, must be zero now.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_SYSTEM_NOT_READY`

        See Also
        --------
        :py:obj:`~.cuMulticastCreate`, :py:obj:`~.cuMulticastAddDevice`, :py:obj:`~.cuMemCreate`
    """


def cuMulticastBindMem(mcHandle, mcOffset, memHandle, memOffset, size, flags):
    """
    cuMulticastBindMem(mcHandle, size_t mcOffset, memHandle, size_t memOffset, size_t size, unsigned long long flags)
     Bind a memory allocation represented by a handle to a multicast object.

        Binds a memory allocation specified by `memHandle` and created via
        :py:obj:`~.cuMemCreate` to a multicast object represented by `mcHandle`
        and created via :py:obj:`~.cuMulticastCreate`. The intended `size` of
        the bind, the offset in the multicast range `mcOffset` as well as the
        offset in the memory `memOffset` must be a multiple of the value
        returned by :py:obj:`~.cuMulticastGetGranularity` with the flag
        :py:obj:`~.CU_MULTICAST_GRANULARITY_MINIMUM`. For best performance
        however, `size`, `mcOffset` and `memOffset` should be aligned to the
        granularity of the memory allocation(see
        :py:obj:`~.cuMemGetAllocationGranularity`) or to the value returned by
        :py:obj:`~.cuMulticastGetGranularity` with the flag
        :py:obj:`~.CU_MULTICAST_GRANULARITY_RECOMMENDED`.

        The `size` + `memOffset` cannot be larger than the size of the
        allocated memory. Similarly the `size` + `mcOffset` cannot be larger
        than the size of the multicast object. The memory allocation must have
        beeen created on one of the devices that was added to the multicast
        team via :py:obj:`~.cuMulticastAddDevice`. Externally shareable as well
        as imported multicast objects can be bound only to externally shareable
        memory. Note that this call will return CUDA_ERROR_OUT_OF_MEMORY if
        there are insufficient resources required to perform the bind. This
        call may also return CUDA_ERROR_SYSTEM_NOT_READY if the necessary
        system software is not initialized or running.

        Parameters
        ----------
        mcHandle : :py:obj:`~.CUmemGenericAllocationHandle`
            Handle representing a multicast object.
        mcOffset : size_t
            Offset into the multicast object for attachment.
        memHandle : :py:obj:`~.CUmemGenericAllocationHandle`
            Handle representing a memory allocation.
        memOffset : size_t
            Offset into the memory for attachment.
        size : size_t
            Size of the memory that will be bound to the multicast object.
        flags : unsigned long long
            Flags for future use, must be zero for now.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_SYSTEM_NOT_READY`

        See Also
        --------
        :py:obj:`~.cuMulticastCreate`, :py:obj:`~.cuMulticastAddDevice`, :py:obj:`~.cuMemCreate`
    """


def cuMulticastCreate(prop: 'Optional[CUmulticastObjectProp]'):
    """
    cuMulticastCreate(CUmulticastObjectProp prop: Optional[CUmulticastObjectProp])
     Create a generic allocation handle representing a multicast object described by the given properties.

        This creates a multicast object as described by `prop`. The number of
        participating devices is specified by
        :py:obj:`~.CUmulticastObjectProp.numDevices`. Devices can be added to
        the multicast object via :py:obj:`~.cuMulticastAddDevice`. All
        participating devices must be added to the multicast object before
        memory can be bound to it. Memory is bound to the multicast object via
        either :py:obj:`~.cuMulticastBindMem` or
        :py:obj:`~.cuMulticastBindAddr`, and can be unbound via
        :py:obj:`~.cuMulticastUnbind`. The total amount of memory that can be
        bound per device is specified by
        :py:obj:`~.py`:obj:`~.CUmulticastObjectProp.size`. This size must be a
        multiple of the value returned by :py:obj:`~.cuMulticastGetGranularity`
        with the flag :py:obj:`~.CU_MULTICAST_GRANULARITY_MINIMUM`. For best
        performance however, the size should be aligned to the value returned
        by :py:obj:`~.cuMulticastGetGranularity` with the flag
        :py:obj:`~.CU_MULTICAST_GRANULARITY_RECOMMENDED`.

        After all participating devices have been added, multicast objects can
        also be mapped to a device's virtual address space using the virtual
        memory management APIs (see :py:obj:`~.cuMemMap` and
        :py:obj:`~.cuMemSetAccess`). Multicast objects can also be shared with
        other processes by requesting a shareable handle via
        :py:obj:`~.cuMemExportToShareableHandle`. Note that the desired types
        of shareable handles must be specified in the bitmask
        :py:obj:`~.CUmulticastObjectProp.handleTypes`. Multicast objects can be
        released using the virtual memory management API
        :py:obj:`~.cuMemRelease`.

        Parameters
        ----------
        prop : :py:obj:`~.CUmulticastObjectProp`
            Properties of the multicast object to create.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        mcHandle : :py:obj:`~.CUmemGenericAllocationHandle`
            Value of handle returned.

        See Also
        --------
        :py:obj:`~.cuMulticastAddDevice`, :py:obj:`~.cuMulticastBindMem`, :py:obj:`~.cuMulticastBindAddr`, :py:obj:`~.cuMulticastUnbind`

        :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemRelease`, :py:obj:`~.cuMemExportToShareableHandle`, :py:obj:`~.cuMemImportFromShareableHandle`
    """


def cuMulticastGetGranularity(prop: 'Optional[CUmulticastObjectProp]', option: 'CUmulticastGranularity_flags'):
    """
    cuMulticastGetGranularity(CUmulticastObjectProp prop: Optional[CUmulticastObjectProp], option: CUmulticastGranularity_flags)
     Calculates either the minimal or recommended granularity for multicast object.

        Calculates either the minimal or recommended granularity for a given
        set of multicast object properties and returns it in granularity. This
        granularity can be used as a multiple for size, bind offsets and
        address mappings of the multicast object.

        Parameters
        ----------
        prop : :py:obj:`~.CUmulticastObjectProp`
            Properties of the multicast object.
        option : :py:obj:`~.CUmulticastGranularity_flags`
            Determines which granularity to return.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        granularity : int
            Returned granularity.

        See Also
        --------
        :py:obj:`~.cuMulticastCreate`, :py:obj:`~.cuMulticastBindMem`, :py:obj:`~.cuMulticastBindAddr`, :py:obj:`~.cuMulticastUnbind`
    """


def cuMulticastUnbind(mcHandle, dev, mcOffset, size):
    """
    cuMulticastUnbind(mcHandle, dev, size_t mcOffset, size_t size)
     Unbind any memory allocations bound to a multicast object at a given offset and upto a given size.

        Unbinds any memory allocations hosted on `dev` and bound to a multicast
        object at `mcOffset` and upto a given `size`. The intended `size` of
        the unbind and the offset in the multicast range ( `mcOffset` ) must be
        a multiple of the value returned by
        :py:obj:`~.cuMulticastGetGranularity` flag
        :py:obj:`~.CU_MULTICAST_GRANULARITY_MINIMUM`. The `size` + `mcOffset`
        cannot be larger than the total size of the multicast object.

        Parameters
        ----------
        mcHandle : :py:obj:`~.CUmemGenericAllocationHandle`
            Handle representing a multicast object.
        dev : :py:obj:`~.CUdevice`
            Device that hosts the memory allocation.
        mcOffset : size_t
            Offset into the multicast object.
        size : size_t
            Desired size to unbind.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuMulticastBindMem`, :py:obj:`~.cuMulticastBindAddr`

        Notes
        -----
        Warning: The `mcOffset` and the `size` must match the corresponding values specified during the bind call. Any other values may result in undefined behavior.
    """


def cuOccupancyAvailableDynamicSMemPerBlock(func, numBlocks, blockSize):
    """
    cuOccupancyAvailableDynamicSMemPerBlock(func, int numBlocks, int blockSize)
     Returns dynamic shared memory available per block when launching `numBlocks` blocks on SM.

        Returns in `*dynamicSmemSize` the maximum size of dynamic shared memory
        to allow `numBlocks` blocks per SM.

        Note that the API can also be used with context-less kernel
        :py:obj:`~.CUkernel` by querying the handle using
        :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
        casting to :py:obj:`~.CUfunction`. Here, the context to use for
        calculations will be the current context.

        Parameters
        ----------
        func : :py:obj:`~.CUfunction`
            Kernel function for which occupancy is calculated
        numBlocks : int
            Number of blocks to fit on SM
        blockSize : int
            Size of the blocks

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        dynamicSmemSize : int
            Returned maximum dynamic shared memory
    """


def cuOccupancyMaxActiveBlocksPerMultiprocessor(func, blockSize, dynamicSMemSize):
    """
    cuOccupancyMaxActiveBlocksPerMultiprocessor(func, int blockSize, size_t dynamicSMemSize)
     Returns occupancy of a function.

        Returns in `*numBlocks` the number of the maximum active blocks per
        streaming multiprocessor.

        Note that the API can also be used with context-less kernel
        :py:obj:`~.CUkernel` by querying the handle using
        :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
        casting to :py:obj:`~.CUfunction`. Here, the context to use for
        calculations will be the current context.

        Parameters
        ----------
        func : :py:obj:`~.CUfunction`
            Kernel for which occupancy is calculated
        blockSize : int
            Block size the kernel is intended to be launched with
        dynamicSMemSize : size_t
            Per-block dynamic shared memory usage intended, in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        numBlocks : int
            Returned occupancy

        See Also
        --------
        :py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessor`
    """


def cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(func, blockSize, dynamicSMemSize, flags):
    """
    cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(func, int blockSize, size_t dynamicSMemSize, unsigned int flags)
     Returns occupancy of a function.

        Returns in `*numBlocks` the number of the maximum active blocks per
        streaming multiprocessor.

        The `Flags` parameter controls how special cases are handled. The valid
        flags are:

        - :py:obj:`~.CU_OCCUPANCY_DEFAULT`, which maintains the default
          behavior as :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor`;

        - :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE`, which suppresses
          the default behavior on platform where global caching affects
          occupancy. On such platforms, if caching is enabled, but per-block SM
          resource usage would result in zero occupancy, the occupancy
          calculator will calculate the occupancy as if caching is disabled.
          Setting :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE` makes the
          occupancy calculator to return 0 in such cases. More information can
          be found about this feature in the "Unified L1/Texture Cache" section
          of the Maxwell tuning guide.

        Note that the API can also be with launch context-less kernel
        :py:obj:`~.CUkernel` by querying the handle using
        :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
        casting to :py:obj:`~.CUfunction`. Here, the context to use for
        calculations will be the current context.

        Parameters
        ----------
        func : :py:obj:`~.CUfunction`
            Kernel for which occupancy is calculated
        blockSize : int
            Block size the kernel is intended to be launched with
        dynamicSMemSize : size_t
            Per-block dynamic shared memory usage intended, in bytes
        flags : unsigned int
            Requested behavior for the occupancy calculator

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        numBlocks : int
            Returned occupancy

        See Also
        --------
        :py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`
    """


def cuOccupancyMaxActiveClusters(func, config: 'Optional[CUlaunchConfig]'):
    """
    cuOccupancyMaxActiveClusters(func, CUlaunchConfig config: Optional[CUlaunchConfig])
     Given the kernel function (`func`) and launch configuration (`config`), return the maximum number of clusters that could co-exist on the target device in `*numClusters`.

        If the function has required cluster size already set (see
        :py:obj:`~.cudaFuncGetAttributes` / :py:obj:`~.cuFuncGetAttribute`),
        the cluster size from config must either be unspecified or match the
        required size. Without required sizes, the cluster size must be
        specified in config, else the function will return an error.

        Note that various attributes of the kernel function may affect
        occupancy calculation. Runtime environment may affect how the hardware
        schedules the clusters, so the calculated occupancy is not guaranteed
        to be achievable.

        Note that the API can also be used with context-less kernel
        :py:obj:`~.CUkernel` by querying the handle using
        :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
        casting to :py:obj:`~.CUfunction`. Here, the context to use for
        calculations will either be taken from the specified stream
        `config->hStream` or the current context in case of NULL stream.

        Parameters
        ----------
        func : :py:obj:`~.CUfunction`
            Kernel function for which maximum number of clusters are calculated
        config : :py:obj:`~.CUlaunchConfig`
            Launch configuration for the given kernel function

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_CLUSTER_SIZE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        numClusters : int
            Returned maximum number of clusters that could co-exist on the
            target device

        See Also
        --------
        :py:obj:`~.cudaFuncGetAttributes`, :py:obj:`~.cuFuncGetAttribute`
    """


def cuOccupancyMaxPotentialBlockSize(func, blockSizeToDynamicSMemSize, dynamicSMemSize, blockSizeLimit):
    """
    cuOccupancyMaxPotentialBlockSize(func, blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit)
     Suggest a launch configuration with reasonable occupancy.

        Returns in `*blockSize` a reasonable block size that can achieve the
        maximum occupancy (or, the maximum number of active warps with the
        fewest blocks per multiprocessor), and in `*minGridSize` the minimum
        grid size to achieve the maximum occupancy.

        If `blockSizeLimit` is 0, the configurator will use the maximum block
        size permitted by the device / function instead.

        If per-block dynamic shared memory allocation is not needed, the user
        should leave both `blockSizeToDynamicSMemSize` and `dynamicSMemSize` as
        0.

        If per-block dynamic shared memory allocation is needed, then if the
        dynamic shared memory size is constant regardless of block size, the
        size should be passed through `dynamicSMemSize`, and
        `blockSizeToDynamicSMemSize` should be NULL.

        Otherwise, if the per-block dynamic shared memory size varies with
        different block sizes, the user needs to provide a unary function
        through `blockSizeToDynamicSMemSize` that computes the dynamic shared
        memory needed by `func` for any given block size. `dynamicSMemSize` is
        ignored. An example signature is:

        **View CUDA Toolkit Documentation for a C++ code example**

        Note that the API can also be used with context-less kernel
        :py:obj:`~.CUkernel` by querying the handle using
        :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
        casting to :py:obj:`~.CUfunction`. Here, the context to use for
        calculations will be the current context.

        Parameters
        ----------
        func : :py:obj:`~.CUfunction`
            Kernel for which launch configuration is calculated
        blockSizeToDynamicSMemSize : :py:obj:`~.CUoccupancyB2DSize`
            A function that calculates how much per-block dynamic shared memory
            `func` uses based on the block size
        dynamicSMemSize : size_t
            Dynamic shared memory usage intended, in bytes
        blockSizeLimit : int
            The maximum block size `func` is designed to handle

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        minGridSize : int
            Returned minimum grid size needed to achieve the maximum occupancy
        blockSize : int
            Returned maximum block size that can achieve the maximum occupancy

        See Also
        --------
        :py:obj:`~.cudaOccupancyMaxPotentialBlockSize`
    """


def cuOccupancyMaxPotentialBlockSizeWithFlags(func, blockSizeToDynamicSMemSize, dynamicSMemSize, blockSizeLimit, flags):
    """
    cuOccupancyMaxPotentialBlockSizeWithFlags(func, blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned int flags)
     Suggest a launch configuration with reasonable occupancy.

        An extended version of :py:obj:`~.cuOccupancyMaxPotentialBlockSize`. In
        addition to arguments passed to
        :py:obj:`~.cuOccupancyMaxPotentialBlockSize`,
        :py:obj:`~.cuOccupancyMaxPotentialBlockSizeWithFlags` also takes a
        `Flags` parameter.

        The `Flags` parameter controls how special cases are handled. The valid
        flags are:

        - :py:obj:`~.CU_OCCUPANCY_DEFAULT`, which maintains the default
          behavior as :py:obj:`~.cuOccupancyMaxPotentialBlockSize`;

        - :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE`, which suppresses
          the default behavior on platform where global caching affects
          occupancy. On such platforms, the launch configurations that produces
          maximal occupancy might not support global caching. Setting
          :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE` guarantees that the
          the produced launch configuration is global caching compatible at a
          potential cost of occupancy. More information can be found about this
          feature in the "Unified L1/Texture Cache" section of the Maxwell
          tuning guide.

        Note that the API can also be used with context-less kernel
        :py:obj:`~.CUkernel` by querying the handle using
        :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
        casting to :py:obj:`~.CUfunction`. Here, the context to use for
        calculations will be the current context.

        Parameters
        ----------
        func : :py:obj:`~.CUfunction`
            Kernel for which launch configuration is calculated
        blockSizeToDynamicSMemSize : :py:obj:`~.CUoccupancyB2DSize`
            A function that calculates how much per-block dynamic shared memory
            `func` uses based on the block size
        dynamicSMemSize : size_t
            Dynamic shared memory usage intended, in bytes
        blockSizeLimit : int
            The maximum block size `func` is designed to handle
        flags : unsigned int
            Options

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        minGridSize : int
            Returned minimum grid size needed to achieve the maximum occupancy
        blockSize : int
            Returned maximum block size that can achieve the maximum occupancy

        See Also
        --------
        :py:obj:`~.cudaOccupancyMaxPotentialBlockSizeWithFlags`
    """


def cuOccupancyMaxPotentialClusterSize(func, config: 'Optional[CUlaunchConfig]'):
    """
    cuOccupancyMaxPotentialClusterSize(func, CUlaunchConfig config: Optional[CUlaunchConfig])
     Given the kernel function (`func`) and launch configuration (`config`), return the maximum cluster size in `*clusterSize`.

        The cluster dimensions in `config` are ignored. If func has a required
        cluster size set (see :py:obj:`~.cudaFuncGetAttributes` /
        :py:obj:`~.cuFuncGetAttribute`),`*clusterSize` will reflect the
        required cluster size.

        By default this function will always return a value that's portable on
        future hardware. A higher value may be returned if the kernel function
        allows non-portable cluster sizes.

        This function will respect the compile time launch bounds.

        Note that the API can also be used with context-less kernel
        :py:obj:`~.CUkernel` by querying the handle using
        :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
        casting to :py:obj:`~.CUfunction`. Here, the context to use for
        calculations will either be taken from the specified stream
        `config->hStream` or the current context in case of NULL stream.

        Parameters
        ----------
        func : :py:obj:`~.CUfunction`
            Kernel function for which maximum cluster size is calculated
        config : :py:obj:`~.CUlaunchConfig`
            Launch configuration for the given kernel function

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
        clusterSize : int
            Returned maximum cluster size that can be launched for the given
            kernel function and launch configuration

        See Also
        --------
        :py:obj:`~.cudaFuncGetAttributes`, :py:obj:`~.cuFuncGetAttribute`
    """


def cuParamSetSize(hfunc, numbytes):
    """
    cuParamSetSize(hfunc, unsigned int numbytes)
     Sets the parameter size for the function.

        [Deprecated]

        Sets through `numbytes` the total size in bytes needed by the function
        parameters of the kernel corresponding to `hfunc`.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            Kernel to set parameter size for
        numbytes : unsigned int
            Size of parameter list in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """


def cuParamSetTexRef(hfunc, texunit, hTexRef):
    """
    cuParamSetTexRef(hfunc, int texunit, hTexRef)
     Adds a texture-reference to the function's argument list.

        [Deprecated]

        Makes the CUDA array or linear memory bound to the texture reference
        `hTexRef` available to a device program as a texture. In this version
        of CUDA, the texture-reference must be obtained via
        :py:obj:`~.cuModuleGetTexRef()` and the `texunit` parameter must be set
        to :py:obj:`~.CU_PARAM_TR_DEFAULT`.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            Kernel to add texture-reference to
        texunit : int
            Texture unit (must be :py:obj:`~.CU_PARAM_TR_DEFAULT`)
        hTexRef : :py:obj:`~.CUtexref`
            Texture-reference to add to argument list

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    """


def cuParamSetf(hfunc, offset, value):
    """
    cuParamSetf(hfunc, int offset, float value)
     Adds a floating-point parameter to the function's argument list.

        [Deprecated]

        Sets a floating-point parameter that will be specified the next time
        the kernel corresponding to `hfunc` will be invoked. `offset` is a byte
        offset.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            Kernel to add parameter to
        offset : int
            Offset to add parameter to argument list
        value : float
            Value of parameter

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """


def cuParamSeti(hfunc, offset, value):
    """
    cuParamSeti(hfunc, int offset, unsigned int value)
     Adds an integer parameter to the function's argument list.

        [Deprecated]

        Sets an integer parameter that will be specified the next time the
        kernel corresponding to `hfunc` will be invoked. `offset` is a byte
        offset.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            Kernel to add parameter to
        offset : int
            Offset to add parameter to argument list
        value : unsigned int
            Value of parameter

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """


def cuParamSetv(hfunc, offset, ptr, numbytes):
    """
    cuParamSetv(hfunc, int offset, ptr, unsigned int numbytes)
     Adds arbitrary data to the function's argument list.

        [Deprecated]

        Copies an arbitrary amount of data (specified in `numbytes`) from `ptr`
        into the parameter space of the kernel corresponding to `hfunc`.
        `offset` is a byte offset.

        Parameters
        ----------
        hfunc : :py:obj:`~.CUfunction`
            Kernel to add data to
        offset : int
            Offset to add data to argument list
        ptr : Any
            Pointer to arbitrary data
        numbytes : unsigned int
            Size of data to copy in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """


def cuPointerGetAttribute(attribute: 'CUpointer_attribute', ptr):
    """
    cuPointerGetAttribute(attribute: CUpointer_attribute, ptr)
     Returns information about a pointer.

        The supported attributes are:

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_CONTEXT`:

        - Returns in `*data` the :py:obj:`~.CUcontext` in which `ptr` was
          allocated or registered. The type of `data` must be
          :py:obj:`~.CUcontext` *.

        - If `ptr` was not allocated by, mapped by, or registered with a
          :py:obj:`~.CUcontext` which uses unified virtual addressing then
          :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMORY_TYPE`:

        - Returns in `*data` the physical memory type of the memory that `ptr`
          addresses as a :py:obj:`~.CUmemorytype` enumerated value. The type of
          `data` must be unsigned int.

        - If `ptr` addresses device memory then `*data` is set to
          :py:obj:`~.CU_MEMORYTYPE_DEVICE`. The particular :py:obj:`~.CUdevice`
          on which the memory resides is the :py:obj:`~.CUdevice` of the
          :py:obj:`~.CUcontext` returned by the
          :py:obj:`~.CU_POINTER_ATTRIBUTE_CONTEXT` attribute of `ptr`.

        - If `ptr` addresses host memory then `*data` is set to
          :py:obj:`~.CU_MEMORYTYPE_HOST`.

        - If `ptr` was not allocated by, mapped by, or registered with a
          :py:obj:`~.CUcontext` which uses unified virtual addressing then
          :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

        - If the current :py:obj:`~.CUcontext` does not support unified virtual
          addressing then :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_POINTER`:

        - Returns in `*data` the device pointer value through which `ptr` may
          be accessed by kernels running in the current :py:obj:`~.CUcontext`.
          The type of `data` must be CUdeviceptr *.

        - If there exists no device pointer value through which kernels running
          in the current :py:obj:`~.CUcontext` may access `ptr` then
          :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

        - If there is no current :py:obj:`~.CUcontext` then
          :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

        - Except in the exceptional disjoint addressing cases discussed below,
          the value returned in `*data` will equal the input value `ptr`.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_HOST_POINTER`:

        - Returns in `*data` the host pointer value through which `ptr` may be
          accessed by by the host program. The type of `data` must be void **.
          If there exists no host pointer value through which the host program
          may directly access `ptr` then :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
          is returned.

        - Except in the exceptional disjoint addressing cases discussed below,
          the value returned in `*data` will equal the input value `ptr`.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_P2P_TOKENS`:

        - Returns in `*data` two tokens for use with the nv-p2p.h Linux kernel
          interface. `data` must be a struct of type
          CUDA_POINTER_ATTRIBUTE_P2P_TOKENS.

        - `ptr` must be a pointer to memory obtained from
          :py:obj:`~.py`:obj:`~.cuMemAlloc()`. Note that p2pToken and
          vaSpaceToken are only valid for the lifetime of the source
          allocation. A subsequent allocation at the same address may return
          completely different tokens. Querying this attribute has a side
          effect of setting the attribute
          :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS` for the region of memory
          that `ptr` points to.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS`:

        - A boolean attribute which when set, ensures that synchronous memory
          operations initiated on the region of memory that `ptr` points to
          will always synchronize. See further documentation in the section
          titled "API synchronization behavior" to learn more about cases when
          synchronous memory operations can exhibit asynchronous behavior.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_BUFFER_ID`:

        - Returns in `*data` a buffer ID which is guaranteed to be unique
          within the process. `data` must point to an unsigned long long.

        - `ptr` must be a pointer to memory obtained from a CUDA memory
          allocation API. Every memory allocation from any of the CUDA memory
          allocation APIs will have a unique ID over a process lifetime.
          Subsequent allocations do not reuse IDs from previous freed
          allocations. IDs are only unique within a single process.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_MANAGED`:

        - Returns in `*data` a boolean that indicates whether the pointer
          points to managed memory or not.

        - If `ptr` is not a valid CUDA pointer then
          :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL`:

        - Returns in `*data` an integer representing a device ordinal of a
          device against which the memory was allocated or registered.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE`:

        - Returns in `*data` a boolean that indicates if this pointer maps to
          an allocation that is suitable for :py:obj:`~.cudaIpcGetMemHandle`.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_START_ADDR`:

        - Returns in `*data` the starting address for the allocation referenced
          by the device pointer `ptr`. Note that this is not necessarily the
          address of the mapped region, but the address of the mappable address
          range `ptr` references (e.g. from :py:obj:`~.cuMemAddressReserve`).

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_SIZE`:

        - Returns in `*data` the size for the allocation referenced by the
          device pointer `ptr`. Note that this is not necessarily the size of
          the mapped region, but the size of the mappable address range `ptr`
          references (e.g. from :py:obj:`~.cuMemAddressReserve`). To retrieve
          the size of the mapped region, see :py:obj:`~.cuMemGetAddressRange`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_MAPPED`:

        - Returns in `*data` a boolean that indicates if this pointer is in a
          valid address range that is mapped to a backing allocation.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES`:

        - Returns a bitmask of the allowed handle types for an allocation that
          may be passed to :py:obj:`~.cuMemExportToShareableHandle`.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE`:

        - Returns in `*data` the handle to the mempool that the allocation was
          obtained from.

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE`:

        - Returns in `*data` a boolean that indicates whether the pointer
          points to memory that is capable to be used for hardware accelerated
          decompression.

        Note that for most allocations in the unified virtual address space the
        host and device pointer for accessing the allocation will be the same.
        The exceptions to this are

        - user memory registered using :py:obj:`~.cuMemHostRegister`

        - host memory allocated using :py:obj:`~.cuMemHostAlloc` with the
          :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED` flag For these types of
          allocation there will exist separate, disjoint host and device
          addresses for accessing the allocation. In particular

        - The host address will correspond to an invalid unmapped device
          address (which will result in an exception if accessed from the
          device)

        - The device address will correspond to an invalid unmapped host
          address (which will result in an exception if accessed from the
          host). For these types of allocations, querying
          :py:obj:`~.CU_POINTER_ATTRIBUTE_HOST_POINTER` and
          :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_POINTER` may be used to
          retrieve the host and device addresses from either address.

        Parameters
        ----------
        attribute : :py:obj:`~.CUpointer_attribute`
            Pointer attribute to query
        ptr : :py:obj:`~.CUdeviceptr`
            Pointer

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        data : Any
            Returned pointer attribute value

        See Also
        --------
        :py:obj:`~.cuPointerSetAttribute`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuMemHostUnregister`, :py:obj:`~.cudaPointerGetAttributes`
    """


def cuPointerGetAttributes(numAttributes, attributes: 'Optional[Tuple[CUpointer_attribute] | List[CUpointer_attribute]]', ptr):
    """
    cuPointerGetAttributes(unsigned int numAttributes, attributes: Optional[Tuple[CUpointer_attribute] | List[CUpointer_attribute]], ptr)
     Returns information about a pointer.

        The supported attributes are (refer to
        :py:obj:`~.cuPointerGetAttribute` for attribute descriptions and
        restrictions):

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_CONTEXT`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMORY_TYPE`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_POINTER`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_HOST_POINTER`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_BUFFER_ID`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_MANAGED`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_START_ADDR`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_SIZE`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_MAPPED`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE`

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE`

        Unlike :py:obj:`~.cuPointerGetAttribute`, this function will not return
        an error when the `ptr` encountered is not a valid CUDA pointer.
        Instead, the attributes are assigned default NULL values and
        CUDA_SUCCESS is returned.

        If `ptr` was not allocated by, mapped by, or registered with a
        :py:obj:`~.CUcontext` which uses UVA (Unified Virtual Addressing),
        :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

        Parameters
        ----------
        numAttributes : unsigned int
            Number of attributes to query
        attributes : List[:py:obj:`~.CUpointer_attribute`]
            An array of attributes to query (numAttributes and the number of
            attributes in this array should match)
        ptr : :py:obj:`~.CUdeviceptr`
            Pointer to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
        data : List[Any]
            A two-dimensional array containing pointers to memory locations
            where the result of each attribute query will be written to.

        See Also
        --------
        :py:obj:`~.cuPointerGetAttribute`, :py:obj:`~.cuPointerSetAttribute`, :py:obj:`~.cudaPointerGetAttributes`
    """


def cuPointerSetAttribute(value, attribute: 'CUpointer_attribute', ptr):
    """
    cuPointerSetAttribute(value, attribute: CUpointer_attribute, ptr)
     Set attributes on a previously allocated memory region.

        The supported attributes are:

        - :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS`:

        - A boolean attribute that can either be set (1) or unset (0). When
          set, the region of memory that `ptr` points to is guaranteed to
          always synchronize memory operations that are synchronous. If there
          are some previously initiated synchronous memory operations that are
          pending when this attribute is set, the function does not return
          until those memory operations are complete. See further documentation
          in the section titled "API synchronization behavior" to learn more
          about cases when synchronous memory operations can exhibit
          asynchronous behavior. `value` will be considered as a pointer to an
          unsigned integer to which this attribute is to be set.

        Parameters
        ----------
        value : Any
            Pointer to memory containing the value to be set
        attribute : :py:obj:`~.CUpointer_attribute`
            Pointer attribute to set
        ptr : :py:obj:`~.CUdeviceptr`
            Pointer to a memory region allocated using CUDA memory allocation
            APIs

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

        See Also
        --------
        :py:obj:`~.cuPointerGetAttribute`, :py:obj:`~.cuPointerGetAttributes`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuMemHostUnregister`
    """


def cuProfilerStart():
    """
    cuProfilerStart()
     Enable profiling.

        Enables profile collection by the active profiling tool for the current
        context. If profiling is already enabled, then
        :py:obj:`~.cuProfilerStart()` has no effect.

        cuProfilerStart and cuProfilerStop APIs are used to programmatically
        control the profiling granularity by allowing profiling to be done only
        on selective pieces of code.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

        See Also
        --------
        :py:obj:`~.cuProfilerInitialize`, :py:obj:`~.cuProfilerStop`, :py:obj:`~.cudaProfilerStart`
    """


def cuProfilerStop():
    """
    cuProfilerStop()
     Disable profiling.

        Disables profile collection by the active profiling tool for the
        current context. If profiling is already disabled, then
        :py:obj:`~.cuProfilerStop()` has no effect.

        cuProfilerStart and cuProfilerStop APIs are used to programmatically
        control the profiling granularity by allowing profiling to be done only
        on selective pieces of code.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

        See Also
        --------
        :py:obj:`~.cuProfilerInitialize`, :py:obj:`~.cuProfilerStart`, :py:obj:`~.cudaProfilerStop`
    """


def cuSignalExternalSemaphoresAsync(extSemArray: 'Optional[Tuple[CUexternalSemaphore] | List[CUexternalSemaphore]]', paramsArray: 'Optional[Tuple[CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS] | List[CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS]]', numExtSems, stream):
    """
    cuSignalExternalSemaphoresAsync(extSemArray: Optional[Tuple[CUexternalSemaphore] | List[CUexternalSemaphore]], paramsArray: Optional[Tuple[CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS] | List[CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS]], unsigned int numExtSems, stream)
     Signals a set of external semaphore objects.

        Enqueues a signal operation on a set of externally allocated semaphore
        object in the specified stream. The operations will be executed when
        all prior operations in the stream complete.

        The exact semantics of signaling a semaphore depends on the type of the
        object.

        If the semaphore object is any one of the following types:
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT` then
        signaling the semaphore will set it to the signaled state.

        If the semaphore object is any one of the following types:
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32`
        then the semaphore will be set to the value specified in
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::fence::value.

        If the semaphore object is of the type
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC` this API sets
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::nvSciSync::fence
        to a value that can be used by subsequent waiters of the same NvSciSync
        object to order operations with those currently submitted in `stream`.
        Such an update will overwrite previous contents of
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::nvSciSync::fence.
        By default, signaling such an external semaphore object causes
        appropriate memory synchronization operations to be performed over all
        external memory objects that are imported as
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`. This ensures that
        any subsequent accesses made by other importers of the same set of
        NvSciBuf memory object(s) are coherent. These operations can be skipped
        by specifying the flag
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC`, which
        can be used as a performance optimization when data coherency is not
        required. But specifying this flag in scenarios where data coherency is
        required results in undefined behavior. Also, for semaphore object of
        the type :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC`, if
        the NvSciSyncAttrList used to create the NvSciSyncObj had not set the
        flags in :py:obj:`~.cuDeviceGetNvSciSyncAttributes` to
        CUDA_NVSCISYNC_ATTR_SIGNAL, this API will return
        CUDA_ERROR_NOT_SUPPORTED. NvSciSyncFence associated with semaphore
        object of the type
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC` can be
        deterministic. For this the NvSciSyncAttrList used to create the
        semaphore object must have value of
        NvSciSyncAttrKey_RequireDeterministicFences key set to true.
        Deterministic fences allow users to enqueue a wait over the semaphore
        object even before corresponding signal is enqueued. For such a
        semaphore object, CUDA guarantees that each signal operation will
        increment the fence value by '1'. Users are expected to track count of
        signals enqueued on the semaphore object and insert waits accordingly.
        When such a semaphore object is signaled from multiple streams, due to
        concurrent stream execution, it is possible that the order in which the
        semaphore gets signaled is indeterministic. This could lead to waiters
        of the semaphore getting unblocked incorrectly. Users are expected to
        handle such situations, either by not using the same semaphore object
        with deterministic fence support enabled in different streams or by
        adding explicit dependency amongst such streams so that the semaphore
        is signaled in order.

        If the semaphore object is any one of the following types:
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT`
        then the keyed mutex will be released with the key specified in
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_PARAMS`::params::keyedmutex::key.

        Parameters
        ----------
        extSemArray : List[:py:obj:`~.CUexternalSemaphore`]
            Set of external semaphores to be signaled
        paramsArray : List[:py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`]
            Array of semaphore parameters
        numExtSems : unsigned int
            Number of semaphores to signal
        stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to enqueue the signal operations in

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """


def cuStreamAddCallback(hStream, callback, userData, flags):
    """
    cuStreamAddCallback(hStream, callback, userData, unsigned int flags)
     Add a callback to a compute stream.

        Adds a callback to be called on the host after all currently enqueued
        items in the stream have completed. For each cuStreamAddCallback call,
        the callback will be executed exactly once. The callback will block
        later work in the stream until it is finished.

        The callback may be passed :py:obj:`~.CUDA_SUCCESS` or an error code.
        In the event of a device error, all subsequently executed callbacks
        will receive an appropriate :py:obj:`~.CUresult`.

        Callbacks must not make any CUDA API calls. Attempting to use a CUDA
        API will result in :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`. Callbacks must
        not perform any synchronization that may depend on outstanding device
        work or other callbacks that are not mandated to run earlier. Callbacks
        without a mandated order (in independent streams) execute in undefined
        order and may be serialized.

        For the purposes of Unified Memory, callback execution makes a number
        of guarantees:

        - The callback stream is considered idle for the duration of the
          callback. Thus, for example, a callback may always use memory
          attached to the callback stream.

        - The start of execution of a callback has the same effect as
          synchronizing an event recorded in the same stream immediately prior
          to the callback. It thus synchronizes streams which have been
          "joined" prior to the callback.

        - Adding device work to any stream does not have the effect of making
          the stream active until all preceding host functions and stream
          callbacks have executed. Thus, for example, a callback might use
          global attached memory even if work has been added to another stream,
          if the work has been ordered behind the callback with an event.

        - Completion of a callback does not cause a stream to become active
          except as described above. The callback stream will remain idle if no
          device work follows the callback, and will remain idle across
          consecutive callbacks without device work in between. Thus, for
          example, stream synchronization can be done by signaling from a
          callback at the end of the stream.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to add callback to
        callback : :py:obj:`~.CUstreamCallback`
            The function to call once preceding stream operations are complete
        userData : Any
            User specified data to be passed to the callback function
        flags : unsigned int
            Reserved for future use, must be 0

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cuStreamAttachMemAsync`, :py:obj:`~.cuLaunchHostFunc`, :py:obj:`~.cudaStreamAddCallback`

        Notes
        -----
        This function is slated for eventual deprecation and removal. If you do not require the callback to execute in case of a device error, consider using :py:obj:`~.cuLaunchHostFunc`. Additionally, this function is not supported with :py:obj:`~.cuStreamBeginCapture` and :py:obj:`~.cuStreamEndCapture`, unlike :py:obj:`~.cuLaunchHostFunc`.
    """


def cuStreamAttachMemAsync(hStream, dptr, length, flags):
    """
    cuStreamAttachMemAsync(hStream, dptr, size_t length, unsigned int flags)
     Attach memory to a stream asynchronously.

        Enqueues an operation in `hStream` to specify stream association of
        `length` bytes of memory starting from `dptr`. This function is a
        stream-ordered operation, meaning that it is dependent on, and will
        only take effect when, previous work in stream has completed. Any
        previous association is automatically replaced.

        `dptr` must point to one of the following types of memories:

        - managed memory declared using the managed keyword or allocated with
          :py:obj:`~.cuMemAllocManaged`.

        - a valid host-accessible region of system-allocated pageable memory.
          This type of memory may only be specified if the device associated
          with the stream reports a non-zero value for the device attribute
          :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`.

        For managed allocations, `length` must be either zero or the entire
        allocation's size. Both indicate that the entire allocation's stream
        association is being changed. Currently, it is not possible to change
        stream association for a portion of a managed allocation.

        For pageable host allocations, `length` must be non-zero.

        The stream association is specified using `flags` which must be one of
        :py:obj:`~.CUmemAttach_flags`. If the :py:obj:`~.CU_MEM_ATTACH_GLOBAL`
        flag is specified, the memory can be accessed by any stream on any
        device. If the :py:obj:`~.CU_MEM_ATTACH_HOST` flag is specified, the
        program makes a guarantee that it won't access the memory on the device
        from any stream on a device that has a zero value for the device
        attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. If
        the :py:obj:`~.CU_MEM_ATTACH_SINGLE` flag is specified and `hStream` is
        associated with a device that has a zero value for the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`, the program
        makes a guarantee that it will only access the memory on the device
        from `hStream`. It is illegal to attach singly to the NULL stream,
        because the NULL stream is a virtual global stream and not a specific
        stream. An error will be returned in this case.

        When memory is associated with a single stream, the Unified Memory
        system will allow CPU access to this memory region so long as all
        operations in `hStream` have completed, regardless of whether other
        streams are active. In effect, this constrains exclusive ownership of
        the managed memory region by an active GPU to per-stream activity
        instead of whole-GPU activity.

        Accessing memory on the device from streams that are not associated
        with it will produce undefined results. No error checking is performed
        by the Unified Memory system to ensure that kernels launched into other
        streams do not access this region.

        It is a program's responsibility to order calls to
        :py:obj:`~.cuStreamAttachMemAsync` via events, synchronization or other
        means to ensure legal access to memory at all times. Data visibility
        and coherency will be changed appropriately for all kernels which
        follow a stream-association change.

        If `hStream` is destroyed while data is associated with it, the
        association is removed and the association reverts to the default
        visibility of the allocation as specified at
        :py:obj:`~.cuMemAllocManaged`. For managed variables, the default
        association is always :py:obj:`~.CU_MEM_ATTACH_GLOBAL`. Note that
        destroying a stream is an asynchronous operation, and as a result, the
        change to default association won't happen until all work in the stream
        has completed.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream in which to enqueue the attach operation
        dptr : :py:obj:`~.CUdeviceptr`
            Pointer to memory (must be a pointer to managed memory or to a
            valid host-accessible region of system-allocated pageable memory)
        length : size_t
            Length of memory
        flags : unsigned int
            Must be one of :py:obj:`~.CUmemAttach_flags`

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cudaStreamAttachMemAsync`
    """


def cuStreamBatchMemOp(stream, count, paramArray: 'Optional[Tuple[CUstreamBatchMemOpParams] | List[CUstreamBatchMemOpParams]]', flags):
    """
    cuStreamBatchMemOp(stream, unsigned int count, paramArray: Optional[Tuple[CUstreamBatchMemOpParams] | List[CUstreamBatchMemOpParams]], unsigned int flags)
     Batch operations to synchronize the stream via memory operations.

        This is a batch version of :py:obj:`~.cuStreamWaitValue32()` and
        :py:obj:`~.cuStreamWriteValue32()`. Batching operations may avoid some
        performance overhead in both the API call and the device execution
        versus adding them to the stream in separate API calls. The operations
        are enqueued in the order they appear in the array.

        See :py:obj:`~.CUstreamBatchMemOpType` for the full set of supported
        operations, and :py:obj:`~.cuStreamWaitValue32()`,
        :py:obj:`~.cuStreamWaitValue64()`, :py:obj:`~.cuStreamWriteValue32()`,
        and :py:obj:`~.cuStreamWriteValue64()` for details of specific
        operations.

        See related APIs for details on querying support for specific
        operations.

        Parameters
        ----------
        stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream to enqueue the operations in.
        count : unsigned int
            The number of operations in the array. Must be less than 256.
        paramArray : List[:py:obj:`~.CUstreamBatchMemOpParams`]
            The types and parameters of the individual operations.
        flags : unsigned int
            Reserved for future expansion; must be 0.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuMemHostRegister`

        Notes
        -----
        Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order. For more information, see the Stream Memory Operations section in the programming guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).
    """


def cuStreamBeginCapture(hStream, mode: 'CUstreamCaptureMode'):
    """
    cuStreamBeginCapture(hStream, mode: CUstreamCaptureMode)
     Begins graph capture on a stream.

        Begin graph capture on `hStream`. When a stream is in capture mode, all
        operations pushed into the stream will not be executed, but will
        instead be captured into a graph, which will be returned via
        :py:obj:`~.cuStreamEndCapture`. Capture may not be initiated if
        `stream` is CU_STREAM_LEGACY. Capture must be ended on the same stream
        in which it was initiated, and it may only be initiated if the stream
        is not already in capture mode. The capture mode may be queried via
        :py:obj:`~.cuStreamIsCapturing`. A unique id representing the capture
        sequence may be queried via :py:obj:`~.cuStreamGetCaptureInfo`.

        If `mode` is not :py:obj:`~.CU_STREAM_CAPTURE_MODE_RELAXED`,
        :py:obj:`~.cuStreamEndCapture` must be called on this stream from the
        same thread.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream in which to initiate capture
        mode : :py:obj:`~.CUstreamCaptureMode`
            Controls the interaction of this capture sequence with other API
            calls that are potentially unsafe. For more details see
            :py:obj:`~.cuThreadExchangeStreamCaptureMode`.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamIsCapturing`, :py:obj:`~.cuStreamEndCapture`, :py:obj:`~.cuThreadExchangeStreamCaptureMode`

        Notes
        -----
        Kernels captured using this API must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.
    """


def cuStreamBeginCaptureToGraph(hStream, hGraph, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', dependencyData: 'Optional[Tuple[CUgraphEdgeData] | List[CUgraphEdgeData]]', numDependencies, mode: 'CUstreamCaptureMode'):
    """
    cuStreamBeginCaptureToGraph(hStream, hGraph, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], dependencyData: Optional[Tuple[CUgraphEdgeData] | List[CUgraphEdgeData]], size_t numDependencies, mode: CUstreamCaptureMode)
     Begins graph capture on a stream to an existing graph.

        Begin graph capture on `hStream`, placing new nodes into an existing
        graph. When a stream is in capture mode, all operations pushed into the
        stream will not be executed, but will instead be captured into
        `hGraph`. The graph will not be instantiable until the user calls
        :py:obj:`~.cuStreamEndCapture`.

        Capture may not be initiated if `stream` is CU_STREAM_LEGACY. Capture
        must be ended on the same stream in which it was initiated, and it may
        only be initiated if the stream is not already in capture mode. The
        capture mode may be queried via :py:obj:`~.cuStreamIsCapturing`. A
        unique id representing the capture sequence may be queried via
        :py:obj:`~.cuStreamGetCaptureInfo`.

        If `mode` is not :py:obj:`~.CU_STREAM_CAPTURE_MODE_RELAXED`,
        :py:obj:`~.cuStreamEndCapture` must be called on this stream from the
        same thread.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream in which to initiate capture.
        hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
            Graph to capture into.
        dependencies : List[:py:obj:`~.CUgraphNode`]
            Dependencies of the first node captured in the stream. Can be NULL
            if numDependencies is 0.
        dependencyData : List[:py:obj:`~.CUgraphEdgeData`]
            Optional array of data associated with each dependency.
        numDependencies : size_t
            Number of dependencies.
        mode : :py:obj:`~.CUstreamCaptureMode`
            Controls the interaction of this capture sequence with other API
            calls that are potentially unsafe. For more details see
            :py:obj:`~.cuThreadExchangeStreamCaptureMode`.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamIsCapturing`, :py:obj:`~.cuStreamEndCapture`, :py:obj:`~.cuThreadExchangeStreamCaptureMode`, :py:obj:`~.cuGraphAddNode`,

        Notes
        -----
        Kernels captured using this API must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.
    """


def cuStreamCopyAttributes(dst, src):
    """
    cuStreamCopyAttributes(dst, src)
     Copies attributes from source stream to destination stream.

        Copies attributes from source stream `src` to destination stream `dst`.
        Both streams must have the same context.

        Parameters
        ----------
        dst : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Destination stream
        src : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Source stream For list of attributes see :py:obj:`~.CUstreamAttrID`

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.CUaccessPolicyWindow`
    """


def cuStreamCreate(Flags):
    """
    cuStreamCreate(unsigned int Flags)
     Create a stream.

        Creates a stream and returns a handle in `phStream`. The `Flags`
        argument determines behaviors of the stream.

        Valid values for `Flags` are:

        - :py:obj:`~.CU_STREAM_DEFAULT`: Default stream creation flag.

        - :py:obj:`~.CU_STREAM_NON_BLOCKING`: Specifies that work running in
          the created stream may run concurrently with work in stream 0 (the
          NULL stream), and that the created stream should perform no implicit
          synchronization with stream 0.

        Parameters
        ----------
        Flags : unsigned int
            Parameters for stream creation

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        phStream : :py:obj:`~.CUstream`
            Returned newly created stream

        See Also
        --------
        :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice` :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`
    """


def cuStreamCreateWithPriority(flags, priority):
    """
    cuStreamCreateWithPriority(unsigned int flags, int priority)
     Create a stream with the given priority.

        Creates a stream with the specified priority and returns a handle in
        `phStream`. This affects the scheduling priority of work in the stream.
        Priorities provide a hint to preferentially run work with higher
        priority when possible, but do not preempt already-running work or
        provide any other functional guarantee on execution order.

        `priority` follows a convention where lower numbers represent higher
        priorities. '0' represents default priority. The range of meaningful
        numerical priorities can be queried using
        :py:obj:`~.cuCtxGetStreamPriorityRange`. If the specified priority is
        outside the numerical range returned by
        :py:obj:`~.cuCtxGetStreamPriorityRange`, it will automatically be
        clamped to the lowest or the highest number in the range.

        Parameters
        ----------
        flags : unsigned int
            Flags for stream creation. See :py:obj:`~.cuStreamCreate` for a
            list of valid flags
        priority : int
            Stream priority. Lower numbers represent higher priorities. See
            :py:obj:`~.cuCtxGetStreamPriorityRange` for more information about
            meaningful stream priorities that can be passed.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        phStream : :py:obj:`~.CUstream`
            Returned newly created stream

        See Also
        --------
        :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice` :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreateWithPriority`

        Notes
        -----
        Stream priorities are supported only on GPUs with compute capability 3.5 or higher.

        In the current implementation, only compute kernels launched in priority streams are affected by the stream's priority. Stream priorities have no effect on host-to-device and device-to-host memory operations.
    """


def cuStreamDestroy(hStream):
    """
    cuStreamDestroy(hStream)
     Destroys a stream.

        Destroys the stream specified by `hStream`.

        In case the device is still doing work in the stream `hStream` when
        :py:obj:`~.cuStreamDestroy()` is called, the function will return
        immediately and the resources associated with `hStream` will be
        released automatically once the device has completed all work in
        `hStream`.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to destroy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamDestroy`
    """


def cuStreamEndCapture(hStream):
    """
    cuStreamEndCapture(hStream)
     Ends capture on a stream, returning the captured graph.

        End capture on `hStream`, returning the captured graph via `phGraph`.
        Capture must have been initiated on `hStream` via a call to
        :py:obj:`~.cuStreamBeginCapture`. If capture was invalidated, due to a
        violation of the rules of stream capture, then a NULL graph will be
        returned.

        If the `mode` argument to :py:obj:`~.cuStreamBeginCapture` was not
        :py:obj:`~.CU_STREAM_CAPTURE_MODE_RELAXED`, this call must be from the
        same thread as :py:obj:`~.cuStreamBeginCapture`.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD`
        phGraph : :py:obj:`~.CUgraph`
            The captured graph

        See Also
        --------
        :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamIsCapturing`, :py:obj:`~.cuGraphDestroy`
    """


def cuStreamGetAttribute(hStream, attr: 'CUstreamAttrID'):
    """
    cuStreamGetAttribute(hStream, attr: CUstreamAttrID)
     Queries stream attribute.

        Queries attribute `attr` from `hStream` and stores it in corresponding
        member of `value_out`.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`

        attr : :py:obj:`~.CUstreamAttrID`


        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
        value_out : :py:obj:`~.CUstreamAttrValue`


        See Also
        --------
        :py:obj:`~.CUaccessPolicyWindow`
    """


def cuStreamGetCaptureInfo(hStream):
    """
    cuStreamGetCaptureInfo(hStream)
     Query a stream's capture state.

        Query stream state related to stream capture.

        If called on :py:obj:`~.CU_STREAM_LEGACY` (the "null stream") while a
        stream not created with :py:obj:`~.CU_STREAM_NON_BLOCKING` is
        capturing, returns :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`.

        Valid data (other than capture status) is returned only if both of the
        following are true:

        - the call returns CUDA_SUCCESS

        - the returned capture status is
          :py:obj:`~.CU_STREAM_CAPTURE_STATUS_ACTIVE`

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`
        captureStatus_out : :py:obj:`~.CUstreamCaptureStatus`
            Location to return the capture status of the stream; required
        id_out : :py:obj:`~.cuuint64_t`
            Optional location to return an id for the capture sequence, which
            is unique over the lifetime of the process
        graph_out : :py:obj:`~.CUgraph`
            Optional location to return the graph being captured into. All
            operations other than destroy and node removal are permitted on the
            graph while the capture sequence is in progress. This API does not
            transfer ownership of the graph, which is transferred or destroyed
            at :py:obj:`~.cuStreamEndCapture`. Note that the graph handle may
            be invalidated before end of capture for certain errors. Nodes that
            are or become unreachable from the original stream at
            :py:obj:`~.cuStreamEndCapture` due to direct actions on the graph
            do not trigger :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNJOINED`.
        dependencies_out : List[:py:obj:`~.CUgraphNode`]
            Optional location to store a pointer to an array of nodes. The next
            node to be captured in the stream will depend on this set of nodes,
            absent operations such as event wait which modify this set. The
            array pointer is valid until the next API call which operates on
            the stream or until the capture is terminated. The node handles may
            be copied out and are valid until they or the graph is destroyed.
            The driver-owned array may also be passed directly to APIs that
            operate on the graph (not the stream) without copying.
        numDependencies_out : int
            Optional location to store the size of the array returned in
            dependencies_out.

        See Also
        --------
        :py:obj:`~.cuStreamGetCaptureInfo_v3` :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamIsCapturing`, :py:obj:`~.cuStreamUpdateCaptureDependencies`
    """


def cuStreamGetCaptureInfo_v3(hStream):
    """
    cuStreamGetCaptureInfo_v3(hStream)
     Query a stream's capture state (12.3+)

        Query stream state related to stream capture.

        If called on :py:obj:`~.CU_STREAM_LEGACY` (the "null stream") while a
        stream not created with :py:obj:`~.CU_STREAM_NON_BLOCKING` is
        capturing, returns :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`.

        Valid data (other than capture status) is returned only if both of the
        following are true:

        - the call returns CUDA_SUCCESS

        - the returned capture status is
          :py:obj:`~.CU_STREAM_CAPTURE_STATUS_ACTIVE`

        If `edgeData_out` is non-NULL then `dependencies_out` must be as well.
        If `dependencies_out` is non-NULL and `edgeData_out` is NULL, but there
        is non-zero edge data for one or more of the current stream
        dependencies, the call will return :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`, :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`
        captureStatus_out : :py:obj:`~.CUstreamCaptureStatus`
            Location to return the capture status of the stream; required
        id_out : :py:obj:`~.cuuint64_t`
            Optional location to return an id for the capture sequence, which
            is unique over the lifetime of the process
        graph_out : :py:obj:`~.CUgraph`
            Optional location to return the graph being captured into. All
            operations other than destroy and node removal are permitted on the
            graph while the capture sequence is in progress. This API does not
            transfer ownership of the graph, which is transferred or destroyed
            at :py:obj:`~.cuStreamEndCapture`. Note that the graph handle may
            be invalidated before end of capture for certain errors. Nodes that
            are or become unreachable from the original stream at
            :py:obj:`~.cuStreamEndCapture` due to direct actions on the graph
            do not trigger :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNJOINED`.
        dependencies_out : List[:py:obj:`~.CUgraphNode`]
            Optional location to store a pointer to an array of nodes. The next
            node to be captured in the stream will depend on this set of nodes,
            absent operations such as event wait which modify this set. The
            array pointer is valid until the next API call which operates on
            the stream or until the capture is terminated. The node handles may
            be copied out and are valid until they or the graph is destroyed.
            The driver-owned array may also be passed directly to APIs that
            operate on the graph (not the stream) without copying.
        edgeData_out : List[:py:obj:`~.CUgraphEdgeData`]
            Optional location to store a pointer to an array of graph edge
            data. This array parallels `dependencies_out`; the next node to be
            added has an edge to `dependencies_out`[i] with annotation
            `edgeData_out`[i] for each `i`. The array pointer is valid until
            the next API call which operates on the stream or until the capture
            is terminated.
        numDependencies_out : int
            Optional location to store the size of the array returned in
            dependencies_out.

        See Also
        --------
        :py:obj:`~.cuStreamGetCaptureInfo` :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamIsCapturing`, :py:obj:`~.cuStreamUpdateCaptureDependencies`
    """


def cuStreamGetCtx(hStream):
    """
    cuStreamGetCtx(hStream)
     Query the context associated with a stream.

        Returns the CUDA context that the stream is associated with.

        Note there is a later version of this API,
        :py:obj:`~.cuStreamGetCtx_v2`. It will supplant this version in CUDA
        13.0. It is recommended to use :py:obj:`~.cuStreamGetCtx_v2` till then
        as this version will return :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` for
        streams created via the API :py:obj:`~.cuGreenCtxStreamCreate`.

        The stream handle `hStream` can refer to any of the following:

        - a stream created via any of the CUDA driver APIs such as
          :py:obj:`~.cuStreamCreate` and
          :py:obj:`~.cuStreamCreateWithPriority`, or their runtime API
          equivalents such as :py:obj:`~.cudaStreamCreate`,
          :py:obj:`~.cudaStreamCreateWithFlags` and
          :py:obj:`~.cudaStreamCreateWithPriority`. The returned context is the
          context that was active in the calling thread when the stream was
          created. Passing an invalid handle will result in undefined behavior.

        - any of the special streams such as the NULL stream,
          :py:obj:`~.CU_STREAM_LEGACY` and :py:obj:`~.CU_STREAM_PER_THREAD`.
          The runtime API equivalents of these are also accepted, which are
          NULL, :py:obj:`~.cudaStreamLegacy` and
          :py:obj:`~.cudaStreamPerThread` respectively. Specifying any of the
          special handles will return the context current to the calling
          thread. If no context is current to the calling thread,
          :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Handle to the stream to be queried

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
        pctx : :py:obj:`~.CUcontext`
            Returned context associated with the stream

        See Also
        --------
        :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice` :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cuStreamGetCtx_v2`, :py:obj:`~.cudaStreamCreateWithFlags`
    """


def cuStreamGetCtx_v2(hStream):
    """
    cuStreamGetCtx_v2(hStream)
     Query the contexts associated with a stream.

        Returns the contexts that the stream is associated with.

        If the stream is associated with a green context, the API returns the
        green context in `pGreenCtx` and the primary context of the associated
        device in `pCtx`.

        If the stream is associated with a regular context, the API returns the
        regular context in `pCtx` and NULL in `pGreenCtx`.

        The stream handle `hStream` can refer to any of the following:

        - a stream created via any of the CUDA driver APIs such as
          :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamCreateWithPriority`
          and :py:obj:`~.cuGreenCtxStreamCreate`, or their runtime API
          equivalents such as :py:obj:`~.cudaStreamCreate`,
          :py:obj:`~.cudaStreamCreateWithFlags` and
          :py:obj:`~.cudaStreamCreateWithPriority`. Passing an invalid handle
          will result in undefined behavior.

        - any of the special streams such as the NULL stream,
          :py:obj:`~.CU_STREAM_LEGACY` and :py:obj:`~.CU_STREAM_PER_THREAD`.
          The runtime API equivalents of these are also accepted, which are
          NULL, :py:obj:`~.cudaStreamLegacy` and
          :py:obj:`~.cudaStreamPerThread` respectively. If any of the special
          handles are specified, the API will operate on the context current to
          the calling thread. If a green context (that was converted via
          :py:obj:`~.cuCtxFromGreenCtx()` before setting it current) is current
          to the calling thread, the API will return the green context in
          `pGreenCtx` and the primary context of the associated device in
          `pCtx`. If a regular context is current, the API returns the regular
          context in `pCtx` and NULL in `pGreenCtx`. Note that specifying
          :py:obj:`~.CU_STREAM_PER_THREAD` or :py:obj:`~.cudaStreamPerThread`
          will return :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` if a green context
          is current to the calling thread. If no context is current to the
          calling thread, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Handle to the stream to be queried

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
        pCtx : :py:obj:`~.CUcontext`
            Returned regular context associated with the stream
        pGreenCtx : :py:obj:`~.CUgreenCtx`
            Returned green context if the stream is associated with a green
            context or NULL if not

        See Also
        --------
        :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate` :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice` :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`,
    """


def cuStreamGetDevice(hStream):
    """
    cuStreamGetDevice(hStream)
     Returns the device handle of the stream.

        Returns in `*device` the device handle of the stream

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Handle to the stream to be queried

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        device : :py:obj:`~.CUdevice`
            Returns the device to which a stream belongs

        See Also
        --------
        :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetFlags`
    """


def cuStreamGetFlags(hStream):
    """
    cuStreamGetFlags(hStream)
     Query the flags of a given stream.

        Query the flags of a stream created using :py:obj:`~.cuStreamCreate`,
        :py:obj:`~.cuStreamCreateWithPriority` or
        :py:obj:`~.cuGreenCtxStreamCreate` and return the flags in `flags`.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Handle to the stream to be queried

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        flags : unsigned int
            Pointer to an unsigned integer in which the stream's flags are
            returned The value returned in `flags` is a logical 'OR' of all
            flags that were used while creating this stream. See
            :py:obj:`~.cuStreamCreate` for the list of valid flags

        See Also
        --------
        :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cudaStreamGetFlags` :py:obj:`~.cuStreamGetDevice`
    """


def cuStreamGetGreenCtx(hStream):
    """
    cuStreamGetGreenCtx(hStream)
     Query the green context associated with a stream.

        Returns the CUDA green context that the stream is associated with, or
        NULL if the stream is not associated with any green context.

        The stream handle `hStream` can refer to any of the following:

        - a stream created via any of the CUDA driver APIs such as
          :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamCreateWithPriority`
          and :py:obj:`~.cuGreenCtxStreamCreate`, or their runtime API
          equivalents such as :py:obj:`~.cudaStreamCreate`,
          :py:obj:`~.cudaStreamCreateWithFlags` and
          :py:obj:`~.cudaStreamCreateWithPriority`. If during stream creation
          the context that was active in the calling thread was obtained with
          cuCtxFromGreenCtx, that green context is returned in `phCtx`.
          Otherwise, `*phCtx` is set to NULL instead.

        - special stream such as the NULL stream or
          :py:obj:`~.CU_STREAM_LEGACY`. In that case if context that is active
          in the calling thread was obtained with cuCtxFromGreenCtx, that green
          context is returned. Otherwise, `*phCtx` is set to NULL instead.

        Passing an invalid handle will result in undefined behavior.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Handle to the stream to be queried

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,
        phCtx : :py:obj:`~.CUgreenCtx`
            Returned green context associated with the stream

        See Also
        --------
        :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuStreamGetCtx_v2`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice` :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`
    """


def cuStreamGetId(hStream):
    """
    cuStreamGetId(hStream)
     Returns the unique Id associated with the stream handle supplied.

        Returns in `streamId` the unique Id which is associated with the given
        stream handle. The Id is unique for the life of the program.

        The stream handle `hStream` can refer to any of the following:

        - a stream created via any of the CUDA driver APIs such as
          :py:obj:`~.cuStreamCreate` and
          :py:obj:`~.cuStreamCreateWithPriority`, or their runtime API
          equivalents such as :py:obj:`~.cudaStreamCreate`,
          :py:obj:`~.cudaStreamCreateWithFlags` and
          :py:obj:`~.cudaStreamCreateWithPriority`. Passing an invalid handle
          will result in undefined behavior.

        - any of the special streams such as the NULL stream,
          :py:obj:`~.CU_STREAM_LEGACY` and :py:obj:`~.CU_STREAM_PER_THREAD`.
          The runtime API equivalents of these are also accepted, which are
          NULL, :py:obj:`~.cudaStreamLegacy` and
          :py:obj:`~.cudaStreamPerThread` respectively.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Handle to the stream to be queried

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
        streamId : unsigned long long
            Pointer to store the Id of the stream

        See Also
        --------
        :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cudaStreamGetId`
    """


def cuStreamGetPriority(hStream):
    """
    cuStreamGetPriority(hStream)
     Query the priority of a given stream.

        Query the priority of a stream created using
        :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamCreateWithPriority` or
        :py:obj:`~.cuGreenCtxStreamCreate` and return the priority in
        `priority`. Note that if the stream was created with a priority outside
        the numerical range returned by
        :py:obj:`~.cuCtxGetStreamPriorityRange`, this function returns the
        clamped priority. See :py:obj:`~.cuStreamCreateWithPriority` for
        details about priority clamping.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Handle to the stream to be queried

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        priority : int
            Pointer to a signed integer in which the stream's priority is
            returned

        See Also
        --------
        :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice` :py:obj:`~.cudaStreamGetPriority`
    """


def cuStreamIsCapturing(hStream):
    """
    cuStreamIsCapturing(hStream)
     Returns a stream's capture status.

        Return the capture status of `hStream` via `captureStatus`. After a
        successful call, `*captureStatus` will contain one of the following:

        - :py:obj:`~.CU_STREAM_CAPTURE_STATUS_NONE`: The stream is not
          capturing.

        - :py:obj:`~.CU_STREAM_CAPTURE_STATUS_ACTIVE`: The stream is capturing.

        - :py:obj:`~.CU_STREAM_CAPTURE_STATUS_INVALIDATED`: The stream was
          capturing but an error has invalidated the capture sequence. The
          capture sequence must be terminated with
          :py:obj:`~.cuStreamEndCapture` on the stream where it was initiated
          in order to continue using `hStream`.

        Note that, if this is called on :py:obj:`~.CU_STREAM_LEGACY` (the "null
        stream") while a blocking stream in the same context is capturing, it
        will return :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT` and
        `*captureStatus` is unspecified after the call. The blocking stream
        capture is not invalidated.

        When a blocking stream is capturing, the legacy stream is in an
        unusable state until the blocking stream capture is terminated. The
        legacy stream is not supported for stream capture, but attempted use
        would have an implicit dependency on the capturing stream(s).

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to query

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`
        captureStatus : :py:obj:`~.CUstreamCaptureStatus`
            Returns the stream's capture status

        See Also
        --------
        :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamEndCapture`
    """


def cuStreamQuery(hStream):
    """
    cuStreamQuery(hStream)
     Determine status of a compute stream.

        Returns :py:obj:`~.CUDA_SUCCESS` if all operations in the stream
        specified by `hStream` have completed, or
        :py:obj:`~.CUDA_ERROR_NOT_READY` if not.

        For the purposes of Unified Memory, a return value of
        :py:obj:`~.CUDA_SUCCESS` is equivalent to having called
        :py:obj:`~.cuStreamSynchronize()`.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to query status of

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_READY`

        See Also
        --------
        :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamQuery`
    """


def cuStreamSetAttribute(hStream, attr: 'CUstreamAttrID', value: 'Optional[CUstreamAttrValue]'):
    """
    cuStreamSetAttribute(hStream, attr: CUstreamAttrID, CUstreamAttrValue value: Optional[CUstreamAttrValue])
     Sets stream attribute.

        Sets attribute `attr` on `hStream` from corresponding attribute of
        `value`. The updated attribute will be applied to subsequent work
        submitted to the stream. It will not affect previously submitted work.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`

        attr : :py:obj:`~.CUstreamAttrID`

        value : :py:obj:`~.CUstreamAttrValue`


        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.CUaccessPolicyWindow`
    """


def cuStreamSynchronize(hStream):
    """
    cuStreamSynchronize(hStream)
     Wait until a stream's tasks are completed.

        Waits until the device has completed all operations in the stream
        specified by `hStream`. If the context was created with the
        :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` flag, the CPU thread will block
        until the stream is finished with all of its tasks.

    
    ote_null_stream

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to wait for

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

        See Also
        --------
        :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamSynchronize`
    """


def cuStreamUpdateCaptureDependencies(hStream, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', numDependencies, flags):
    """
    cuStreamUpdateCaptureDependencies(hStream, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], size_t numDependencies, unsigned int flags)
     Update the set of dependencies in a capturing stream (11.3+)

        Modifies the dependency set of a capturing stream. The dependency set
        is the set of nodes that the next captured node in the stream will
        depend on.

        Valid flags are :py:obj:`~.CU_STREAM_ADD_CAPTURE_DEPENDENCIES` and
        :py:obj:`~.CU_STREAM_SET_CAPTURE_DEPENDENCIES`. These control whether
        the set passed to the API is added to the existing set or replaces it.
        A flags value of 0 defaults to
        :py:obj:`~.CU_STREAM_ADD_CAPTURE_DEPENDENCIES`.

        Nodes that are removed from the dependency set via this API do not
        result in :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNJOINED` if they are
        unreachable from the stream at :py:obj:`~.cuStreamEndCapture`.

        Returns :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` if the stream is not
        capturing.

        This API is new in CUDA 11.3. Developers requiring compatibility across
        minor versions to CUDA 11.0 should not use this API or provide a
        fallback.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream to update
        dependencies : List[:py:obj:`~.CUgraphNode`]
            The set of dependencies to add
        numDependencies : size_t
            The size of the dependencies array
        flags : unsigned int
            See above

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE`

        See Also
        --------
        :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamGetCaptureInfo`,
    """


def cuStreamUpdateCaptureDependencies_v2(hStream, dependencies: 'Optional[Tuple[CUgraphNode] | List[CUgraphNode]]', dependencyData: 'Optional[Tuple[CUgraphEdgeData] | List[CUgraphEdgeData]]', numDependencies, flags):
    """
    cuStreamUpdateCaptureDependencies_v2(hStream, dependencies: Optional[Tuple[CUgraphNode] | List[CUgraphNode]], dependencyData: Optional[Tuple[CUgraphEdgeData] | List[CUgraphEdgeData]], size_t numDependencies, unsigned int flags)
     Update the set of dependencies in a capturing stream (12.3+)

        Modifies the dependency set of a capturing stream. The dependency set
        is the set of nodes that the next captured node in the stream will
        depend on along with the edge data for those dependencies.

        Valid flags are :py:obj:`~.CU_STREAM_ADD_CAPTURE_DEPENDENCIES` and
        :py:obj:`~.CU_STREAM_SET_CAPTURE_DEPENDENCIES`. These control whether
        the set passed to the API is added to the existing set or replaces it.
        A flags value of 0 defaults to
        :py:obj:`~.CU_STREAM_ADD_CAPTURE_DEPENDENCIES`.

        Nodes that are removed from the dependency set via this API do not
        result in :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNJOINED` if they are
        unreachable from the stream at :py:obj:`~.cuStreamEndCapture`.

        Returns :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` if the stream is not
        capturing.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream to update
        dependencies : List[:py:obj:`~.CUgraphNode`]
            The set of dependencies to add
        dependencyData : List[:py:obj:`~.CUgraphEdgeData`]
            Optional array of data associated with each dependency.
        numDependencies : size_t
            The size of the dependencies array
        flags : unsigned int
            See above

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE`

        See Also
        --------
        :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamGetCaptureInfo`,
    """


def cuStreamWaitEvent(hStream, hEvent, Flags):
    """
    cuStreamWaitEvent(hStream, hEvent, unsigned int Flags)
     Make a compute stream wait on an event.

        Makes all future work submitted to `hStream` wait for all work captured
        in `hEvent`. See :py:obj:`~.cuEventRecord()` for details on what is
        captured by an event. The synchronization will be performed efficiently
        on the device when applicable. `hEvent` may be from a different context
        or device than `hStream`.

        flags include:

        - :py:obj:`~.CU_EVENT_WAIT_DEFAULT`: Default event creation flag.

        - :py:obj:`~.CU_EVENT_WAIT_EXTERNAL`: Event is captured in the graph as
          an external event node when performing stream capture. This flag is
          invalid outside of stream capture.

        Parameters
        ----------
        hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to wait
        hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
            Event to wait on (may not be NULL)
        Flags : unsigned int
            See :py:obj:`~.CUevent_capture_flags`

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,

        See Also
        --------
        :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cudaStreamWaitEvent`
    """


def cuStreamWaitValue32(stream, addr, value, flags):
    """
    cuStreamWaitValue32(stream, addr, value, unsigned int flags)
     Wait on a memory location.

        Enqueues a synchronization of the stream on the given memory location.
        Work ordered after the operation will block until the given condition
        on the memory is satisfied. By default, the condition is to wait for
        (int32_t)(*addr - value) >= 0, a cyclic greater-or-equal. Other
        condition types can be specified via `flags`.

        If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
        device pointer should be obtained with
        :py:obj:`~.cuMemHostGetDevicePointer()`. This function cannot be used
        with managed memory (:py:obj:`~.cuMemAllocManaged`).

        Support for CU_STREAM_WAIT_VALUE_NOR can be queried with
        :py:obj:`~.cuDeviceGetAttribute()` and
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V2`.

        Parameters
        ----------
        stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream to synchronize on the memory location.
        addr : :py:obj:`~.CUdeviceptr`
            The memory location to wait on.
        value : Any
            The value to compare with the memory location.
        flags : unsigned int
            See :py:obj:`~.CUstreamWaitValue_flags`.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuStreamWaitEvent`

        Notes
        -----
        Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order.
    """


def cuStreamWaitValue64(stream, addr, value, flags):
    """
    cuStreamWaitValue64(stream, addr, value, unsigned int flags)
     Wait on a memory location.

        Enqueues a synchronization of the stream on the given memory location.
        Work ordered after the operation will block until the given condition
        on the memory is satisfied. By default, the condition is to wait for
        (int64_t)(*addr - value) >= 0, a cyclic greater-or-equal. Other
        condition types can be specified via `flags`.

        If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
        device pointer should be obtained with
        :py:obj:`~.cuMemHostGetDevicePointer()`.

        Support for this can be queried with :py:obj:`~.cuDeviceGetAttribute()`
        and :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS`.

        Parameters
        ----------
        stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream to synchronize on the memory location.
        addr : :py:obj:`~.CUdeviceptr`
            The memory location to wait on.
        value : Any
            The value to compare with the memory location.
        flags : unsigned int
            See :py:obj:`~.CUstreamWaitValue_flags`.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuStreamWaitEvent`

        Notes
        -----
        Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order.
    """


def cuStreamWriteValue32(stream, addr, value, flags):
    """
    cuStreamWriteValue32(stream, addr, value, unsigned int flags)
     Write a value to memory.

        Write a value to memory.

        If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
        device pointer should be obtained with
        :py:obj:`~.cuMemHostGetDevicePointer()`. This function cannot be used
        with managed memory (:py:obj:`~.cuMemAllocManaged`).

        Parameters
        ----------
        stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream to do the write in.
        addr : :py:obj:`~.CUdeviceptr`
            The device address to write to.
        value : Any
            The value to write.
        flags : unsigned int
            See :py:obj:`~.CUstreamWriteValue_flags`.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuEventRecord`
    """


def cuStreamWriteValue64(stream, addr, value, flags):
    """
    cuStreamWriteValue64(stream, addr, value, unsigned int flags)
     Write a value to memory.

        Write a value to memory.

        If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
        device pointer should be obtained with
        :py:obj:`~.cuMemHostGetDevicePointer()`.

        Support for this can be queried with :py:obj:`~.cuDeviceGetAttribute()`
        and :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS`.

        Parameters
        ----------
        stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            The stream to do the write in.
        addr : :py:obj:`~.CUdeviceptr`
            The device address to write to.
        value : Any
            The value to write.
        flags : unsigned int
            See :py:obj:`~.CUstreamWriteValue_flags`.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

        See Also
        --------
        :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuEventRecord`
    """


def cuSurfObjectCreate(pResDesc: 'Optional[CUDA_RESOURCE_DESC]'):
    """
    cuSurfObjectCreate(CUDA_RESOURCE_DESC pResDesc: Optional[CUDA_RESOURCE_DESC])
     Creates a surface object.

        Creates a surface object and returns it in `pSurfObject`. `pResDesc`
        describes the data to perform surface load/stores on.
        :py:obj:`~.CUDA_RESOURCE_DESC.resType` must be
        :py:obj:`~.CU_RESOURCE_TYPE_ARRAY` and
        :py:obj:`~.CUDA_RESOURCE_DESC`::res::array::hArray must be set to a
        valid CUDA array handle. :py:obj:`~.CUDA_RESOURCE_DESC.flags` must be
        set to zero.

        Surface objects are only supported on devices of compute capability 3.0
        or higher. Additionally, a surface object is an opaque value, and, as
        such, should only be accessed through CUDA API calls.

        Parameters
        ----------
        pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
            Resource descriptor

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pSurfObject : :py:obj:`~.CUsurfObject`
            Surface object to create

        See Also
        --------
        :py:obj:`~.cuSurfObjectDestroy`, :py:obj:`~.cudaCreateSurfaceObject`
    """


def cuSurfObjectDestroy(surfObject):
    """
    cuSurfObjectDestroy(surfObject)
     Destroys a surface object.

        Destroys the surface object specified by `surfObject`.

        Parameters
        ----------
        surfObject : :py:obj:`~.CUsurfObject`
            Surface object to destroy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuSurfObjectCreate`, :py:obj:`~.cudaDestroySurfaceObject`
    """


def cuSurfObjectGetResourceDesc(surfObject):
    """
    cuSurfObjectGetResourceDesc(surfObject)
     Returns a surface object's resource descriptor.

        Returns the resource descriptor for the surface object specified by
        `surfObject`.

        Parameters
        ----------
        surfObject : :py:obj:`~.CUsurfObject`
            Surface object

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
            Resource descriptor

        See Also
        --------
        :py:obj:`~.cuSurfObjectCreate`, :py:obj:`~.cudaGetSurfaceObjectResourceDesc`
    """


def cuSurfRefGetArray(hSurfRef):
    """
    cuSurfRefGetArray(hSurfRef)
     Passes back the CUDA array bound to a surface reference.

        [Deprecated]

        Returns in `*phArray` the CUDA array bound to the surface reference
        `hSurfRef`, or returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the
        surface reference is not bound to any CUDA array.

        Parameters
        ----------
        hSurfRef : :py:obj:`~.CUsurfref`
            Surface reference handle

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phArray : :py:obj:`~.CUarray`
            Surface reference handle

        See Also
        --------
        :py:obj:`~.cuModuleGetSurfRef`, :py:obj:`~.cuSurfRefSetArray`
    """


def cuSurfRefSetArray(hSurfRef, hArray, Flags):
    """
    cuSurfRefSetArray(hSurfRef, hArray, unsigned int Flags)
     Sets the CUDA array for a surface reference.

        [Deprecated]

        Sets the CUDA array `hArray` to be read and written by the surface
        reference `hSurfRef`. Any previous CUDA array state associated with the
        surface reference is superseded by this function. `Flags` must be set
        to 0. The :py:obj:`~.CUDA_ARRAY3D_SURFACE_LDST` flag must have been set
        for the CUDA array. Any CUDA array previously bound to `hSurfRef` is
        unbound.

        Parameters
        ----------
        hSurfRef : :py:obj:`~.CUsurfref`
            Surface reference handle
        hArray : :py:obj:`~.CUarray`
            CUDA array handle
        Flags : unsigned int
            set to 0

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuModuleGetSurfRef`, :py:obj:`~.cuSurfRefGetArray`
    """


def cuTensorMapEncodeIm2col(tensorDataType: 'CUtensorMapDataType', tensorRank, globalAddress, globalDim: 'Optional[Tuple[cuuint64_t] | List[cuuint64_t]]', globalStrides: 'Optional[Tuple[cuuint64_t] | List[cuuint64_t]]', pixelBoxLowerCorner: 'Optional[Tuple[int] | List[int]]', pixelBoxUpperCorner: 'Optional[Tuple[int] | List[int]]', channelsPerPixel, pixelsPerColumn, elementStrides: 'Optional[Tuple[cuuint32_t] | List[cuuint32_t]]', interleave: 'CUtensorMapInterleave', swizzle: 'CUtensorMapSwizzle', l2Promotion: 'CUtensorMapL2promotion', oobFill: 'CUtensorMapFloatOOBfill'):
    """
    cuTensorMapEncodeIm2col(tensorDataType: CUtensorMapDataType, tensorRank, globalAddress, globalDim: Optional[Tuple[cuuint64_t] | List[cuuint64_t]], globalStrides: Optional[Tuple[cuuint64_t] | List[cuuint64_t]], pixelBoxLowerCorner: Optional[Tuple[int] | List[int]], pixelBoxUpperCorner: Optional[Tuple[int] | List[int]], channelsPerPixel, pixelsPerColumn, elementStrides: Optional[Tuple[cuuint32_t] | List[cuuint32_t]], interleave: CUtensorMapInterleave, swizzle: CUtensorMapSwizzle, l2Promotion: CUtensorMapL2promotion, oobFill: CUtensorMapFloatOOBfill)
     Create a tensor map descriptor object representing im2col memory region.

        Creates a descriptor for Tensor Memory Access (TMA) object specified by
        the parameters describing a im2col memory layout and returns it in
        `tensorMap`.

        Tensor map objects are only supported on devices of compute capability
        9.0 or higher. Additionally, a tensor map object is an opaque value,
        and, as such, should only be accessed through CUDA APIs and PTX.

        The parameters passed are bound to the following requirements:

        - `tensorMap` address must be aligned to 64 bytes.

        - `tensorDataType` has to be an enum from
          :py:obj:`~.CUtensorMapDataType` which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B` copies '16 x U4'
          packed values to memory aligned as 8 bytes. There are no gaps between
          packed values. :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`
          copies '16 x U4' packed values to memory aligned as 16 bytes. There
          are 8 byte gaps between every 8 byte chunk of packed values.
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` copies '16 x U6'
          packed values to memory aligned as 16 bytes. There are 4 byte gaps
          between every 12 byte chunk of packed values.

        - `tensorRank`, which specifies the number of tensor dimensions, must
          be 3, 4, or 5.

        - `globalAddress`, which specifies the starting address of the memory
          region described, must be 16 byte aligned. The following requirements
          need to also be met:

          - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`,
            `globalAddress` must be 32 byte aligned.

          - When `tensorDataType` is
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, `globalAddress`
            must be 32 byte aligned.

        - `globalDim` array, which specifies tensor size of each of the
          `tensorRank` dimensions, must be non-zero and less than or equal to
          2^32. Additionally, the following requirements need to be met for the
          packed data types:

          - When `tensorDataType` is
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, globalDim[0]
            must be a multiple of 128.

          - When `tensorDataType` is
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`, `globalDim`[0]
            must be a multiple of 2.

          - Dimension for the packed data types must reflect the number of
            individual U# values.

        - `globalStrides` array, which specifies tensor stride of each of the
          lower `tensorRank` - 1 dimensions in bytes, must be a multiple of 16
          and less than 2^40. Additionally, the following requirements need to
          be met:

          - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`, the
            strides must be a multiple of 32.

          - When `tensorDataType` is
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, the strides must
            be a multiple of 32. Each following dimension specified includes
            previous dimension stride:

          - **View CUDA Toolkit Documentation for a C++ code example**

        - `pixelBoxLowerCorner` array specifies the coordinate offsets {D, H,
          W} of the bounding box from top/left/front corner. The number of
          offsets and their precision depend on the tensor dimensionality:

          - When `tensorRank` is 3, one signed offset within range [-32768,
            32767] is supported.

          - When `tensorRank` is 4, two signed offsets each within range [-128,
            127] are supported.

          - When `tensorRank` is 5, three offsets each within range [-16, 15]
            are supported.

        - `pixelBoxUpperCorner` array specifies the coordinate offsets {D, H,
          W} of the bounding box from bottom/right/back corner. The number of
          offsets and their precision depend on the tensor dimensionality:

          - When `tensorRank` is 3, one signed offset within range [-32768,
            32767] is supported.

          - When `tensorRank` is 4, two signed offsets each within range [-128,
            127] are supported.

          - When `tensorRank` is 5, three offsets each within range [-16, 15]
            are supported. The bounding box specified by `pixelBoxLowerCorner`
            and `pixelBoxUpperCorner` must have non-zero area.

        - `channelsPerPixel`, which specifies the number of elements which must
          be accessed along C dimension, must be less than or equal to 256.
          Additionally, when `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, `channelsPerPixel`
          must be 128.

        - `pixelsPerColumn`, which specifies the number of elements that must
          be accessed along the {N, D, H, W} dimensions, must be less than or
          equal to 1024.

        - `elementStrides` array, which specifies the iteration step along each
          of the `tensorRank` dimensions, must be non-zero and less than or
          equal to 8. Note that when `interleave` is
          :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, the first element of this
          array is ignored since TMA doesnt support the stride for dimension
          zero. When all elements of the `elementStrides` array are one,
          `boxDim` specifies the number of elements to load. However, if
          `elementStrides`[i] is not equal to one for some `i`, then TMA loads
          ceil( `boxDim`[i] / `elementStrides`[i]) number of elements along
          i-th dimension. To load N elements along i-th dimension, `boxDim`[i]
          must be set to N * `elementStrides`[i].

        - `interleave` specifies the interleaved layout of type
          :py:obj:`~.CUtensorMapInterleave`, which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16
          bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16
          uses 32 bytes. When `interleave` is
          :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE` and `swizzle` is not
          :py:obj:`~.CU_TENSOR_MAP_SWIZZLE_NONE`, the bounding box inner
          dimension (computed as `channelsPerPixel` multiplied by element size
          in bytes derived from `tensorDataType`) must be less than or equal to
          the swizzle size.

          - CU_TENSOR_MAP_SWIZZLE_32B requires the bounding box inner dimension
            to be <= 32.

          - CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension
            to be <= 64.

          - CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner
            dimension to be <= 128. Additionally, `tensorDataType` of
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` requires
            `interleave` to be :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`.

        - `swizzle`, which specifies the shared memory bank swizzling pattern,
          has to be of type :py:obj:`~.CUtensorMapSwizzle` which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - Data are organized in a specific order in global memory; however,
          this may not match the order in which the application accesses data
          in shared memory. This difference in data organization may cause bank
          conflicts when shared memory is accessed. In order to avoid this
          problem, data can be loaded to shared memory with shuffling across
          shared memory banks. When `interleave` is
          :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`, `swizzle` must be
          :py:obj:`~.CU_TENSOR_MAP_SWIZZLE_32B`. Other interleave modes can
          have any swizzling pattern. When the `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`, only the following
          swizzle modes are supported:

          - CU_TENSOR_MAP_SWIZZLE_NONE (Load & Store)

          - CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)

          - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store)

          - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B (Store only) When the
            `tensorDataType` is
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, only the
            following swizzle modes are supported:

          - CU_TENSOR_MAP_SWIZZLE_NONE (Load only)

          - CU_TENSOR_MAP_SWIZZLE_128B (Load only)

          - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)

        - `l2Promotion` specifies L2 fetch size which indicates the byte
          granularity at which L2 requests are filled from DRAM. It must be of
          type :py:obj:`~.CUtensorMapL2promotion`, which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - `oobFill`, which indicates whether zero or a special NaN constant
          should be used to fill out-of-bound elements, must be of type
          :py:obj:`~.CUtensorMapFloatOOBfill` which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - Note that
          :py:obj:`~.CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA` can
          only be used when `tensorDataType` represents a floating-point data
          type, and when `tensorDataType` is not
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`,
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, and
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`.

        Parameters
        ----------
        tensorDataType : :py:obj:`~.CUtensorMapDataType`
            Tensor data type
        tensorRank : Any
            Dimensionality of tensor; must be at least 3
        globalAddress : Any
            Starting address of memory region described by tensor
        globalDim : List[:py:obj:`~.cuuint64_t`]
            Array containing tensor size (number of elements) along each of the
            `tensorRank` dimensions
        globalStrides : List[:py:obj:`~.cuuint64_t`]
            Array containing stride size (in bytes) along each of the
            `tensorRank` - 1 dimensions
        pixelBoxLowerCorner : List[int]
            Array containing DHW dimensions of lower box corner
        pixelBoxUpperCorner : List[int]
            Array containing DHW dimensions of upper box corner
        channelsPerPixel : Any
            Number of channels per pixel
        pixelsPerColumn : Any
            Number of pixels per column
        elementStrides : List[:py:obj:`~.cuuint32_t`]
            Array containing traversal stride in each of the `tensorRank`
            dimensions
        interleave : :py:obj:`~.CUtensorMapInterleave`
            Type of interleaved layout the tensor addresses
        swizzle : :py:obj:`~.CUtensorMapSwizzle`
            Bank swizzling pattern inside shared memory
        l2Promotion : :py:obj:`~.CUtensorMapL2promotion`
            L2 promotion size
        oobFill : :py:obj:`~.CUtensorMapFloatOOBfill`
            Indicate whether zero or special NaN constant will be used to fill
            out-of-bound elements

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        tensorMap : :py:obj:`~.CUtensorMap`
            Tensor map object to create

        See Also
        --------
        :py:obj:`~.cuTensorMapEncodeTiled`, :py:obj:`~.cuTensorMapEncodeIm2colWide`, :py:obj:`~.cuTensorMapReplaceAddress`
    """


def cuTensorMapEncodeIm2colWide(tensorDataType: 'CUtensorMapDataType', tensorRank, globalAddress, globalDim: 'Optional[Tuple[cuuint64_t] | List[cuuint64_t]]', globalStrides: 'Optional[Tuple[cuuint64_t] | List[cuuint64_t]]', pixelBoxLowerCornerWidth, pixelBoxUpperCornerWidth, channelsPerPixel, pixelsPerColumn, elementStrides: 'Optional[Tuple[cuuint32_t] | List[cuuint32_t]]', interleave: 'CUtensorMapInterleave', mode: 'CUtensorMapIm2ColWideMode', swizzle: 'CUtensorMapSwizzle', l2Promotion: 'CUtensorMapL2promotion', oobFill: 'CUtensorMapFloatOOBfill'):
    """
    cuTensorMapEncodeIm2colWide(tensorDataType: CUtensorMapDataType, tensorRank, globalAddress, globalDim: Optional[Tuple[cuuint64_t] | List[cuuint64_t]], globalStrides: Optional[Tuple[cuuint64_t] | List[cuuint64_t]], int pixelBoxLowerCornerWidth, int pixelBoxUpperCornerWidth, channelsPerPixel, pixelsPerColumn, elementStrides: Optional[Tuple[cuuint32_t] | List[cuuint32_t]], interleave: CUtensorMapInterleave, mode: CUtensorMapIm2ColWideMode, swizzle: CUtensorMapSwizzle, l2Promotion: CUtensorMapL2promotion, oobFill: CUtensorMapFloatOOBfill)
     Create a tensor map descriptor object representing im2col memory region, but where the elements are exclusively loaded along the W dimension.

        Creates a descriptor for Tensor Memory Access (TMA) object specified by
        the parameters describing a im2col memory layout and where the row is
        always loaded along the W dimensuin and returns it in `tensorMap`. This
        assumes the tensor layout in memory is either NDHWC, NHWC, or NWC.

        This API is only supported on devices of compute capability 10.0 or
        higher. Additionally, a tensor map object is an opaque value, and, as
        such, should only be accessed through CUDA APIs and PTX.

        The parameters passed are bound to the following requirements:

        - `tensorMap` address must be aligned to 64 bytes.

        - `tensorDataType` has to be an enum from
          :py:obj:`~.CUtensorMapDataType` which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B` copies '16 x U4'
          packed values to memory aligned as 8 bytes. There are no gaps between
          packed values. :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`
          copies '16 x U4' packed values to memory aligned as 16 bytes. There
          are 8 byte gaps between every 8 byte chunk of packed values.
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` copies '16 x U6'
          packed values to memory aligned as 16 bytes. There are 4 byte gaps
          between every 12 byte chunk of packed values.

        - `tensorRank`, which specifies the number of tensor dimensions, must
          be 3, 4, or 5.

        - `globalAddress`, which specifies the starting address of the memory
          region described, must be 16 byte aligned. The following requirements
          need to also be met:

          - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`,
            `globalAddress` must be 32 byte aligned.

          - When `tensorDataType` is
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, `globalAddress`
            must be 32 byte aligned.

        `globalDim` array, which specifies tensor size of each of the
        `tensorRank` dimensions, must be non-zero and less than or equal to
        2^32. Additionally, the following requirements need to be met for the
        packed data types:

        - When `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, globalDim[0] must
          be a multiple of 128.

        - When `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`, `globalDim`[0] must
          be a multiple of 2.

        - Dimension for the packed data types must reflect the number of
          individual U# values.

        `globalStrides` array, which specifies tensor stride of each of the
        lower `tensorRank` - 1 dimensions in bytes, must be a multiple of 16
        and less than 2^40. Additionally, the following requirements need to be
        met:

        - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`, the
          strides must be a multiple of 32.

        - When `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, the strides must
          be a multiple of 32. Each following dimension specified includes
          previous dimension stride:

        - **View CUDA Toolkit Documentation for a C++ code example**

        `pixelBoxLowerCornerWidth` specifies the coordinate offset W of the
        bounding box from left corner. The offset must be within range [-32768,
        32767].

        - `pixelBoxUpperCornerWidth` specifies the coordinate offset W of the
          bounding box from right corner. The offset must be within range
          [-32768, 32767].

        The bounding box specified by `pixelBoxLowerCornerWidth` and
        `pixelBoxUpperCornerWidth` must have non-zero area. Note that the size
        of the box along D and H dimensions is always equal to one.

        - `channelsPerPixel`, which specifies the number of elements which must
          be accessed along C dimension, must be less than or equal to 256.
          Additionally, when `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, `channelsPerPixel`
          must be 128.

        - `pixelsPerColumn`, which specifies the number of elements that must
          be accessed along the W dimension, must be less than or equal to
          1024. This field is ignored when `mode` is
          :py:obj:`~.CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128`.

        - `elementStrides` array, which specifies the iteration step along each
          of the `tensorRank` dimensions, must be non-zero and less than or
          equal to 8. Note that when `interleave` is
          :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, the first element of this
          array is ignored since TMA doesnt support the stride for dimension
          zero. When all elements of the `elementStrides` array are one,
          `boxDim` specifies the number of elements to load. However, if
          `elementStrides`[i] is not equal to one for some `i`, then TMA loads
          ceil( `boxDim`[i] / `elementStrides`[i]) number of elements along
          i-th dimension. To load N elements along i-th dimension, `boxDim`[i]
          must be set to N * `elementStrides`[i].

        - `interleave` specifies the interleaved layout of type
          :py:obj:`~.CUtensorMapInterleave`, which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16
          bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16
          uses 32 bytes. When `interleave` is
          :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, the bounding box inner
          dimension (computed as `channelsPerPixel` multiplied by element size
          in bytes derived from `tensorDataType`) must be less than or equal to
          the swizzle size.

          - CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension
            to be <= 64.

          - CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner
            dimension to be <= 128. Additionally, `tensorDataType` of
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` requires
            `interleave` to be :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`.

        - `mode`, which describes loading of elements loaded along the W
          dimension, has to be one of the following
          :py:obj:`~.CUtensorMapIm2ColWideMode` types:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - :py:obj:`~.CU_TENSOR_MAP_IM2COL_WIDE_MODE_W` allows the number of
          elements loaded along the W dimension to be specified via the
          `pixelsPerColumn` field.

        - `swizzle`, which specifies the shared memory bank swizzling pattern,
          must be one of the following :py:obj:`~.CUtensorMapSwizzle` modes
          (other swizzle modes are not supported):

        - **View CUDA Toolkit Documentation for a C++ code example**

        - Data are organized in a specific order in global memory; however,
          this may not match the order in which the application accesses data
          in shared memory. This difference in data organization may cause bank
          conflicts when shared memory is accessed. In order to avoid this
          problem, data can be loaded to shared memory with shuffling across
          shared memory banks. When the `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`, only the following
          swizzle modes are supported:

          - CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)

          - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store) When the
            `tensorDataType` is
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, only the
            following swizzle modes are supported:

          - CU_TENSOR_MAP_SWIZZLE_128B (Load only)

          - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)

        - `l2Promotion` specifies L2 fetch size which indicates the byte
          granularity at which L2 requests are filled from DRAM. It must be of
          type :py:obj:`~.CUtensorMapL2promotion`, which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - `oobFill`, which indicates whether zero or a special NaN constant
          should be used to fill out-of-bound elements, must be of type
          :py:obj:`~.CUtensorMapFloatOOBfill` which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - Note that
          :py:obj:`~.CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA` can
          only be used when `tensorDataType` represents a floating-point data
          type, and when `tensorDataType` is not
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`,
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, and
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`.

        Parameters
        ----------
        tensorDataType : :py:obj:`~.CUtensorMapDataType`
            Tensor data type
        tensorRank : Any
            Dimensionality of tensor; must be at least 3
        globalAddress : Any
            Starting address of memory region described by tensor
        globalDim : List[:py:obj:`~.cuuint64_t`]
            Array containing tensor size (number of elements) along each of the
            `tensorRank` dimensions
        globalStrides : List[:py:obj:`~.cuuint64_t`]
            Array containing stride size (in bytes) along each of the
            `tensorRank` - 1 dimensions
        pixelBoxLowerCornerWidth : int
            Width offset of left box corner
        pixelBoxUpperCornerWidth : int
            Width offset of right box corner
        channelsPerPixel : Any
            Number of channels per pixel
        pixelsPerColumn : Any
            Number of pixels per column
        elementStrides : List[:py:obj:`~.cuuint32_t`]
            Array containing traversal stride in each of the `tensorRank`
            dimensions
        interleave : :py:obj:`~.CUtensorMapInterleave`
            Type of interleaved layout the tensor addresses
        mode : :py:obj:`~.CUtensorMapIm2ColWideMode`
            W or W128 mode
        swizzle : :py:obj:`~.CUtensorMapSwizzle`
            Bank swizzling pattern inside shared memory
        l2Promotion : :py:obj:`~.CUtensorMapL2promotion`
            L2 promotion size
        oobFill : :py:obj:`~.CUtensorMapFloatOOBfill`
            Indicate whether zero or special NaN constant will be used to fill
            out-of-bound elements

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        tensorMap : :py:obj:`~.CUtensorMap`
            Tensor map object to create

        See Also
        --------
        :py:obj:`~.cuTensorMapEncodeTiled`, :py:obj:`~.cuTensorMapEncodeIm2col`, :py:obj:`~.cuTensorMapReplaceAddress`
    """


def cuTensorMapEncodeTiled(tensorDataType: 'CUtensorMapDataType', tensorRank, globalAddress, globalDim: 'Optional[Tuple[cuuint64_t] | List[cuuint64_t]]', globalStrides: 'Optional[Tuple[cuuint64_t] | List[cuuint64_t]]', boxDim: 'Optional[Tuple[cuuint32_t] | List[cuuint32_t]]', elementStrides: 'Optional[Tuple[cuuint32_t] | List[cuuint32_t]]', interleave: 'CUtensorMapInterleave', swizzle: 'CUtensorMapSwizzle', l2Promotion: 'CUtensorMapL2promotion', oobFill: 'CUtensorMapFloatOOBfill'):
    """
    cuTensorMapEncodeTiled(tensorDataType: CUtensorMapDataType, tensorRank, globalAddress, globalDim: Optional[Tuple[cuuint64_t] | List[cuuint64_t]], globalStrides: Optional[Tuple[cuuint64_t] | List[cuuint64_t]], boxDim: Optional[Tuple[cuuint32_t] | List[cuuint32_t]], elementStrides: Optional[Tuple[cuuint32_t] | List[cuuint32_t]], interleave: CUtensorMapInterleave, swizzle: CUtensorMapSwizzle, l2Promotion: CUtensorMapL2promotion, oobFill: CUtensorMapFloatOOBfill)
     Create a tensor map descriptor object representing tiled memory region.

        Creates a descriptor for Tensor Memory Access (TMA) object specified by
        the parameters describing a tiled region and returns it in `tensorMap`.

        Tensor map objects are only supported on devices of compute capability
        9.0 or higher. Additionally, a tensor map object is an opaque value,
        and, as such, should only be accessed through CUDA APIs and PTX.

        The parameters passed are bound to the following requirements:

        - `tensorMap` address must be aligned to 64 bytes.

        - `tensorDataType` has to be an enum from
          :py:obj:`~.CUtensorMapDataType` which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B` copies '16 x U4'
          packed values to memory aligned as 8 bytes. There are no gaps between
          packed values. :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`
          copies '16 x U4' packed values to memory aligned as 16 bytes. There
          are 8 byte gaps between every 8 byte chunk of packed values.
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` copies '16 x U6'
          packed values to memory aligned as 16 bytes. There are 4 byte gaps
          between every 12 byte chunk of packed values.

        - `tensorRank` must be non-zero and less than or equal to the maximum
          supported dimensionality of 5. If `interleave` is not
          :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, then `tensorRank` must
          additionally be greater than or equal to 3.

        - `globalAddress`, which specifies the starting address of the memory
          region described, must be 16 byte aligned. The following requirements
          need to also be met:

          - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`,
            `globalAddress` must be 32 byte aligned.

          - When `tensorDataType` is
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, `globalAddress`
            must be 32 byte aligned.

        `globalDim` array, which specifies tensor size of each of the
        `tensorRank` dimensions, must be non-zero and less than or equal to
        2^32. Additionally, the following requirements need to be met for the
        packed data types:

        - When `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, globalDim[0] must
          be a multiple of 128.

        - When `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`, `globalDim`[0] must
          be a multiple of 2.

        - Dimension for the packed data types must reflect the number of
          individual U# values.

        `globalStrides` array, which specifies tensor stride of each of the
        lower `tensorRank` - 1 dimensions in bytes, must be a multiple of 16
        and less than 2^40. Additionally, the following requirements need to be
        met:

        - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`, the
          strides must be a multiple of 32.

        - When `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, the strides must
          be a multiple of 32. Each following dimension specified includes
          previous dimension stride:

        - **View CUDA Toolkit Documentation for a C++ code example**

        `boxDim` array, which specifies number of elements to be traversed
        along each of the `tensorRank` dimensions, must be non-zero and less
        than or equal to 256. Additionally, the following requirements need to
        be met:

        - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, {
          `boxDim`[0] * elementSizeInBytes( `tensorDataType` ) } must be a
          multiple of 16 bytes.

        - When `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, boxDim[0] must be
          128.

        `elementStrides` array, which specifies the iteration step along each
        of the `tensorRank` dimensions, must be non-zero and less than or equal
        to 8. Note that when `interleave` is
        :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, the first element of this
        array is ignored since TMA doesnt support the stride for dimension
        zero. When all elements of `elementStrides` array is one, `boxDim`
        specifies the number of elements to load. However, if the
        `elementStrides`[i] is not equal to one, then TMA loads ceil(
        `boxDim`[i] / `elementStrides`[i]) number of elements along i-th
        dimension. To load N elements along i-th dimension, `boxDim`[i] must be
        set to N * `elementStrides`[i].

        - `interleave` specifies the interleaved layout of type
          :py:obj:`~.CUtensorMapInterleave`, which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16
          bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16
          uses 32 bytes. When `interleave` is
          :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE` and `swizzle` is not
          :py:obj:`~.CU_TENSOR_MAP_SWIZZLE_NONE`, the bounding box inner
          dimension (computed as `boxDim`[0] multiplied by element size derived
          from `tensorDataType`) must be less than or equal to the swizzle
          size.

          - CU_TENSOR_MAP_SWIZZLE_32B requires the bounding box inner dimension
            to be <= 32.

          - CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension
            to be <= 64.

          - CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner
            dimension to be <= 128. Additionally, `tensorDataType` of
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` requires
            `interleave` to be :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`.

        - `swizzle`, which specifies the shared memory bank swizzling pattern,
          has to be of type :py:obj:`~.CUtensorMapSwizzle` which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - Data are organized in a specific order in global memory; however,
          this may not match the order in which the application accesses data
          in shared memory. This difference in data organization may cause bank
          conflicts when shared memory is accessed. In order to avoid this
          problem, data can be loaded to shared memory with shuffling across
          shared memory banks. When `interleave` is
          :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`, `swizzle` must be
          :py:obj:`~.CU_TENSOR_MAP_SWIZZLE_32B`. Other interleave modes can
          have any swizzling pattern. When the `tensorDataType` is
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`, only the following
          swizzle modes are supported:

          - CU_TENSOR_MAP_SWIZZLE_NONE (Load & Store)

          - CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)

          - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store)

          - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B (Store only) When the
            `tensorDataType` is
            :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, only the
            following swizzle modes are supported:

          - CU_TENSOR_MAP_SWIZZLE_NONE (Load only)

          - CU_TENSOR_MAP_SWIZZLE_128B (Load only)

          - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)

        - `l2Promotion` specifies L2 fetch size which indicates the byte
          granurality at which L2 requests is filled from DRAM. It must be of
          type :py:obj:`~.CUtensorMapL2promotion`, which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - `oobFill`, which indicates whether zero or a special NaN constant
          should be used to fill out-of-bound elements, must be of type
          :py:obj:`~.CUtensorMapFloatOOBfill` which is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - Note that
          :py:obj:`~.CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA` can
          only be used when `tensorDataType` represents a floating-point data
          type, and when `tensorDataType` is not
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`,
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, and
          :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`.

        Parameters
        ----------
        tensorDataType : :py:obj:`~.CUtensorMapDataType`
            Tensor data type
        tensorRank : Any
            Dimensionality of tensor
        globalAddress : Any
            Starting address of memory region described by tensor
        globalDim : List[:py:obj:`~.cuuint64_t`]
            Array containing tensor size (number of elements) along each of the
            `tensorRank` dimensions
        globalStrides : List[:py:obj:`~.cuuint64_t`]
            Array containing stride size (in bytes) along each of the
            `tensorRank` - 1 dimensions
        boxDim : List[:py:obj:`~.cuuint32_t`]
            Array containing traversal box size (number of elments) along each
            of the `tensorRank` dimensions. Specifies how many elements to be
            traversed along each tensor dimension.
        elementStrides : List[:py:obj:`~.cuuint32_t`]
            Array containing traversal stride in each of the `tensorRank`
            dimensions
        interleave : :py:obj:`~.CUtensorMapInterleave`
            Type of interleaved layout the tensor addresses
        swizzle : :py:obj:`~.CUtensorMapSwizzle`
            Bank swizzling pattern inside shared memory
        l2Promotion : :py:obj:`~.CUtensorMapL2promotion`
            L2 promotion size
        oobFill : :py:obj:`~.CUtensorMapFloatOOBfill`
            Indicate whether zero or special NaN constant must be used to fill
            out-of-bound elements

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        tensorMap : :py:obj:`~.CUtensorMap`
            Tensor map object to create

        See Also
        --------
        :py:obj:`~.cuTensorMapEncodeIm2col`, :py:obj:`~.cuTensorMapEncodeIm2colWide`, :py:obj:`~.cuTensorMapReplaceAddress`
    """


def cuTensorMapReplaceAddress(tensorMap: 'Optional[CUtensorMap]', globalAddress):
    """
    cuTensorMapReplaceAddress(CUtensorMap tensorMap: Optional[CUtensorMap], globalAddress)
     Modify an existing tensor map descriptor with an updated global address.

        Modifies the descriptor for Tensor Memory Access (TMA) object passed in
        `tensorMap` with an updated `globalAddress`.

        Tensor map objects are only supported on devices of compute capability
        9.0 or higher. Additionally, a tensor map object is an opaque value,
        and, as such, should only be accessed through CUDA API calls.

        Parameters
        ----------
        tensorMap : :py:obj:`~.CUtensorMap`
            Tensor map object to modify
        globalAddress : Any
            Starting address of memory region described by tensor, must follow
            previous alignment requirements

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTensorMapEncodeTiled`, :py:obj:`~.cuTensorMapEncodeIm2col` :py:obj:`~.cuTensorMapEncodeIm2colWide`
    """


def cuTexObjectCreate(pResDesc: 'Optional[CUDA_RESOURCE_DESC]', pTexDesc: 'Optional[CUDA_TEXTURE_DESC]', pResViewDesc: 'Optional[CUDA_RESOURCE_VIEW_DESC]'):
    """
    cuTexObjectCreate(CUDA_RESOURCE_DESC pResDesc: Optional[CUDA_RESOURCE_DESC], CUDA_TEXTURE_DESC pTexDesc: Optional[CUDA_TEXTURE_DESC], CUDA_RESOURCE_VIEW_DESC pResViewDesc: Optional[CUDA_RESOURCE_VIEW_DESC])
     Creates a texture object.

        Creates a texture object and returns it in `pTexObject`. `pResDesc`
        describes the data to texture from. `pTexDesc` describes how the data
        should be sampled. `pResViewDesc` is an optional argument that
        specifies an alternate format for the data described by `pResDesc`, and
        also describes the subresource region to restrict access to when
        texturing. `pResViewDesc` can only be specified if the type of resource
        is a CUDA array or a CUDA mipmapped array not in a block compressed
        format.

        Texture objects are only supported on devices of compute capability 3.0
        or higher. Additionally, a texture object is an opaque value, and, as
        such, should only be accessed through CUDA API calls.

        The :py:obj:`~.CUDA_RESOURCE_DESC` structure is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - :py:obj:`~.CUDA_RESOURCE_DESC.resType` specifies the type of resource
          to texture from. CUresourceType is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
        :py:obj:`~.CU_RESOURCE_TYPE_ARRAY`,
        :py:obj:`~.CUDA_RESOURCE_DESC`::res::array::hArray must be set to a
        valid CUDA array handle.

        If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
        :py:obj:`~.CU_RESOURCE_TYPE_MIPMAPPED_ARRAY`,
        :py:obj:`~.CUDA_RESOURCE_DESC`::res::mipmap::hMipmappedArray must be
        set to a valid CUDA mipmapped array handle.

        If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
        :py:obj:`~.CU_RESOURCE_TYPE_LINEAR`,
        :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::devPtr must be set to a
        valid device pointer, that is aligned to
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT`.
        :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::format and
        :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::numChannels describe the
        format of each component and the number of components per array
        element. :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::sizeInBytes
        specifies the size of the array in bytes. The total number of elements
        in the linear address range cannot exceed
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH`. The
        number of elements is computed as (sizeInBytes / (sizeof(format) *
        numChannels)).

        If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
        :py:obj:`~.CU_RESOURCE_TYPE_PITCH2D`,
        :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::devPtr must be set to a
        valid device pointer, that is aligned to
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT`.
        :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::format and
        :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::numChannels describe the
        format of each component and the number of components per array
        element. :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::width and
        :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::height specify the width
        and height of the array in elements, and cannot exceed
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH` and
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT`
        respectively.
        :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::pitchInBytes specifies
        the pitch between two rows in bytes and has to be aligned to
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT`. Pitch cannot
        exceed :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH`.

        - :py:obj:`~.flags` must be set to zero.

        The :py:obj:`~.CUDA_TEXTURE_DESC` struct is defined as

        **View CUDA Toolkit Documentation for a C++ code example**

        where

        - :py:obj:`~.CUDA_TEXTURE_DESC.addressMode` specifies the addressing
          mode for each dimension of the texture data.
          :py:obj:`~.CUaddress_mode` is defined as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - This is ignored if :py:obj:`~.CUDA_RESOURCE_DESC.resType` is
          :py:obj:`~.CU_RESOURCE_TYPE_LINEAR`. Also, if the flag,
          :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES` is not set, the only
          supported address mode is :py:obj:`~.CU_TR_ADDRESS_MODE_CLAMP`.

        - :py:obj:`~.CUDA_TEXTURE_DESC.filterMode` specifies the filtering mode
          to be used when fetching from the texture. CUfilter_mode is defined
          as:

        - **View CUDA Toolkit Documentation for a C++ code example**

        - This is ignored if :py:obj:`~.CUDA_RESOURCE_DESC.resType` is
          :py:obj:`~.CU_RESOURCE_TYPE_LINEAR`.

        - :py:obj:`~.CUDA_TEXTURE_DESC.flags` can be any combination of the
          following:

          - :py:obj:`~.CU_TRSF_READ_AS_INTEGER`, which suppresses the default
            behavior of having the texture promote integer data to floating
            point data in the range [0, 1]. Note that texture with 32-bit
            integer format would not be promoted, regardless of whether or not
            this flag is specified.

          - :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES`, which suppresses the
            default behavior of having the texture coordinates range from [0,
            Dim) where Dim is the width or height of the CUDA array. Instead,
            the texture coordinates [0, 1.0) reference the entire breadth of
            the array dimension; Note that for CUDA mipmapped arrays, this flag
            has to be set.

          - :py:obj:`~.CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION`, which disables
            any trilinear filtering optimizations. Trilinear optimizations
            improve texture filtering performance by allowing bilinear
            filtering on textures in scenarios where it can closely approximate
            the expected results.

          - :py:obj:`~.CU_TRSF_SEAMLESS_CUBEMAP`, which enables seamless cube
            map filtering. This flag can only be specified if the underlying
            resource is a CUDA array or a CUDA mipmapped array that was created
            with the flag :py:obj:`~.CUDA_ARRAY3D_CUBEMAP`. When seamless cube
            map filtering is enabled, texture address modes specified by
            :py:obj:`~.CUDA_TEXTURE_DESC.addressMode` are ignored. Instead, if
            the :py:obj:`~.CUDA_TEXTURE_DESC.filterMode` is set to
            :py:obj:`~.CU_TR_FILTER_MODE_POINT` the address mode
            :py:obj:`~.CU_TR_ADDRESS_MODE_CLAMP` will be applied for all
            dimensions. If the :py:obj:`~.CUDA_TEXTURE_DESC.filterMode` is set
            to :py:obj:`~.CU_TR_FILTER_MODE_LINEAR` seamless cube map filtering
            will be performed when sampling along the cube face borders.

        - :py:obj:`~.CUDA_TEXTURE_DESC.maxAnisotropy` specifies the maximum
          anisotropy ratio to be used when doing anisotropic filtering. This
          value will be clamped to the range [1,16].

        - :py:obj:`~.CUDA_TEXTURE_DESC.mipmapFilterMode` specifies the filter
          mode when the calculated mipmap level lies between two defined mipmap
          levels.

        - :py:obj:`~.CUDA_TEXTURE_DESC.mipmapLevelBias` specifies the offset to
          be applied to the calculated mipmap level.

        - :py:obj:`~.CUDA_TEXTURE_DESC.minMipmapLevelClamp` specifies the lower
          end of the mipmap level range to clamp access to.

        - :py:obj:`~.CUDA_TEXTURE_DESC.maxMipmapLevelClamp` specifies the upper
          end of the mipmap level range to clamp access to.

        The :py:obj:`~.CUDA_RESOURCE_VIEW_DESC` struct is defined as

        **View CUDA Toolkit Documentation for a C++ code example**

        where:

        - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.format` specifies how the data
          contained in the CUDA array or CUDA mipmapped array should be
          interpreted. Note that this can incur a change in size of the texture
          data. If the resource view format is a block compressed format, then
          the underlying CUDA array or CUDA mipmapped array has to have a base
          of format :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT32`. with 2 or 4
          channels, depending on the block compressed format. For ex., BC1 and
          BC4 require the underlying CUDA array to have a format of
          :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT32` with 2 channels. The other BC
          formats require the underlying resource to have the same base format
          but with 4 channels.

        - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.width` specifies the new width of
          the texture data. If the resource view format is a block compressed
          format, this value has to be 4 times the original width of the
          resource. For non block compressed formats, this value has to be
          equal to that of the original resource.

        - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.height` specifies the new height
          of the texture data. If the resource view format is a block
          compressed format, this value has to be 4 times the original height
          of the resource. For non block compressed formats, this value has to
          be equal to that of the original resource.

        - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.depth` specifies the new depth of
          the texture data. This value has to be equal to that of the original
          resource.

        - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.firstMipmapLevel` specifies the
          most detailed mipmap level. This will be the new mipmap level zero.
          For non-mipmapped resources, this value has to be
          zero.:py:obj:`~.CUDA_TEXTURE_DESC.minMipmapLevelClamp` and
          :py:obj:`~.CUDA_TEXTURE_DESC.maxMipmapLevelClamp` will be relative to
          this value. For ex., if the firstMipmapLevel is set to 2, and a
          minMipmapLevelClamp of 1.2 is specified, then the actual minimum
          mipmap level clamp will be 3.2.

        - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.lastMipmapLevel` specifies the
          least detailed mipmap level. For non-mipmapped resources, this value
          has to be zero.

        - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.firstLayer` specifies the first
          layer index for layered textures. This will be the new layer zero.
          For non-layered resources, this value has to be zero.

        - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.lastLayer` specifies the last
          layer index for layered textures. For non-layered resources, this
          value has to be zero.

        Parameters
        ----------
        pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
            Resource descriptor
        pTexDesc : :py:obj:`~.CUDA_TEXTURE_DESC`
            Texture descriptor
        pResViewDesc : :py:obj:`~.CUDA_RESOURCE_VIEW_DESC`
            Resource view descriptor

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pTexObject : :py:obj:`~.CUtexObject`
            Texture object to create

        See Also
        --------
        :py:obj:`~.cuTexObjectDestroy`, :py:obj:`~.cudaCreateTextureObject`
    """


def cuTexObjectDestroy(texObject):
    """
    cuTexObjectDestroy(texObject)
     Destroys a texture object.

        Destroys the texture object specified by `texObject`.

        Parameters
        ----------
        texObject : :py:obj:`~.CUtexObject`
            Texture object to destroy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaDestroyTextureObject`
    """


def cuTexObjectGetResourceDesc(texObject):
    """
    cuTexObjectGetResourceDesc(texObject)
     Returns a texture object's resource descriptor.

        Returns the resource descriptor for the texture object specified by
        `texObject`.

        Parameters
        ----------
        texObject : :py:obj:`~.CUtexObject`
            Texture object

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
            Resource descriptor

        See Also
        --------
        :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaGetTextureObjectResourceDesc`,
    """


def cuTexObjectGetResourceViewDesc(texObject):
    """
    cuTexObjectGetResourceViewDesc(texObject)
     Returns a texture object's resource view descriptor.

        Returns the resource view descriptor for the texture object specified
        by `texObject`. If no resource view was set for `texObject`, the
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

        Parameters
        ----------
        texObject : :py:obj:`~.CUtexObject`
            Texture object

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pResViewDesc : :py:obj:`~.CUDA_RESOURCE_VIEW_DESC`
            Resource view descriptor

        See Also
        --------
        :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaGetTextureObjectResourceViewDesc`
    """


def cuTexObjectGetTextureDesc(texObject):
    """
    cuTexObjectGetTextureDesc(texObject)
     Returns a texture object's texture descriptor.

        Returns the texture descriptor for the texture object specified by
        `texObject`.

        Parameters
        ----------
        texObject : :py:obj:`~.CUtexObject`
            Texture object

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pTexDesc : :py:obj:`~.CUDA_TEXTURE_DESC`
            Texture descriptor

        See Also
        --------
        :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaGetTextureObjectTextureDesc`
    """


def cuTexRefCreate():
    """
    cuTexRefCreate()
     Creates a texture reference.

        [Deprecated]

        Creates a texture reference and returns its handle in `*pTexRef`. Once
        created, the application must call :py:obj:`~.cuTexRefSetArray()` or
        :py:obj:`~.cuTexRefSetAddress()` to associate the reference with
        allocated memory. Other texture reference functions are used to specify
        the format and interpretation (addressing, filtering, etc.) to be used
        when the memory is read through this texture reference.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pTexRef : :py:obj:`~.CUtexref`
            Returned texture reference

        See Also
        --------
        :py:obj:`~.cuTexRefDestroy`
    """


def cuTexRefDestroy(hTexRef):
    """
    cuTexRefDestroy(hTexRef)
     Destroys a texture reference.

        [Deprecated]

        Destroys the texture reference specified by `hTexRef`.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference to destroy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefCreate`
    """


def cuTexRefGetAddress(hTexRef):
    """
    cuTexRefGetAddress(hTexRef)
     Gets the address associated with a texture reference.

        [Deprecated]

        Returns in `*pdptr` the base address bound to the texture reference
        `hTexRef`, or returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the
        texture reference is not bound to any device memory range.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pdptr : :py:obj:`~.CUdeviceptr`
            Returned device address

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefGetAddressMode(hTexRef, dim):
    """
    cuTexRefGetAddressMode(hTexRef, int dim)
     Gets the addressing mode used by a texture reference.

        [Deprecated]

        Returns in `*pam` the addressing mode corresponding to the dimension
        `dim` of the texture reference `hTexRef`. Currently, the only valid
        value for `dim` are 0 and 1.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference
        dim : int
            Dimension

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pam : :py:obj:`~.CUaddress_mode`
            Returned addressing mode

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefGetArray(hTexRef):
    """
    cuTexRefGetArray(hTexRef)
     Gets the array bound to a texture reference.

        [Deprecated]

        Returns in `*phArray` the CUDA array bound to the texture reference
        `hTexRef`, or returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the
        texture reference is not bound to any CUDA array.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phArray : :py:obj:`~.CUarray`
            Returned array

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefGetBorderColor(hTexRef):
    """
    cuTexRefGetBorderColor(hTexRef)
     Gets the border color used by a texture reference.

        [Deprecated]

        Returns in `pBorderColor`, values of the RGBA color used by the texture
        reference `hTexRef`. The color value is of type float and holds color
        components in the following sequence: pBorderColor[0] holds 'R'
        component pBorderColor[1] holds 'G' component pBorderColor[2] holds 'B'
        component pBorderColor[3] holds 'A' component

        Parameters
        ----------
        pBorderColor : :py:obj:`~.CUtexref`
            Returned Type and Value of RGBA color

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        hTexRef : float
            Texture reference

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetBorderColor`
    """


def cuTexRefGetFilterMode(hTexRef):
    """
    cuTexRefGetFilterMode(hTexRef)
     Gets the filter-mode used by a texture reference.

        [Deprecated]

        Returns in `*pfm` the filtering mode of the texture reference
        `hTexRef`.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pfm : :py:obj:`~.CUfilter_mode`
            Returned filtering mode

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefGetFlags(hTexRef):
    """
    cuTexRefGetFlags(hTexRef)
     Gets the flags used by a texture reference.

        [Deprecated]

        Returns in `*pFlags` the flags of the texture reference `hTexRef`.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pFlags : unsigned int
            Returned flags

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefGetFormat(hTexRef):
    """
    cuTexRefGetFormat(hTexRef)
     Gets the format used by a texture reference.

        [Deprecated]

        Returns in `*pFormat` and `*pNumChannels` the format and number of
        components of the CUDA array bound to the texture reference `hTexRef`.
        If `pFormat` or `pNumChannels` is NULL, it will be ignored.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pFormat : :py:obj:`~.CUarray_format`
            Returned format
        pNumChannels : int
            Returned number of components

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`
    """


def cuTexRefGetMaxAnisotropy(hTexRef):
    """
    cuTexRefGetMaxAnisotropy(hTexRef)
     Gets the maximum anisotropy for a texture reference.

        [Deprecated]

        Returns the maximum anisotropy in `pmaxAniso` that's used when reading
        memory through the texture reference `hTexRef`.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pmaxAniso : int
            Returned maximum anisotropy

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefGetMipmapFilterMode(hTexRef):
    """
    cuTexRefGetMipmapFilterMode(hTexRef)
     Gets the mipmap filtering mode for a texture reference.

        [Deprecated]

        Returns the mipmap filtering mode in `pfm` that's used when reading
        memory through the texture reference `hTexRef`.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pfm : :py:obj:`~.CUfilter_mode`
            Returned mipmap filtering mode

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefGetMipmapLevelBias(hTexRef):
    """
    cuTexRefGetMipmapLevelBias(hTexRef)
     Gets the mipmap level bias for a texture reference.

        [Deprecated]

        Returns the mipmap level bias in `pBias` that's added to the specified
        mipmap level when reading memory through the texture reference
        `hTexRef`.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pbias : float
            Returned mipmap level bias

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefGetMipmapLevelClamp(hTexRef):
    """
    cuTexRefGetMipmapLevelClamp(hTexRef)
     Gets the min/max mipmap level clamps for a texture reference.

        [Deprecated]

        Returns the min/max mipmap level clamps in `pminMipmapLevelClamp` and
        `pmaxMipmapLevelClamp` that's used when reading memory through the
        texture reference `hTexRef`.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pminMipmapLevelClamp : float
            Returned mipmap min level clamp
        pmaxMipmapLevelClamp : float
            Returned mipmap max level clamp

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefGetMipmappedArray(hTexRef):
    """
    cuTexRefGetMipmappedArray(hTexRef)
     Gets the mipmapped array bound to a texture reference.

        [Deprecated]

        Returns in `*phMipmappedArray` the CUDA mipmapped array bound to the
        texture reference `hTexRef`, or returns
        :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the texture reference is not
        bound to any CUDA mipmapped array.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        phMipmappedArray : :py:obj:`~.CUmipmappedArray`
            Returned mipmapped array

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefSetAddress(hTexRef, dptr, numbytes):
    """
    cuTexRefSetAddress(hTexRef, dptr, size_t numbytes)
     Binds an address as a texture reference.

        [Deprecated]

        Binds a linear address range to the texture reference `hTexRef`. Any
        previous address or CUDA array state associated with the texture
        reference is superseded by this function. Any memory previously bound
        to `hTexRef` is unbound.

        Since the hardware enforces an alignment requirement on texture base
        addresses, :py:obj:`~.cuTexRefSetAddress()` passes back a byte offset
        in `*ByteOffset` that must be applied to texture fetches in order to
        read from the desired memory. This offset must be divided by the texel
        size and passed to kernels that read from the texture so they can be
        applied to the :py:obj:`~.tex1Dfetch()` function.

        If the device memory pointer was returned from
        :py:obj:`~.cuMemAlloc()`, the offset is guaranteed to be 0 and NULL may
        be passed as the `ByteOffset` parameter.

        The total number of elements (or texels) in the linear address range
        cannot exceed
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH`. The
        number of elements is computed as (`numbytes` / bytesPerElement), where
        bytesPerElement is determined from the data format and number of
        components set using :py:obj:`~.cuTexRefSetFormat()`.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference to bind
        dptr : :py:obj:`~.CUdeviceptr`
            Device pointer to bind
        numbytes : size_t
            Size of memory to bind in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        ByteOffset : int
            Returned byte offset

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefSetAddress2D(hTexRef, desc: 'Optional[CUDA_ARRAY_DESCRIPTOR]', dptr, Pitch):
    """
    cuTexRefSetAddress2D(hTexRef, CUDA_ARRAY_DESCRIPTOR desc: Optional[CUDA_ARRAY_DESCRIPTOR], dptr, size_t Pitch)
     Binds an address as a 2D texture reference.

        [Deprecated]

        Binds a linear address range to the texture reference `hTexRef`. Any
        previous address or CUDA array state associated with the texture
        reference is superseded by this function. Any memory previously bound
        to `hTexRef` is unbound.

        Using a :py:obj:`~.tex2D()` function inside a kernel requires a call to
        either :py:obj:`~.cuTexRefSetArray()` to bind the corresponding texture
        reference to an array, or :py:obj:`~.cuTexRefSetAddress2D()` to bind
        the texture reference to linear memory.

        Function calls to :py:obj:`~.cuTexRefSetFormat()` cannot follow calls
        to :py:obj:`~.cuTexRefSetAddress2D()` for the same texture reference.

        It is required that `dptr` be aligned to the appropriate hardware-
        specific texture alignment. You can query this value using the device
        attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT`. If an
        unaligned `dptr` is supplied, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is
        returned.

        `Pitch` has to be aligned to the hardware-specific texture pitch
        alignment. This value can be queried using the device attribute
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT`. If an
        unaligned `Pitch` is supplied, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is
        returned.

        Width and Height, which are specified in elements (or texels), cannot
        exceed :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH`
        and :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT`
        respectively. `Pitch`, which is specified in bytes, cannot exceed
        :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH`.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference to bind
        desc : :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
            Descriptor of CUDA array
        dptr : :py:obj:`~.CUdeviceptr`
            Device pointer to bind
        Pitch : size_t
            Line pitch in bytes

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefSetAddressMode(hTexRef, dim, am: 'CUaddress_mode'):
    """
    cuTexRefSetAddressMode(hTexRef, int dim, am: CUaddress_mode)
     Sets the addressing mode for a texture reference.

        [Deprecated]

        Specifies the addressing mode `am` for the given dimension `dim` of the
        texture reference `hTexRef`. If `dim` is zero, the addressing mode is
        applied to the first parameter of the functions used to fetch from the
        texture; if `dim` is 1, the second, and so on.
        :py:obj:`~.CUaddress_mode` is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        Note that this call has no effect if `hTexRef` is bound to linear
        memory. Also, if the flag, :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES`,
        is not set, the only supported address mode is
        :py:obj:`~.CU_TR_ADDRESS_MODE_CLAMP`.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference
        dim : int
            Dimension
        am : :py:obj:`~.CUaddress_mode`
            Addressing mode to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefSetArray(hTexRef, hArray, Flags):
    """
    cuTexRefSetArray(hTexRef, hArray, unsigned int Flags)
     Binds an array as a texture reference.

        [Deprecated]

        Binds the CUDA array `hArray` to the texture reference `hTexRef`. Any
        previous address or CUDA array state associated with the texture
        reference is superseded by this function. `Flags` must be set to
        :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`. Any CUDA array previously bound to
        `hTexRef` is unbound.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference to bind
        hArray : :py:obj:`~.CUarray`
            Array to bind
        Flags : unsigned int
            Options (must be :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`)

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefSetBorderColor(hTexRef, pBorderColor):
    """
    cuTexRefSetBorderColor(hTexRef, float pBorderColor)
     Sets the border color for a texture reference.

        [Deprecated]

        Specifies the value of the RGBA color via the `pBorderColor` to the
        texture reference `hTexRef`. The color value supports only float type
        and holds color components in the following sequence: pBorderColor[0]
        holds 'R' component pBorderColor[1] holds 'G' component pBorderColor[2]
        holds 'B' component pBorderColor[3] holds 'A' component

        Note that the color values can be set only when the Address mode is set
        to CU_TR_ADDRESS_MODE_BORDER using :py:obj:`~.cuTexRefSetAddressMode`.
        Applications using integer border color values have to
        "reinterpret_cast" their values to float.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference
        pBorderColor : float
            RGBA color

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetBorderColor`
    """


def cuTexRefSetFilterMode(hTexRef, fm: 'CUfilter_mode'):
    """
    cuTexRefSetFilterMode(hTexRef, fm: CUfilter_mode)
     Sets the filtering mode for a texture reference.

        [Deprecated]

        Specifies the filtering mode `fm` to be used when reading memory
        through the texture reference `hTexRef`. :py:obj:`~.CUfilter_mode_enum`
        is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        Note that this call has no effect if `hTexRef` is bound to linear
        memory.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference
        fm : :py:obj:`~.CUfilter_mode`
            Filtering mode to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefSetFlags(hTexRef, Flags):
    """
    cuTexRefSetFlags(hTexRef, unsigned int Flags)
     Sets the flags for a texture reference.

        [Deprecated]

        Specifies optional flags via `Flags` to specify the behavior of data
        returned through the texture reference `hTexRef`. The valid flags are:

        - :py:obj:`~.CU_TRSF_READ_AS_INTEGER`, which suppresses the default
          behavior of having the texture promote integer data to floating point
          data in the range [0, 1]. Note that texture with 32-bit integer
          format would not be promoted, regardless of whether or not this flag
          is specified;

        - :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES`, which suppresses the
          default behavior of having the texture coordinates range from [0,
          Dim) where Dim is the width or height of the CUDA array. Instead, the
          texture coordinates [0, 1.0) reference the entire breadth of the
          array dimension;

        - :py:obj:`~.CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION`, which disables
          any trilinear filtering optimizations. Trilinear optimizations
          improve texture filtering performance by allowing bilinear filtering
          on textures in scenarios where it can closely approximate the
          expected results.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference
        Flags : unsigned int
            Optional flags to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefSetFormat(hTexRef, fmt: 'CUarray_format', NumPackedComponents):
    """
    cuTexRefSetFormat(hTexRef, fmt: CUarray_format, int NumPackedComponents)
     Sets the format for a texture reference.

        [Deprecated]

        Specifies the format of the data to be read by the texture reference
        `hTexRef`. `fmt` and `NumPackedComponents` are exactly analogous to the
        :py:obj:`~.Format` and :py:obj:`~.NumChannels` members of the
        :py:obj:`~.CUDA_ARRAY_DESCRIPTOR` structure: They specify the format of
        each component and the number of components per array element.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference
        fmt : :py:obj:`~.CUarray_format`
            Format to set
        NumPackedComponents : int
            Number of components per array element

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaCreateChannelDesc`
    """


def cuTexRefSetMaxAnisotropy(hTexRef, maxAniso):
    """
    cuTexRefSetMaxAnisotropy(hTexRef, unsigned int maxAniso)
     Sets the maximum anisotropy for a texture reference.

        [Deprecated]

        Specifies the maximum anisotropy `maxAniso` to be used when reading
        memory through the texture reference `hTexRef`.

        Note that this call has no effect if `hTexRef` is bound to linear
        memory.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference
        maxAniso : unsigned int
            Maximum anisotropy

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefSetMipmapFilterMode(hTexRef, fm: 'CUfilter_mode'):
    """
    cuTexRefSetMipmapFilterMode(hTexRef, fm: CUfilter_mode)
     Sets the mipmap filtering mode for a texture reference.

        [Deprecated]

        Specifies the mipmap filtering mode `fm` to be used when reading memory
        through the texture reference `hTexRef`. :py:obj:`~.CUfilter_mode_enum`
        is defined as:

        **View CUDA Toolkit Documentation for a C++ code example**

        Note that this call has no effect if `hTexRef` is not bound to a
        mipmapped array.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference
        fm : :py:obj:`~.CUfilter_mode`
            Filtering mode to set

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefSetMipmapLevelBias(hTexRef, bias):
    """
    cuTexRefSetMipmapLevelBias(hTexRef, float bias)
     Sets the mipmap level bias for a texture reference.

        [Deprecated]

        Specifies the mipmap level bias `bias` to be added to the specified
        mipmap level when reading memory through the texture reference
        `hTexRef`.

        Note that this call has no effect if `hTexRef` is not bound to a
        mipmapped array.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference
        bias : float
            Mipmap level bias

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefSetMipmapLevelClamp(hTexRef, minMipmapLevelClamp, maxMipmapLevelClamp):
    """
    cuTexRefSetMipmapLevelClamp(hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp)
     Sets the mipmap min/max mipmap level clamps for a texture reference.

        [Deprecated]

        Specifies the min/max mipmap level clamps, `minMipmapLevelClamp` and
        `maxMipmapLevelClamp` respectively, to be used when reading memory
        through the texture reference `hTexRef`.

        Note that this call has no effect if `hTexRef` is not bound to a
        mipmapped array.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference
        minMipmapLevelClamp : float
            Mipmap min level clamp
        maxMipmapLevelClamp : float
            Mipmap max level clamp

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuTexRefSetMipmappedArray(hTexRef, hMipmappedArray, Flags):
    """
    cuTexRefSetMipmappedArray(hTexRef, hMipmappedArray, unsigned int Flags)
     Binds a mipmapped array to a texture reference.

        [Deprecated]

        Binds the CUDA mipmapped array `hMipmappedArray` to the texture
        reference `hTexRef`. Any previous address or CUDA array state
        associated with the texture reference is superseded by this function.
        `Flags` must be set to :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`. Any CUDA
        array previously bound to `hTexRef` is unbound.

        Parameters
        ----------
        hTexRef : :py:obj:`~.CUtexref`
            Texture reference to bind
        hMipmappedArray : :py:obj:`~.CUmipmappedArray`
            Mipmapped array to bind
        Flags : unsigned int
            Options (must be :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`)

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """


def cuThreadExchangeStreamCaptureMode(mode: 'CUstreamCaptureMode'):
    """
    cuThreadExchangeStreamCaptureMode(mode: CUstreamCaptureMode)
     Swaps the stream capture interaction mode for a thread.

        Sets the calling thread's stream capture interaction mode to the value
        contained in `*mode`, and overwrites `*mode` with the previous mode for
        the thread. To facilitate deterministic behavior across function or
        module boundaries, callers are encouraged to use this API in a push-pop
        fashion:

        **View CUDA Toolkit Documentation for a C++ code example**

        During stream capture (see :py:obj:`~.cuStreamBeginCapture`), some
        actions, such as a call to :py:obj:`~.cudaMalloc`, may be unsafe. In
        the case of :py:obj:`~.cudaMalloc`, the operation is not enqueued
        asynchronously to a stream, and is not observed by stream capture.
        Therefore, if the sequence of operations captured via
        :py:obj:`~.cuStreamBeginCapture` depended on the allocation being
        replayed whenever the graph is launched, the captured graph would be
        invalid.

        Therefore, stream capture places restrictions on API calls that can be
        made within or concurrently to a
        :py:obj:`~.cuStreamBeginCapture`-:py:obj:`~.cuStreamEndCapture`
        sequence. This behavior can be controlled via this API and flags to
        :py:obj:`~.cuStreamBeginCapture`.

        A thread's mode is one of the following:

        - `CU_STREAM_CAPTURE_MODE_GLOBAL:` This is the default mode. If the
          local thread has an ongoing capture sequence that was not initiated
          with `CU_STREAM_CAPTURE_MODE_RELAXED` at `cuStreamBeginCapture`, or
          if any other thread has a concurrent capture sequence initiated with
          `CU_STREAM_CAPTURE_MODE_GLOBAL`, this thread is prohibited from
          potentially unsafe API calls.

        - `CU_STREAM_CAPTURE_MODE_THREAD_LOCAL:` If the local thread has an
          ongoing capture sequence not initiated with
          `CU_STREAM_CAPTURE_MODE_RELAXED`, it is prohibited from potentially
          unsafe API calls. Concurrent capture sequences in other threads are
          ignored.

        - `CU_STREAM_CAPTURE_MODE_RELAXED:` The local thread is not prohibited
          from potentially unsafe API calls. Note that the thread is still
          prohibited from API calls which necessarily conflict with stream
          capture, for example, attempting :py:obj:`~.cuEventQuery` on an event
          that was last recorded inside a capture sequence.

        Parameters
        ----------
        mode : :py:obj:`~.CUstreamCaptureMode`
            Pointer to mode value to swap with the current mode

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        mode : :py:obj:`~.CUstreamCaptureMode`
            Pointer to mode value to swap with the current mode

        See Also
        --------
        :py:obj:`~.cuStreamBeginCapture`
    """


def cuUserObjectCreate(ptr, destroy, initialRefcount, flags):
    """
    cuUserObjectCreate(ptr, destroy, unsigned int initialRefcount, unsigned int flags)
     Create a user object.

        Create a user object with the specified destructor callback and initial
        reference count. The initial references are owned by the caller.

        Destructor callbacks cannot make CUDA API calls and should avoid
        blocking behavior, as they are executed by a shared internal thread.
        Another thread may be signaled to perform such actions, if it does not
        block forward progress of tasks scheduled through CUDA.

        See CUDA User Objects in the CUDA C++ Programming Guide for more
        information on user objects.

        Parameters
        ----------
        ptr : Any
            The pointer to pass to the destroy function
        destroy : :py:obj:`~.CUhostFn`
            Callback to free the user object when it is no longer in use
        initialRefcount : unsigned int
            The initial refcount to create the object with, typically 1. The
            initial references are owned by the calling thread.
        flags : unsigned int
            Currently it is required to pass
            :py:obj:`~.CU_USER_OBJECT_NO_DESTRUCTOR_SYNC`, which is the only
            defined flag. This indicates that the destroy callback cannot be
            waited on by any CUDA API. Users requiring synchronization of the
            callback should signal its completion manually.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        object_out : :py:obj:`~.CUuserObject`
            Location to return the user object handle

        See Also
        --------
        :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """


def cuUserObjectRelease(object, count):
    """
    cuUserObjectRelease(object, unsigned int count)
     Release a reference to a user object.

        Releases user object references owned by the caller. The object's
        destructor is invoked if the reference count reaches zero.

        It is undefined behavior to release references not owned by the caller,
        or to use a user object handle after all references are released.

        See CUDA User Objects in the CUDA C++ Programming Guide for more
        information on user objects.

        Parameters
        ----------
        object : :py:obj:`~.CUuserObject`
            The object to release
        count : unsigned int
            The number of references to release, typically 1. Must be nonzero
            and not larger than INT_MAX.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """


def cuUserObjectRetain(object, count):
    """
    cuUserObjectRetain(object, unsigned int count)
     Retain a reference to a user object.

        Retains new references to a user object. The new references are owned
        by the caller.

        See CUDA User Objects in the CUDA C++ Programming Guide for more
        information on user objects.

        Parameters
        ----------
        object : :py:obj:`~.CUuserObject`
            The object to retain
        count : unsigned int
            The number of references to retain, typically 1. Must be nonzero
            and not larger than INT_MAX.

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

        See Also
        --------
        :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """


def cuVDPAUCtxCreate(flags, device, vdpDevice, vdpGetProcAddress):
    """
    cuVDPAUCtxCreate(unsigned int flags, device, vdpDevice, vdpGetProcAddress)
     Create a CUDA context for interoperability with VDPAU.

        Creates a new CUDA context, initializes VDPAU interoperability, and
        associates the CUDA context with the calling thread. It must be called
        before performing any other VDPAU interoperability operations. It may
        fail if the needed VDPAU driver facilities are not available. For usage
        of the `flags` parameter, see :py:obj:`~.cuCtxCreate()`.

        Parameters
        ----------
        flags : unsigned int
            Options for CUDA context creation
        device : :py:obj:`~.CUdevice`
            Device on which to create the context
        vdpDevice : :py:obj:`~.VdpDevice`
            The VdpDevice to interop with
        vdpGetProcAddress : :py:obj:`~.VdpGetProcAddress`
            VDPAU's VdpGetProcAddress function pointer

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
        pCtx : :py:obj:`~.CUcontext`
            Returned CUDA context

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterVideoSurface`, :py:obj:`~.cuGraphicsVDPAURegisterOutputSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuVDPAUGetDevice`
    """


def cuVDPAUGetDevice(vdpDevice, vdpGetProcAddress):
    """
    cuVDPAUGetDevice(vdpDevice, vdpGetProcAddress)
     Gets the CUDA device associated with a VDPAU device.

        Returns in `*pDevice` the CUDA device associated with a `vdpDevice`, if
        applicable.

        Parameters
        ----------
        vdpDevice : :py:obj:`~.VdpDevice`
            A VdpDevice handle
        vdpGetProcAddress : :py:obj:`~.VdpGetProcAddress`
            VDPAU's VdpGetProcAddress function pointer

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
        pDevice : :py:obj:`~.CUdevice`
            Device associated with vdpDevice

        See Also
        --------
        :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuVDPAUCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterVideoSurface`, :py:obj:`~.cuGraphicsVDPAURegisterOutputSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cudaVDPAUGetDevice`
    """


def cuWaitExternalSemaphoresAsync(extSemArray: 'Optional[Tuple[CUexternalSemaphore] | List[CUexternalSemaphore]]', paramsArray: 'Optional[Tuple[CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS] | List[CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS]]', numExtSems, stream):
    """
    cuWaitExternalSemaphoresAsync(extSemArray: Optional[Tuple[CUexternalSemaphore] | List[CUexternalSemaphore]], paramsArray: Optional[Tuple[CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS] | List[CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS]], unsigned int numExtSems, stream)
     Waits on a set of external semaphore objects.

        Enqueues a wait operation on a set of externally allocated semaphore
        object in the specified stream. The operations will be executed when
        all prior operations in the stream complete.

        The exact semantics of waiting on a semaphore depends on the type of
        the object.

        If the semaphore object is any one of the following types:
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT` then
        waiting on the semaphore will wait until the semaphore reaches the
        signaled state. The semaphore will then be reset to the unsignaled
        state. Therefore for every signal operation, there can only be one wait
        operation.

        If the semaphore object is any one of the following types:
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32`
        then waiting on the semaphore will wait until the value of the
        semaphore is greater than or equal to
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`::params::fence::value.

        If the semaphore object is of the type
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC` then, waiting
        on the semaphore will wait until the
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::nvSciSync::fence
        is signaled by the signaler of the NvSciSyncObj that was associated
        with this semaphore object. By default, waiting on such an external
        semaphore object causes appropriate memory synchronization operations
        to be performed over all external memory objects that are imported as
        :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`. This ensures that
        any subsequent accesses made by other importers of the same set of
        NvSciBuf memory object(s) are coherent. These operations can be skipped
        by specifying the flag
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC`, which
        can be used as a performance optimization when data coherency is not
        required. But specifying this flag in scenarios where data coherency is
        required results in undefined behavior. Also, for semaphore object of
        the type :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC`, if
        the NvSciSyncAttrList used to create the NvSciSyncObj had not set the
        flags in :py:obj:`~.cuDeviceGetNvSciSyncAttributes` to
        CUDA_NVSCISYNC_ATTR_WAIT, this API will return
        CUDA_ERROR_NOT_SUPPORTED.

        If the semaphore object is any one of the following types:
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX`,
        :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT`
        then the keyed mutex will be acquired when it is released with the key
        specified in
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`::params::keyedmutex::key
        or until the timeout specified by
        :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`::params::keyedmutex::timeoutMs
        has lapsed. The timeout interval can either be a finite value specified
        in milliseconds or an infinite value. In case an infinite value is
        specified the timeout never elapses. The windows INFINITE macro must be
        used to specify infinite timeout.

        Parameters
        ----------
        extSemArray : List[:py:obj:`~.CUexternalSemaphore`]
            External semaphores to be waited on
        paramsArray : List[:py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`]
            Array of semaphore parameters
        numExtSems : unsigned int
            Number of semaphores to wait on
        stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
            Stream to enqueue the wait operations in

        Returns
        -------
        CUresult
            :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_TIMEOUT`

        See Also
        --------
        :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`
    """


def sizeof(objType):
    """
    sizeof(objType)
     Returns the size of provided CUDA Python structure in bytes

        Parameters
        ----------
        objType : Any
            CUDA Python object

        Returns
        -------
        lowered_name : int
            The size of `objType` in bytes
    """


class CUCoredumpGenerationFlags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_COREDUMP_DEFAULT_FLAGS: ClassVar[CUCoredumpGenerationFlags] = ...
    CU_COREDUMP_LIGHTWEIGHT_FLAGS: ClassVar[CUCoredumpGenerationFlags] = ...
    CU_COREDUMP_SKIP_ABORT: ClassVar[CUCoredumpGenerationFlags] = ...
    CU_COREDUMP_SKIP_CONSTBANK_MEMORY: ClassVar[CUCoredumpGenerationFlags] = ...
    CU_COREDUMP_SKIP_GLOBAL_MEMORY: ClassVar[CUCoredumpGenerationFlags] = ...
    CU_COREDUMP_SKIP_LOCAL_MEMORY: ClassVar[CUCoredumpGenerationFlags] = ...
    CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES: ClassVar[CUCoredumpGenerationFlags] = ...
    CU_COREDUMP_SKIP_SHARED_MEMORY: ClassVar[CUCoredumpGenerationFlags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUDA_ARRAY3D_DESCRIPTOR(CUDA_ARRAY3D_DESCRIPTOR_v2):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_ARRAY3D_DESCRIPTOR_st:
    Depth: Incomplete
    Flags: Incomplete
    Format: Incomplete
    Height: Incomplete
    NumChannels: Incomplete
    Width: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_ARRAY3D_DESCRIPTOR_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_ARRAY3D_DESCRIPTOR_st.__reduce_cython__(self)"""

class CUDA_ARRAY3D_DESCRIPTOR_v2(CUDA_ARRAY3D_DESCRIPTOR_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_ARRAY_DESCRIPTOR(CUDA_ARRAY_DESCRIPTOR_v2):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_ARRAY_DESCRIPTOR_st:
    Format: Incomplete
    Height: Incomplete
    NumChannels: Incomplete
    Width: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_ARRAY_DESCRIPTOR_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_ARRAY_DESCRIPTOR_st.__reduce_cython__(self)"""

class CUDA_ARRAY_DESCRIPTOR_v2(CUDA_ARRAY_DESCRIPTOR_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_ARRAY_MEMORY_REQUIREMENTS(CUDA_ARRAY_MEMORY_REQUIREMENTS_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_ARRAY_MEMORY_REQUIREMENTS_st:
    alignment: Incomplete
    reserved: Incomplete
    size: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_ARRAY_MEMORY_REQUIREMENTS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_ARRAY_MEMORY_REQUIREMENTS_st.__reduce_cython__(self)"""

class CUDA_ARRAY_MEMORY_REQUIREMENTS_v1(CUDA_ARRAY_MEMORY_REQUIREMENTS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_ARRAY_SPARSE_PROPERTIES(CUDA_ARRAY_SPARSE_PROPERTIES_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_ARRAY_SPARSE_PROPERTIES_st:
    flags: Incomplete
    miptailFirstLevel: Incomplete
    miptailSize: Incomplete
    reserved: Incomplete
    tileExtent: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_ARRAY_SPARSE_PROPERTIES_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_ARRAY_SPARSE_PROPERTIES_st.__reduce_cython__(self)"""

class CUDA_ARRAY_SPARSE_PROPERTIES_v1(CUDA_ARRAY_SPARSE_PROPERTIES_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_BATCH_MEM_OP_NODE_PARAMS(CUDA_BATCH_MEM_OP_NODE_PARAMS_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_BATCH_MEM_OP_NODE_PARAMS_v1(CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st:
    count: Incomplete
    ctx: Incomplete
    flags: Incomplete
    paramArray: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.__reduce_cython__(self)"""

class CUDA_BATCH_MEM_OP_NODE_PARAMS_v2(CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st:
    count: Incomplete
    ctx: Incomplete
    flags: Incomplete
    paramArray: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.__reduce_cython__(self)"""

class CUDA_CHILD_GRAPH_NODE_PARAMS(CUDA_CHILD_GRAPH_NODE_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_CHILD_GRAPH_NODE_PARAMS_st:
    graph: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_CHILD_GRAPH_NODE_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_CHILD_GRAPH_NODE_PARAMS_st.__reduce_cython__(self)"""

class CUDA_CONDITIONAL_NODE_PARAMS:
    ctx: Incomplete
    handle: Incomplete
    phGraph_out: Incomplete
    size: Incomplete
    type: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_CONDITIONAL_NODE_PARAMS.getPtr(self)"""
    def __reduce__(self):
        """CUDA_CONDITIONAL_NODE_PARAMS.__reduce_cython__(self)"""

class CUDA_EVENT_RECORD_NODE_PARAMS(CUDA_EVENT_RECORD_NODE_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EVENT_RECORD_NODE_PARAMS_st:
    event: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EVENT_RECORD_NODE_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EVENT_RECORD_NODE_PARAMS_st.__reduce_cython__(self)"""

class CUDA_EVENT_WAIT_NODE_PARAMS(CUDA_EVENT_WAIT_NODE_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EVENT_WAIT_NODE_PARAMS_st:
    event: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EVENT_WAIT_NODE_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EVENT_WAIT_NODE_PARAMS_st.__reduce_cython__(self)"""

class CUDA_EXTERNAL_MEMORY_BUFFER_DESC(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st:
    flags: Incomplete
    offset: Incomplete
    reserved: Incomplete
    size: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.__reduce_cython__(self)"""

class CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXTERNAL_MEMORY_HANDLE_DESC(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st:
    flags: Incomplete
    handle: Incomplete
    reserved: Incomplete
    size: Incomplete
    type: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.__reduce_cython__(self)"""

class CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st:
    arrayDesc: Incomplete
    numLevels: Incomplete
    offset: Incomplete
    reserved: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.__reduce_cython__(self)"""

class CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st:
    flags: Incomplete
    handle: Incomplete
    reserved: Incomplete
    type: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.__reduce_cython__(self)"""

class CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st:
    flags: Incomplete
    params: Incomplete
    reserved: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.__reduce_cython__(self)"""

class CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st:
    flags: Incomplete
    params: Incomplete
    reserved: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.__reduce_cython__(self)"""

class CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXT_SEM_SIGNAL_NODE_PARAMS(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st:
    extSemArray: Incomplete
    numExtSems: Incomplete
    paramsArray: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.__reduce_cython__(self)"""

class CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st:
    extSemArray: Incomplete
    numExtSems: Incomplete
    paramsArray: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.__reduce_cython__(self)"""

class CUDA_EXT_SEM_WAIT_NODE_PARAMS(CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXT_SEM_WAIT_NODE_PARAMS_st:
    extSemArray: Incomplete
    numExtSems: Incomplete
    paramsArray: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.__reduce_cython__(self)"""

class CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2(CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st:
    extSemArray: Incomplete
    numExtSems: Incomplete
    paramsArray: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.__reduce_cython__(self)"""

class CUDA_GRAPH_INSTANTIATE_PARAMS(CUDA_GRAPH_INSTANTIATE_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_GRAPH_INSTANTIATE_PARAMS_st:
    flags: Incomplete
    hErrNode_out: Incomplete
    hUploadStream: Incomplete
    result_out: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_GRAPH_INSTANTIATE_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_GRAPH_INSTANTIATE_PARAMS_st.__reduce_cython__(self)"""

class CUDA_HOST_NODE_PARAMS(CUDA_HOST_NODE_PARAMS_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_HOST_NODE_PARAMS_st:
    fn: Incomplete
    userData: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_HOST_NODE_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_HOST_NODE_PARAMS_st.__reduce_cython__(self)"""

class CUDA_HOST_NODE_PARAMS_v1(CUDA_HOST_NODE_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_HOST_NODE_PARAMS_v2(CUDA_HOST_NODE_PARAMS_v2_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_HOST_NODE_PARAMS_v2_st:
    fn: Incomplete
    userData: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_HOST_NODE_PARAMS_v2_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_HOST_NODE_PARAMS_v2_st.__reduce_cython__(self)"""

class CUDA_KERNEL_NODE_PARAMS(CUDA_KERNEL_NODE_PARAMS_v2):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_KERNEL_NODE_PARAMS_st:
    blockDimX: Incomplete
    blockDimY: Incomplete
    blockDimZ: Incomplete
    extra: Incomplete
    func: Incomplete
    gridDimX: Incomplete
    gridDimY: Incomplete
    gridDimZ: Incomplete
    kernelParams: Incomplete
    sharedMemBytes: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_KERNEL_NODE_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_KERNEL_NODE_PARAMS_st.__reduce_cython__(self)"""

class CUDA_KERNEL_NODE_PARAMS_v1(CUDA_KERNEL_NODE_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_KERNEL_NODE_PARAMS_v2(CUDA_KERNEL_NODE_PARAMS_v2_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_KERNEL_NODE_PARAMS_v2_st:
    blockDimX: Incomplete
    blockDimY: Incomplete
    blockDimZ: Incomplete
    ctx: Incomplete
    extra: Incomplete
    func: Incomplete
    gridDimX: Incomplete
    gridDimY: Incomplete
    gridDimZ: Incomplete
    kern: Incomplete
    kernelParams: Incomplete
    sharedMemBytes: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_KERNEL_NODE_PARAMS_v2_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_KERNEL_NODE_PARAMS_v2_st.__reduce_cython__(self)"""

class CUDA_KERNEL_NODE_PARAMS_v3(CUDA_KERNEL_NODE_PARAMS_v3_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_KERNEL_NODE_PARAMS_v3_st:
    blockDimX: Incomplete
    blockDimY: Incomplete
    blockDimZ: Incomplete
    ctx: Incomplete
    extra: Incomplete
    func: Incomplete
    gridDimX: Incomplete
    gridDimY: Incomplete
    gridDimZ: Incomplete
    kern: Incomplete
    kernelParams: Incomplete
    sharedMemBytes: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_KERNEL_NODE_PARAMS_v3_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_KERNEL_NODE_PARAMS_v3_st.__reduce_cython__(self)"""

class CUDA_LAUNCH_PARAMS(CUDA_LAUNCH_PARAMS_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_LAUNCH_PARAMS_st:
    blockDimX: Incomplete
    blockDimY: Incomplete
    blockDimZ: Incomplete
    function: Incomplete
    gridDimX: Incomplete
    gridDimY: Incomplete
    gridDimZ: Incomplete
    hStream: Incomplete
    kernelParams: Incomplete
    sharedMemBytes: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_LAUNCH_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_LAUNCH_PARAMS_st.__reduce_cython__(self)"""

class CUDA_LAUNCH_PARAMS_v1(CUDA_LAUNCH_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMCPY2D(CUDA_MEMCPY2D_v2):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMCPY2D_st:
    Height: Incomplete
    WidthInBytes: Incomplete
    dstArray: Incomplete
    dstDevice: Incomplete
    dstHost: Incomplete
    dstMemoryType: Incomplete
    dstPitch: Incomplete
    dstXInBytes: Incomplete
    dstY: Incomplete
    srcArray: Incomplete
    srcDevice: Incomplete
    srcHost: Incomplete
    srcMemoryType: Incomplete
    srcPitch: Incomplete
    srcXInBytes: Incomplete
    srcY: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_MEMCPY2D_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_MEMCPY2D_st.__reduce_cython__(self)"""

class CUDA_MEMCPY2D_v2(CUDA_MEMCPY2D_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMCPY3D(CUDA_MEMCPY3D_v2):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMCPY3D_BATCH_OP(CUDA_MEMCPY3D_BATCH_OP_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMCPY3D_BATCH_OP_st:
    dst: Incomplete
    extent: Incomplete
    flags: Incomplete
    src: Incomplete
    srcAccessOrder: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_MEMCPY3D_BATCH_OP_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_MEMCPY3D_BATCH_OP_st.__reduce_cython__(self)"""

class CUDA_MEMCPY3D_BATCH_OP_v1(CUDA_MEMCPY3D_BATCH_OP_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMCPY3D_PEER(CUDA_MEMCPY3D_PEER_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMCPY3D_PEER_st:
    Depth: Incomplete
    Height: Incomplete
    WidthInBytes: Incomplete
    dstArray: Incomplete
    dstContext: Incomplete
    dstDevice: Incomplete
    dstHeight: Incomplete
    dstHost: Incomplete
    dstLOD: Incomplete
    dstMemoryType: Incomplete
    dstPitch: Incomplete
    dstXInBytes: Incomplete
    dstY: Incomplete
    dstZ: Incomplete
    srcArray: Incomplete
    srcContext: Incomplete
    srcDevice: Incomplete
    srcHeight: Incomplete
    srcHost: Incomplete
    srcLOD: Incomplete
    srcMemoryType: Incomplete
    srcPitch: Incomplete
    srcXInBytes: Incomplete
    srcY: Incomplete
    srcZ: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_MEMCPY3D_PEER_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_MEMCPY3D_PEER_st.__reduce_cython__(self)"""

class CUDA_MEMCPY3D_PEER_v1(CUDA_MEMCPY3D_PEER_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMCPY3D_st:
    Depth: Incomplete
    Height: Incomplete
    WidthInBytes: Incomplete
    dstArray: Incomplete
    dstDevice: Incomplete
    dstHeight: Incomplete
    dstHost: Incomplete
    dstLOD: Incomplete
    dstMemoryType: Incomplete
    dstPitch: Incomplete
    dstXInBytes: Incomplete
    dstY: Incomplete
    dstZ: Incomplete
    reserved0: Incomplete
    reserved1: Incomplete
    srcArray: Incomplete
    srcDevice: Incomplete
    srcHeight: Incomplete
    srcHost: Incomplete
    srcLOD: Incomplete
    srcMemoryType: Incomplete
    srcPitch: Incomplete
    srcXInBytes: Incomplete
    srcY: Incomplete
    srcZ: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_MEMCPY3D_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_MEMCPY3D_st.__reduce_cython__(self)"""

class CUDA_MEMCPY3D_v2(CUDA_MEMCPY3D_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMCPY_NODE_PARAMS(CUDA_MEMCPY_NODE_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMCPY_NODE_PARAMS_st:
    copyCtx: Incomplete
    copyParams: Incomplete
    flags: Incomplete
    reserved: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_MEMCPY_NODE_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_MEMCPY_NODE_PARAMS_st.__reduce_cython__(self)"""

class CUDA_MEMSET_NODE_PARAMS(CUDA_MEMSET_NODE_PARAMS_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMSET_NODE_PARAMS_st:
    dst: Incomplete
    elementSize: Incomplete
    height: Incomplete
    pitch: Incomplete
    value: Incomplete
    width: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_MEMSET_NODE_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_MEMSET_NODE_PARAMS_st.__reduce_cython__(self)"""

class CUDA_MEMSET_NODE_PARAMS_v1(CUDA_MEMSET_NODE_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMSET_NODE_PARAMS_v2(CUDA_MEMSET_NODE_PARAMS_v2_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEMSET_NODE_PARAMS_v2_st:
    ctx: Incomplete
    dst: Incomplete
    elementSize: Incomplete
    height: Incomplete
    pitch: Incomplete
    value: Incomplete
    width: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_MEMSET_NODE_PARAMS_v2_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_MEMSET_NODE_PARAMS_v2_st.__reduce_cython__(self)"""

class CUDA_MEM_ALLOC_NODE_PARAMS(CUDA_MEM_ALLOC_NODE_PARAMS_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEM_ALLOC_NODE_PARAMS_v1(CUDA_MEM_ALLOC_NODE_PARAMS_v1_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEM_ALLOC_NODE_PARAMS_v1_st:
    accessDescCount: Incomplete
    accessDescs: Incomplete
    bytesize: Incomplete
    dptr: Incomplete
    poolProps: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.__reduce_cython__(self)"""

class CUDA_MEM_ALLOC_NODE_PARAMS_v2(CUDA_MEM_ALLOC_NODE_PARAMS_v2_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEM_ALLOC_NODE_PARAMS_v2_st:
    accessDescCount: Incomplete
    accessDescs: Incomplete
    bytesize: Incomplete
    dptr: Incomplete
    poolProps: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.__reduce_cython__(self)"""

class CUDA_MEM_FREE_NODE_PARAMS(CUDA_MEM_FREE_NODE_PARAMS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_MEM_FREE_NODE_PARAMS_st:
    dptr: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_MEM_FREE_NODE_PARAMS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_MEM_FREE_NODE_PARAMS_st.__reduce_cython__(self)"""

class CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE: ClassVar[CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS] = ...
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ: ClassVar[CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS] = ...
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE: ClassVar[CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUDA_POINTER_ATTRIBUTE_P2P_TOKENS(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st:
    p2pToken: Incomplete
    vaSpaceToken: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st.__reduce_cython__(self)"""

class CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_RESOURCE_DESC(CUDA_RESOURCE_DESC_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_RESOURCE_DESC_st:
    flags: Incomplete
    res: Incomplete
    resType: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_RESOURCE_DESC_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_RESOURCE_DESC_st.__reduce_cython__(self)"""

class CUDA_RESOURCE_DESC_v1(CUDA_RESOURCE_DESC_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_RESOURCE_VIEW_DESC(CUDA_RESOURCE_VIEW_DESC_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_RESOURCE_VIEW_DESC_st:
    depth: Incomplete
    firstLayer: Incomplete
    firstMipmapLevel: Incomplete
    format: Incomplete
    height: Incomplete
    lastLayer: Incomplete
    lastMipmapLevel: Incomplete
    reserved: Incomplete
    width: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_RESOURCE_VIEW_DESC_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_RESOURCE_VIEW_DESC_st.__reduce_cython__(self)"""

class CUDA_RESOURCE_VIEW_DESC_v1(CUDA_RESOURCE_VIEW_DESC_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_TEXTURE_DESC(CUDA_TEXTURE_DESC_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUDA_TEXTURE_DESC_st:
    addressMode: Incomplete
    borderColor: Incomplete
    filterMode: Incomplete
    flags: Incomplete
    maxAnisotropy: Incomplete
    maxMipmapLevelClamp: Incomplete
    minMipmapLevelClamp: Incomplete
    mipmapFilterMode: Incomplete
    mipmapLevelBias: Incomplete
    reserved: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUDA_TEXTURE_DESC_st.getPtr(self)"""
    def __reduce__(self):
        """CUDA_TEXTURE_DESC_st.__reduce_cython__(self)"""

class CUDA_TEXTURE_DESC_v1(CUDA_TEXTURE_DESC_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUGLDeviceList(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GL_DEVICE_LIST_ALL: ClassVar[CUGLDeviceList] = ...
    CU_GL_DEVICE_LIST_CURRENT_FRAME: ClassVar[CUGLDeviceList] = ...
    CU_GL_DEVICE_LIST_NEXT_FRAME: ClassVar[CUGLDeviceList] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUGLmap_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GL_MAP_RESOURCE_FLAGS_NONE: ClassVar[CUGLmap_flags] = ...
    CU_GL_MAP_RESOURCE_FLAGS_READ_ONLY: ClassVar[CUGLmap_flags] = ...
    CU_GL_MAP_RESOURCE_FLAGS_WRITE_DISCARD: ClassVar[CUGLmap_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUGPUDirectRDMAWritesOrdering(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES: ClassVar[CUGPUDirectRDMAWritesOrdering] = ...
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE: ClassVar[CUGPUDirectRDMAWritesOrdering] = ...
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER: ClassVar[CUGPUDirectRDMAWritesOrdering] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUaccessPolicyWindow(CUaccessPolicyWindow_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUaccessPolicyWindow_st:
    base_ptr: Incomplete
    hitProp: Incomplete
    hitRatio: Incomplete
    missProp: Incomplete
    num_bytes: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUaccessPolicyWindow_st.getPtr(self)"""
    def __reduce__(self):
        """CUaccessPolicyWindow_st.__reduce_cython__(self)"""

class CUaccessPolicyWindow_v1(CUaccessPolicyWindow_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUaccessProperty(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_ACCESS_PROPERTY_NORMAL: ClassVar[CUaccessProperty] = ...
    CU_ACCESS_PROPERTY_PERSISTING: ClassVar[CUaccessProperty] = ...
    CU_ACCESS_PROPERTY_STREAMING: ClassVar[CUaccessProperty] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUaddress_mode(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_TR_ADDRESS_MODE_BORDER: ClassVar[CUaddress_mode] = ...
    CU_TR_ADDRESS_MODE_CLAMP: ClassVar[CUaddress_mode] = ...
    CU_TR_ADDRESS_MODE_MIRROR: ClassVar[CUaddress_mode] = ...
    CU_TR_ADDRESS_MODE_WRAP: ClassVar[CUaddress_mode] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUarray:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUarray.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUarray.__reduce_cython__(self)"""

class CUarrayMapInfo(CUarrayMapInfo_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUarrayMapInfo_st:
    deviceBitMask: Incomplete
    flags: Incomplete
    memHandle: Incomplete
    memHandleType: Incomplete
    memOperationType: Incomplete
    offset: Incomplete
    reserved: Incomplete
    resource: Incomplete
    resourceType: Incomplete
    subresource: Incomplete
    subresourceType: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUarrayMapInfo_st.getPtr(self)"""
    def __reduce__(self):
        """CUarrayMapInfo_st.__reduce_cython__(self)"""

class CUarrayMapInfo_v1(CUarrayMapInfo_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUarraySparseSubresourceType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL: ClassVar[CUarraySparseSubresourceType] = ...
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL: ClassVar[CUarraySparseSubresourceType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUarray_cubemap_face(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_CUBEMAP_FACE_NEGATIVE_X: ClassVar[CUarray_cubemap_face] = ...
    CU_CUBEMAP_FACE_NEGATIVE_Y: ClassVar[CUarray_cubemap_face] = ...
    CU_CUBEMAP_FACE_NEGATIVE_Z: ClassVar[CUarray_cubemap_face] = ...
    CU_CUBEMAP_FACE_POSITIVE_X: ClassVar[CUarray_cubemap_face] = ...
    CU_CUBEMAP_FACE_POSITIVE_Y: ClassVar[CUarray_cubemap_face] = ...
    CU_CUBEMAP_FACE_POSITIVE_Z: ClassVar[CUarray_cubemap_face] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUarray_format(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_AD_FORMAT_AYUV: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC1_UNORM: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC1_UNORM_SRGB: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC2_UNORM: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC2_UNORM_SRGB: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC3_UNORM: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC3_UNORM_SRGB: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC4_SNORM: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC4_UNORM: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC5_SNORM: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC5_UNORM: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC6H_SF16: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC6H_UF16: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC7_UNORM: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_BC7_UNORM_SRGB: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_FLOAT: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_HALF: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_MAX: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_NV12: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_NV16: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_P010: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_P016: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_P210: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_P216: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_SIGNED_INT16: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_SIGNED_INT32: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_SIGNED_INT8: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_SNORM_INT16X1: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_SNORM_INT16X2: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_SNORM_INT16X4: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_SNORM_INT8X1: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_SNORM_INT8X2: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_SNORM_INT8X4: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_UNORM_INT16X1: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_UNORM_INT16X2: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_UNORM_INT16X4: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_UNORM_INT8X1: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_UNORM_INT8X2: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_UNORM_INT8X4: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_UNORM_INT_101010_2: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_UNSIGNED_INT16: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_UNSIGNED_INT32: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_UNSIGNED_INT8: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_Y210: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_Y216: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_Y410: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_Y416: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_Y444_PLANAR10: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_Y444_PLANAR8: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_YUV444_16bit_SemiPlanar: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_YUV444_8bit_SemiPlanar: ClassVar[CUarray_format] = ...
    CU_AD_FORMAT_YUY2: ClassVar[CUarray_format] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUasyncCallback:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUasyncCallback.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUasyncCallback.__reduce_cython__(self)"""

class CUasyncCallbackHandle:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUasyncCallbackHandle.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUasyncCallbackHandle.__reduce_cython__(self)"""

class CUasyncNotificationInfo(CUasyncNotificationInfo_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUasyncNotificationInfo_st:
    info: Incomplete
    type: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUasyncNotificationInfo_st.getPtr(self)"""
    def __reduce__(self):
        """CUasyncNotificationInfo_st.__reduce_cython__(self)"""

class CUasyncNotificationType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_ASYNC_NOTIFICATION_TYPE_OVER_BUDGET: ClassVar[CUasyncNotificationType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUcheckpointCheckpointArgs(CUcheckpointCheckpointArgs_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUcheckpointCheckpointArgs_st:
    reserved: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUcheckpointCheckpointArgs_st.getPtr(self)"""
    def __reduce__(self):
        """CUcheckpointCheckpointArgs_st.__reduce_cython__(self)"""

class CUcheckpointLockArgs(CUcheckpointLockArgs_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUcheckpointLockArgs_st:
    reserved0: Incomplete
    reserved1: Incomplete
    timeoutMs: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUcheckpointLockArgs_st.getPtr(self)"""
    def __reduce__(self):
        """CUcheckpointLockArgs_st.__reduce_cython__(self)"""

class CUcheckpointRestoreArgs(CUcheckpointRestoreArgs_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUcheckpointRestoreArgs_st:
    reserved: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUcheckpointRestoreArgs_st.getPtr(self)"""
    def __reduce__(self):
        """CUcheckpointRestoreArgs_st.__reduce_cython__(self)"""

class CUcheckpointUnlockArgs(CUcheckpointUnlockArgs_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUcheckpointUnlockArgs_st:
    reserved: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUcheckpointUnlockArgs_st.getPtr(self)"""
    def __reduce__(self):
        """CUcheckpointUnlockArgs_st.__reduce_cython__(self)"""

class CUcigDataType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CIG_DATA_TYPE_D3D12_COMMAND_QUEUE: ClassVar[CUcigDataType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUclusterSchedulingPolicy(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_CLUSTER_SCHEDULING_POLICY_DEFAULT: ClassVar[CUclusterSchedulingPolicy] = ...
    CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING: ClassVar[CUclusterSchedulingPolicy] = ...
    CU_CLUSTER_SCHEDULING_POLICY_SPREAD: ClassVar[CUclusterSchedulingPolicy] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUcomputemode(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_COMPUTEMODE_DEFAULT: ClassVar[CUcomputemode] = ...
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS: ClassVar[CUcomputemode] = ...
    CU_COMPUTEMODE_PROHIBITED: ClassVar[CUcomputemode] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUcontext:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUcontext.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUcontext.__reduce_cython__(self)"""

class CUcoredumpSettings(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_COREDUMP_ENABLE_ON_EXCEPTION: ClassVar[CUcoredumpSettings] = ...
    CU_COREDUMP_ENABLE_USER_TRIGGER: ClassVar[CUcoredumpSettings] = ...
    CU_COREDUMP_FILE: ClassVar[CUcoredumpSettings] = ...
    CU_COREDUMP_GENERATION_FLAGS: ClassVar[CUcoredumpSettings] = ...
    CU_COREDUMP_LIGHTWEIGHT: ClassVar[CUcoredumpSettings] = ...
    CU_COREDUMP_MAX: ClassVar[CUcoredumpSettings] = ...
    CU_COREDUMP_PIPE: ClassVar[CUcoredumpSettings] = ...
    CU_COREDUMP_TRIGGER_HOST: ClassVar[CUcoredumpSettings] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUctxCigParam(CUctxCigParam_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUctxCigParam_st:
    sharedData: Incomplete
    sharedDataType: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUctxCigParam_st.getPtr(self)"""
    def __reduce__(self):
        """CUctxCigParam_st.__reduce_cython__(self)"""

class CUctxCreateParams(CUctxCreateParams_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUctxCreateParams_st:
    cigParams: Incomplete
    execAffinityParams: Incomplete
    numExecAffinityParams: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUctxCreateParams_st.getPtr(self)"""
    def __reduce__(self):
        """CUctxCreateParams_st.__reduce_cython__(self)"""

class CUctx_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_CTX_BLOCKING_SYNC: ClassVar[CUctx_flags] = ...
    CU_CTX_COREDUMP_ENABLE: ClassVar[CUctx_flags] = ...
    CU_CTX_FLAGS_MASK: ClassVar[CUctx_flags] = ...
    CU_CTX_LMEM_RESIZE_TO_MAX: ClassVar[CUctx_flags] = ...
    CU_CTX_MAP_HOST: ClassVar[CUctx_flags] = ...
    CU_CTX_SCHED_AUTO: ClassVar[CUctx_flags] = ...
    CU_CTX_SCHED_BLOCKING_SYNC: ClassVar[CUctx_flags] = ...
    CU_CTX_SCHED_MASK: ClassVar[CUctx_flags] = ...
    CU_CTX_SCHED_SPIN: ClassVar[CUctx_flags] = ...
    CU_CTX_SCHED_YIELD: ClassVar[CUctx_flags] = ...
    CU_CTX_SYNC_MEMOPS: ClassVar[CUctx_flags] = ...
    CU_CTX_USER_COREDUMP_ENABLE: ClassVar[CUctx_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUdevResource(CUdevResource_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUdevResourceDesc:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUdevResourceDesc.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUdevResourceDesc.__reduce_cython__(self)"""

class CUdevResourceType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_DEV_RESOURCE_TYPE_INVALID: ClassVar[CUdevResourceType] = ...
    CU_DEV_RESOURCE_TYPE_SM: ClassVar[CUdevResourceType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUdevResource_st:
    sm: Incomplete
    type: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUdevResource_st.getPtr(self)"""
    def __reduce__(self):
        """CUdevResource_st.__reduce_cython__(self)"""

class CUdevResource_v1(CUdevResource_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUdevSmResource(CUdevSmResource_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUdevSmResourceSplit_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_DEV_SM_RESOURCE_SPLIT_IGNORE_SM_COSCHEDULING: ClassVar[CUdevSmResourceSplit_flags] = ...
    CU_DEV_SM_RESOURCE_SPLIT_MAX_POTENTIAL_CLUSTER_SIZE: ClassVar[CUdevSmResourceSplit_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUdevSmResource_st:
    smCount: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUdevSmResource_st.getPtr(self)"""
    def __reduce__(self):
        """CUdevSmResource_st.__reduce_cython__(self)"""

class CUdevice:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """CUdevice.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUdevice.__reduce_cython__(self)"""

class CUdeviceNumaConfig(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_DEVICE_NUMA_CONFIG_NONE: ClassVar[CUdeviceNumaConfig] = ...
    CU_DEVICE_NUMA_CONFIG_NUMA_NODE: ClassVar[CUdeviceNumaConfig] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUdevice_P2PAttribute(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED: ClassVar[CUdevice_P2PAttribute] = ...
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED: ClassVar[CUdevice_P2PAttribute] = ...
    CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED: ClassVar[CUdevice_P2PAttribute] = ...
    CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED: ClassVar[CUdevice_P2PAttribute] = ...
    CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK: ClassVar[CUdevice_P2PAttribute] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUdevice_attribute(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V1: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS_V1: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V1: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_GPU_PCI_DEVICE_ID: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_GPU_PCI_SUBSYSTEM_ID: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_HOST_NUMA_MULTINODE_IPC_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_INTEGRATED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_PITCH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_MAXIMUM_LENGTH: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MPS_ENABLED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_NUMA_CONFIG: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_NUMA_ID: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_TENSOR_MAP_ACCESS_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED: ClassVar[CUdevice_attribute] = ...
    CU_DEVICE_ATTRIBUTE_WARP_SIZE: ClassVar[CUdevice_attribute] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUdevice_v1:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """CUdevice_v1.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUdevice_v1.__reduce_cython__(self)"""

class CUdeviceptr:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """CUdeviceptr.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUdeviceptr.__reduce_cython__(self)"""

class CUdeviceptr_v2:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """CUdeviceptr_v2.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUdeviceptr_v2.__reduce_cython__(self)"""

class CUdevprop(CUdevprop_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUdevprop_st:
    SIMDWidth: Incomplete
    clockRate: Incomplete
    maxGridSize: Incomplete
    maxThreadsDim: Incomplete
    maxThreadsPerBlock: Incomplete
    memPitch: Incomplete
    regsPerBlock: Incomplete
    sharedMemPerBlock: Incomplete
    textureAlign: Incomplete
    totalConstantMemory: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUdevprop_st.getPtr(self)"""
    def __reduce__(self):
        """CUdevprop_st.__reduce_cython__(self)"""

class CUdevprop_v1(CUdevprop_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUdriverProcAddressQueryResult(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GET_PROC_ADDRESS_SUCCESS: ClassVar[CUdriverProcAddressQueryResult] = ...
    CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND: ClassVar[CUdriverProcAddressQueryResult] = ...
    CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT: ClassVar[CUdriverProcAddressQueryResult] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUdriverProcAddress_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GET_PROC_ADDRESS_DEFAULT: ClassVar[CUdriverProcAddress_flags] = ...
    CU_GET_PROC_ADDRESS_LEGACY_STREAM: ClassVar[CUdriverProcAddress_flags] = ...
    CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM: ClassVar[CUdriverProcAddress_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUeglColorFormat(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_EGL_COLOR_FORMAT_A: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_ABGR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_ARGB: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_AYUV: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_AYUV_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER10_BGGR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER10_CCCC: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER10_GBRG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER10_GRBG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER10_RGGB: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER12_BCCR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER12_BGGR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER12_CBRC: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER12_CCCC: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER12_CRBC: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER12_GBRG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER12_GRBG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER12_RCCB: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER12_RGGB: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER14_BGGR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER14_GBRG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER14_GRBG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER14_RGGB: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER20_BGGR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER20_GBRG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER20_GRBG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER20_RGGB: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_BCCR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_BGGR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_CBRC: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_CRBC: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_GBRG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_GRBG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_ISP_BGGR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_ISP_GBRG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_ISP_GRBG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_ISP_RGGB: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_RCCB: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BAYER_RGGB: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BGR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_BGRA: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_L: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_MAX: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_R: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_RG: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_RGB: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_RGBA: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_UYVY_2020: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_UYVY_422: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_UYVY_709: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_UYVY_709_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_UYVY_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_VYUY: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_VYUY_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_2020: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_2020: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_709: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_709_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10_709_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y10_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_709_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_709_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y12_709_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y12_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR_2020: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR_709: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_2020: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_709: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV422_PLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV422_PLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV444_PLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV444_PLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUVA: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUVA_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUV_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUYV_422: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YUYV_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR_2020: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR_709: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_2020: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_709: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU422_PLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU422_PLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU444_PLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU444_PLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVYU: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_YVYU_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y_709_ER: ClassVar[CUeglColorFormat] = ...
    CU_EGL_COLOR_FORMAT_Y_ER: ClassVar[CUeglColorFormat] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUeglFrame(CUeglFrame_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUeglFrameType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_EGL_FRAME_TYPE_ARRAY: ClassVar[CUeglFrameType] = ...
    CU_EGL_FRAME_TYPE_PITCH: ClassVar[CUeglFrameType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUeglFrame_st:
    cuFormat: Incomplete
    depth: Incomplete
    eglColorFormat: Incomplete
    frame: Incomplete
    frameType: Incomplete
    height: Incomplete
    numChannels: Incomplete
    pitch: Incomplete
    planeCount: Incomplete
    width: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUeglFrame_st.getPtr(self)"""
    def __reduce__(self):
        """CUeglFrame_st.__reduce_cython__(self)"""

class CUeglFrame_v1(CUeglFrame_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUeglResourceLocationFlags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_EGL_RESOURCE_LOCATION_SYSMEM: ClassVar[CUeglResourceLocationFlags] = ...
    CU_EGL_RESOURCE_LOCATION_VIDMEM: ClassVar[CUeglResourceLocationFlags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUeglStreamConnection:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUeglStreamConnection.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUeglStreamConnection.__reduce_cython__(self)"""

class CUevent:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUevent.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUevent.__reduce_cython__(self)"""

class CUevent_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_EVENT_BLOCKING_SYNC: ClassVar[CUevent_flags] = ...
    CU_EVENT_DEFAULT: ClassVar[CUevent_flags] = ...
    CU_EVENT_DISABLE_TIMING: ClassVar[CUevent_flags] = ...
    CU_EVENT_INTERPROCESS: ClassVar[CUevent_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUevent_record_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_EVENT_RECORD_DEFAULT: ClassVar[CUevent_record_flags] = ...
    CU_EVENT_RECORD_EXTERNAL: ClassVar[CUevent_record_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUevent_sched_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_EVENT_SCHED_AUTO: ClassVar[CUevent_sched_flags] = ...
    CU_EVENT_SCHED_BLOCKING_SYNC: ClassVar[CUevent_sched_flags] = ...
    CU_EVENT_SCHED_SPIN: ClassVar[CUevent_sched_flags] = ...
    CU_EVENT_SCHED_YIELD: ClassVar[CUevent_sched_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUevent_wait_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_EVENT_WAIT_DEFAULT: ClassVar[CUevent_wait_flags] = ...
    CU_EVENT_WAIT_EXTERNAL: ClassVar[CUevent_wait_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUexecAffinityParam(CUexecAffinityParam_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUexecAffinityParam_st:
    param: Incomplete
    type: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUexecAffinityParam_st.getPtr(self)"""
    def __reduce__(self):
        """CUexecAffinityParam_st.__reduce_cython__(self)"""

class CUexecAffinityParam_v1(CUexecAffinityParam_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUexecAffinitySmCount(CUexecAffinitySmCount_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUexecAffinitySmCount_st:
    val: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUexecAffinitySmCount_st.getPtr(self)"""
    def __reduce__(self):
        """CUexecAffinitySmCount_st.__reduce_cython__(self)"""

class CUexecAffinitySmCount_v1(CUexecAffinitySmCount_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUexecAffinityType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_EXEC_AFFINITY_TYPE_MAX: ClassVar[CUexecAffinityType] = ...
    CU_EXEC_AFFINITY_TYPE_SM_COUNT: ClassVar[CUexecAffinityType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUextent3D(CUextent3D_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUextent3D_st:
    depth: Incomplete
    height: Incomplete
    width: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUextent3D_st.getPtr(self)"""
    def __reduce__(self):
        """CUextent3D_st.__reduce_cython__(self)"""

class CUextent3D_v1(CUextent3D_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUexternalMemory:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUexternalMemory.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUexternalMemory.__reduce_cython__(self)"""

class CUexternalMemoryHandleType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE: ClassVar[CUexternalMemoryHandleType] = ...
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT: ClassVar[CUexternalMemoryHandleType] = ...
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP: ClassVar[CUexternalMemoryHandleType] = ...
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE: ClassVar[CUexternalMemoryHandleType] = ...
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF: ClassVar[CUexternalMemoryHandleType] = ...
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD: ClassVar[CUexternalMemoryHandleType] = ...
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32: ClassVar[CUexternalMemoryHandleType] = ...
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT: ClassVar[CUexternalMemoryHandleType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUexternalSemaphore:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUexternalSemaphore.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUexternalSemaphore.__reduce_cython__(self)"""

class CUexternalSemaphoreHandleType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE: ClassVar[CUexternalSemaphoreHandleType] = ...
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX: ClassVar[CUexternalSemaphoreHandleType] = ...
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT: ClassVar[CUexternalSemaphoreHandleType] = ...
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE: ClassVar[CUexternalSemaphoreHandleType] = ...
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC: ClassVar[CUexternalSemaphoreHandleType] = ...
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD: ClassVar[CUexternalSemaphoreHandleType] = ...
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32: ClassVar[CUexternalSemaphoreHandleType] = ...
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT: ClassVar[CUexternalSemaphoreHandleType] = ...
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD: ClassVar[CUexternalSemaphoreHandleType] = ...
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32: ClassVar[CUexternalSemaphoreHandleType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUfilter_mode(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_TR_FILTER_MODE_LINEAR: ClassVar[CUfilter_mode] = ...
    CU_TR_FILTER_MODE_POINT: ClassVar[CUfilter_mode] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUflushGPUDirectRDMAWritesOptions(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST: ClassVar[CUflushGPUDirectRDMAWritesOptions] = ...
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS: ClassVar[CUflushGPUDirectRDMAWritesOptions] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUflushGPUDirectRDMAWritesScope(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES: ClassVar[CUflushGPUDirectRDMAWritesScope] = ...
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER: ClassVar[CUflushGPUDirectRDMAWritesScope] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUflushGPUDirectRDMAWritesTarget(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX: ClassVar[CUflushGPUDirectRDMAWritesTarget] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUfunc_cache(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_FUNC_CACHE_PREFER_EQUAL: ClassVar[CUfunc_cache] = ...
    CU_FUNC_CACHE_PREFER_L1: ClassVar[CUfunc_cache] = ...
    CU_FUNC_CACHE_PREFER_NONE: ClassVar[CUfunc_cache] = ...
    CU_FUNC_CACHE_PREFER_SHARED: ClassVar[CUfunc_cache] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUfunction:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUfunction.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUfunction.__reduce_cython__(self)"""

class CUfunctionLoadingState(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_FUNCTION_LOADING_STATE_LOADED: ClassVar[CUfunctionLoadingState] = ...
    CU_FUNCTION_LOADING_STATE_MAX: ClassVar[CUfunctionLoadingState] = ...
    CU_FUNCTION_LOADING_STATE_UNLOADED: ClassVar[CUfunctionLoadingState] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUfunction_attribute(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_FUNC_ATTRIBUTE_BINARY_VERSION: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_MAX: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_NUM_REGS: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_PTX_VERSION: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH: ClassVar[CUfunction_attribute] = ...
    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES: ClassVar[CUfunction_attribute] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUgraph:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUgraph.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUgraph.__reduce_cython__(self)"""

class CUgraphConditionalHandle:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """CUgraphConditionalHandle.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUgraphConditionalHandle.__reduce_cython__(self)"""

class CUgraphConditionalNodeType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GRAPH_COND_TYPE_IF: ClassVar[CUgraphConditionalNodeType] = ...
    CU_GRAPH_COND_TYPE_SWITCH: ClassVar[CUgraphConditionalNodeType] = ...
    CU_GRAPH_COND_TYPE_WHILE: ClassVar[CUgraphConditionalNodeType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUgraphDebugDot_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_CONDITIONAL_NODE_PARAMS: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_EXTRA_TOPO_INFO: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES: ClassVar[CUgraphDebugDot_flags] = ...
    CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE: ClassVar[CUgraphDebugDot_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUgraphDependencyType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GRAPH_DEPENDENCY_TYPE_DEFAULT: ClassVar[CUgraphDependencyType] = ...
    CU_GRAPH_DEPENDENCY_TYPE_PROGRAMMATIC: ClassVar[CUgraphDependencyType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUgraphDeviceNode:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUgraphDeviceNode.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUgraphDeviceNode.__reduce_cython__(self)"""

class CUgraphEdgeData(CUgraphEdgeData_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUgraphEdgeData_st:
    from_port: Incomplete
    reserved: Incomplete
    to_port: Incomplete
    type: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUgraphEdgeData_st.getPtr(self)"""
    def __reduce__(self):
        """CUgraphEdgeData_st.__reduce_cython__(self)"""

class CUgraphExec:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUgraphExec.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUgraphExec.__reduce_cython__(self)"""

class CUgraphExecUpdateResult(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GRAPH_EXEC_UPDATE_ERROR: ClassVar[CUgraphExecUpdateResult] = ...
    CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED: ClassVar[CUgraphExecUpdateResult] = ...
    CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED: ClassVar[CUgraphExecUpdateResult] = ...
    CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED: ClassVar[CUgraphExecUpdateResult] = ...
    CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED: ClassVar[CUgraphExecUpdateResult] = ...
    CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED: ClassVar[CUgraphExecUpdateResult] = ...
    CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED: ClassVar[CUgraphExecUpdateResult] = ...
    CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE: ClassVar[CUgraphExecUpdateResult] = ...
    CU_GRAPH_EXEC_UPDATE_SUCCESS: ClassVar[CUgraphExecUpdateResult] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUgraphExecUpdateResultInfo(CUgraphExecUpdateResultInfo_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUgraphExecUpdateResultInfo_st:
    errorFromNode: Incomplete
    errorNode: Incomplete
    result: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUgraphExecUpdateResultInfo_st.getPtr(self)"""
    def __reduce__(self):
        """CUgraphExecUpdateResultInfo_st.__reduce_cython__(self)"""

class CUgraphExecUpdateResultInfo_v1(CUgraphExecUpdateResultInfo_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUgraphInstantiateResult(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CUDA_GRAPH_INSTANTIATE_CONDITIONAL_HANDLE_UNUSED: ClassVar[CUgraphInstantiateResult] = ...
    CUDA_GRAPH_INSTANTIATE_ERROR: ClassVar[CUgraphInstantiateResult] = ...
    CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE: ClassVar[CUgraphInstantiateResult] = ...
    CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED: ClassVar[CUgraphInstantiateResult] = ...
    CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED: ClassVar[CUgraphInstantiateResult] = ...
    CUDA_GRAPH_INSTANTIATE_SUCCESS: ClassVar[CUgraphInstantiateResult] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUgraphInstantiate_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH: ClassVar[CUgraphInstantiate_flags] = ...
    CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH: ClassVar[CUgraphInstantiate_flags] = ...
    CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD: ClassVar[CUgraphInstantiate_flags] = ...
    CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY: ClassVar[CUgraphInstantiate_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUgraphMem_attribute(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT: ClassVar[CUgraphMem_attribute] = ...
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH: ClassVar[CUgraphMem_attribute] = ...
    CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT: ClassVar[CUgraphMem_attribute] = ...
    CU_GRAPH_MEM_ATTR_USED_MEM_HIGH: ClassVar[CUgraphMem_attribute] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUgraphNode:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUgraphNode.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUgraphNode.__reduce_cython__(self)"""

class CUgraphNodeParams(CUgraphNodeParams_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUgraphNodeParams_st:
    alloc: Incomplete
    conditional: Incomplete
    eventRecord: Incomplete
    eventWait: Incomplete
    extSemSignal: Incomplete
    extSemWait: Incomplete
    free: Incomplete
    graph: Incomplete
    host: Incomplete
    kernel: Incomplete
    memOp: Incomplete
    memcpy: Incomplete
    memset: Incomplete
    reserved0: Incomplete
    reserved1: Incomplete
    reserved2: Incomplete
    type: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUgraphNodeParams_st.getPtr(self)"""
    def __reduce__(self):
        """CUgraphNodeParams_st.__reduce_cython__(self)"""

class CUgraphNodeType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GRAPH_NODE_TYPE_BATCH_MEM_OP: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_CONDITIONAL: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_EMPTY: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_EVENT_RECORD: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_GRAPH: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_HOST: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_KERNEL: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_MEMCPY: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_MEMSET: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_MEM_ALLOC: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_MEM_FREE: ClassVar[CUgraphNodeType] = ...
    CU_GRAPH_NODE_TYPE_WAIT_EVENT: ClassVar[CUgraphNodeType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUgraphicsMapResourceFlags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE: ClassVar[CUgraphicsMapResourceFlags] = ...
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY: ClassVar[CUgraphicsMapResourceFlags] = ...
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD: ClassVar[CUgraphicsMapResourceFlags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUgraphicsRegisterFlags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GRAPHICS_REGISTER_FLAGS_NONE: ClassVar[CUgraphicsRegisterFlags] = ...
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY: ClassVar[CUgraphicsRegisterFlags] = ...
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST: ClassVar[CUgraphicsRegisterFlags] = ...
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER: ClassVar[CUgraphicsRegisterFlags] = ...
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD: ClassVar[CUgraphicsRegisterFlags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUgraphicsResource:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUgraphicsResource.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUgraphicsResource.__reduce_cython__(self)"""

class CUgreenCtx:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUgreenCtx.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUgreenCtx.__reduce_cython__(self)"""

class CUgreenCtxCreate_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GREEN_CTX_DEFAULT_STREAM: ClassVar[CUgreenCtxCreate_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUhostFn:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUhostFn.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUhostFn.__reduce_cython__(self)"""

class CUipcEventHandle(CUipcEventHandle_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUipcEventHandle_st:
    reserved: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUipcEventHandle_st.getPtr(self)"""
    def __reduce__(self):
        """CUipcEventHandle_st.__reduce_cython__(self)"""

class CUipcEventHandle_v1(CUipcEventHandle_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUipcMemHandle(CUipcMemHandle_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUipcMemHandle_st:
    reserved: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUipcMemHandle_st.getPtr(self)"""
    def __reduce__(self):
        """CUipcMemHandle_st.__reduce_cython__(self)"""

class CUipcMemHandle_v1(CUipcMemHandle_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUipcMem_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS: ClassVar[CUipcMem_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUjitInputType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_JIT_INPUT_CUBIN: ClassVar[CUjitInputType] = ...
    CU_JIT_INPUT_FATBINARY: ClassVar[CUjitInputType] = ...
    CU_JIT_INPUT_LIBRARY: ClassVar[CUjitInputType] = ...
    CU_JIT_INPUT_NVVM: ClassVar[CUjitInputType] = ...
    CU_JIT_INPUT_OBJECT: ClassVar[CUjitInputType] = ...
    CU_JIT_INPUT_PTX: ClassVar[CUjitInputType] = ...
    CU_JIT_NUM_INPUT_TYPES: ClassVar[CUjitInputType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUjit_cacheMode(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_JIT_CACHE_OPTION_CA: ClassVar[CUjit_cacheMode] = ...
    CU_JIT_CACHE_OPTION_CG: ClassVar[CUjit_cacheMode] = ...
    CU_JIT_CACHE_OPTION_NONE: ClassVar[CUjit_cacheMode] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUjit_fallback(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_PREFER_BINARY: ClassVar[CUjit_fallback] = ...
    CU_PREFER_PTX: ClassVar[CUjit_fallback] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUjit_option(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_JIT_CACHE_MODE: ClassVar[CUjit_option] = ...
    CU_JIT_ERROR_LOG_BUFFER: ClassVar[CUjit_option] = ...
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES: ClassVar[CUjit_option] = ...
    CU_JIT_FALLBACK_STRATEGY: ClassVar[CUjit_option] = ...
    CU_JIT_FAST_COMPILE: ClassVar[CUjit_option] = ...
    CU_JIT_FMA: ClassVar[CUjit_option] = ...
    CU_JIT_FTZ: ClassVar[CUjit_option] = ...
    CU_JIT_GENERATE_DEBUG_INFO: ClassVar[CUjit_option] = ...
    CU_JIT_GENERATE_LINE_INFO: ClassVar[CUjit_option] = ...
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES: ClassVar[CUjit_option] = ...
    CU_JIT_GLOBAL_SYMBOL_COUNT: ClassVar[CUjit_option] = ...
    CU_JIT_GLOBAL_SYMBOL_NAMES: ClassVar[CUjit_option] = ...
    CU_JIT_INFO_LOG_BUFFER: ClassVar[CUjit_option] = ...
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES: ClassVar[CUjit_option] = ...
    CU_JIT_LOG_VERBOSE: ClassVar[CUjit_option] = ...
    CU_JIT_LTO: ClassVar[CUjit_option] = ...
    CU_JIT_MAX_REGISTERS: ClassVar[CUjit_option] = ...
    CU_JIT_MAX_THREADS_PER_BLOCK: ClassVar[CUjit_option] = ...
    CU_JIT_MIN_CTA_PER_SM: ClassVar[CUjit_option] = ...
    CU_JIT_NEW_SM3X_OPT: ClassVar[CUjit_option] = ...
    CU_JIT_NUM_OPTIONS: ClassVar[CUjit_option] = ...
    CU_JIT_OPTIMIZATION_LEVEL: ClassVar[CUjit_option] = ...
    CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES: ClassVar[CUjit_option] = ...
    CU_JIT_OVERRIDE_DIRECTIVE_VALUES: ClassVar[CUjit_option] = ...
    CU_JIT_POSITION_INDEPENDENT_CODE: ClassVar[CUjit_option] = ...
    CU_JIT_PREC_DIV: ClassVar[CUjit_option] = ...
    CU_JIT_PREC_SQRT: ClassVar[CUjit_option] = ...
    CU_JIT_REFERENCED_KERNEL_COUNT: ClassVar[CUjit_option] = ...
    CU_JIT_REFERENCED_KERNEL_NAMES: ClassVar[CUjit_option] = ...
    CU_JIT_REFERENCED_VARIABLE_COUNT: ClassVar[CUjit_option] = ...
    CU_JIT_REFERENCED_VARIABLE_NAMES: ClassVar[CUjit_option] = ...
    CU_JIT_TARGET: ClassVar[CUjit_option] = ...
    CU_JIT_TARGET_FROM_CUCONTEXT: ClassVar[CUjit_option] = ...
    CU_JIT_THREADS_PER_BLOCK: ClassVar[CUjit_option] = ...
    CU_JIT_WALL_TIME: ClassVar[CUjit_option] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUjit_target(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_TARGET_COMPUTE_100: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_100A: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_101: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_101A: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_120: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_120A: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_30: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_32: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_35: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_37: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_50: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_52: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_53: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_60: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_61: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_62: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_70: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_72: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_75: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_80: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_86: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_87: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_89: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_90: ClassVar[CUjit_target] = ...
    CU_TARGET_COMPUTE_90A: ClassVar[CUjit_target] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUkernel:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUkernel.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUkernel.__reduce_cython__(self)"""

class CUkernelNodeAttrID(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_COOPERATIVE: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_IGNORE: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_PRIORITY: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION: ClassVar[CUkernelNodeAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY: ClassVar[CUkernelNodeAttrID] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUkernelNodeAttrValue(CUkernelNodeAttrValue_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUkernelNodeAttrValue_v1(CUlaunchAttributeValue):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUlaunchAttribute(CUlaunchAttribute_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUlaunchAttributeID(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_COOPERATIVE: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_IGNORE: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_PRIORITY: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION: ClassVar[CUlaunchAttributeID] = ...
    CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY: ClassVar[CUlaunchAttributeID] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUlaunchAttributeValue(CUlaunchAttributeValue_union):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUlaunchAttributeValue_union:
    accessPolicyWindow: Incomplete
    clusterDim: Incomplete
    clusterSchedulingPolicyPreference: Incomplete
    cooperative: Incomplete
    deviceUpdatableKernelNode: Incomplete
    launchCompletionEvent: Incomplete
    memSyncDomain: Incomplete
    memSyncDomainMap: Incomplete
    pad: Incomplete
    preferredClusterDim: Incomplete
    priority: Incomplete
    programmaticEvent: Incomplete
    programmaticStreamSerializationAllowed: Incomplete
    sharedMemCarveout: Incomplete
    syncPolicy: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUlaunchAttributeValue_union.getPtr(self)"""
    def __reduce__(self):
        """CUlaunchAttributeValue_union.__reduce_cython__(self)"""

class CUlaunchAttribute_st:
    id: Incomplete
    value: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUlaunchAttribute_st.getPtr(self)"""
    def __reduce__(self):
        """CUlaunchAttribute_st.__reduce_cython__(self)"""

class CUlaunchConfig(CUlaunchConfig_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUlaunchConfig_st:
    attrs: Incomplete
    blockDimX: Incomplete
    blockDimY: Incomplete
    blockDimZ: Incomplete
    gridDimX: Incomplete
    gridDimY: Incomplete
    gridDimZ: Incomplete
    hStream: Incomplete
    numAttrs: Incomplete
    sharedMemBytes: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUlaunchConfig_st.getPtr(self)"""
    def __reduce__(self):
        """CUlaunchConfig_st.__reduce_cython__(self)"""

class CUlaunchMemSyncDomain(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_LAUNCH_MEM_SYNC_DOMAIN_DEFAULT: ClassVar[CUlaunchMemSyncDomain] = ...
    CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE: ClassVar[CUlaunchMemSyncDomain] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUlaunchMemSyncDomainMap(CUlaunchMemSyncDomainMap_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUlaunchMemSyncDomainMap_st:
    default_: Incomplete
    remote: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUlaunchMemSyncDomainMap_st.getPtr(self)"""
    def __reduce__(self):
        """CUlaunchMemSyncDomainMap_st.__reduce_cython__(self)"""

class CUlibrary:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUlibrary.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUlibrary.__reduce_cython__(self)"""

class CUlibraryHostUniversalFunctionAndDataTable(CUlibraryHostUniversalFunctionAndDataTable_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUlibraryHostUniversalFunctionAndDataTable_st:
    dataTable: Incomplete
    dataWindowSize: Incomplete
    functionTable: Incomplete
    functionWindowSize: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUlibraryHostUniversalFunctionAndDataTable_st.getPtr(self)"""
    def __reduce__(self):
        """CUlibraryHostUniversalFunctionAndDataTable_st.__reduce_cython__(self)"""

class CUlibraryOption(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_LIBRARY_BINARY_IS_PRESERVED: ClassVar[CUlibraryOption] = ...
    CU_LIBRARY_HOST_UNIVERSAL_FUNCTION_AND_DATA_TABLE: ClassVar[CUlibraryOption] = ...
    CU_LIBRARY_NUM_OPTIONS: ClassVar[CUlibraryOption] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUlimit(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_LIMIT_CIG_ENABLED: ClassVar[CUlimit] = ...
    CU_LIMIT_CIG_SHMEM_FALLBACK_ENABLED: ClassVar[CUlimit] = ...
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT: ClassVar[CUlimit] = ...
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH: ClassVar[CUlimit] = ...
    CU_LIMIT_MALLOC_HEAP_SIZE: ClassVar[CUlimit] = ...
    CU_LIMIT_MAX: ClassVar[CUlimit] = ...
    CU_LIMIT_MAX_L2_FETCH_GRANULARITY: ClassVar[CUlimit] = ...
    CU_LIMIT_PERSISTING_L2_CACHE_SIZE: ClassVar[CUlimit] = ...
    CU_LIMIT_PRINTF_FIFO_SIZE: ClassVar[CUlimit] = ...
    CU_LIMIT_SHMEM_SIZE: ClassVar[CUlimit] = ...
    CU_LIMIT_STACK_SIZE: ClassVar[CUlimit] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUlinkState:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUlinkState.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUlinkState.__reduce_cython__(self)"""

class CUmemAccessDesc(CUmemAccessDesc_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemAccessDesc_st:
    flags: Incomplete
    location: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemAccessDesc_st.getPtr(self)"""
    def __reduce__(self):
        """CUmemAccessDesc_st.__reduce_cython__(self)"""

class CUmemAccessDesc_v1(CUmemAccessDesc_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemAccess_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_ACCESS_FLAGS_PROT_MAX: ClassVar[CUmemAccess_flags] = ...
    CU_MEM_ACCESS_FLAGS_PROT_NONE: ClassVar[CUmemAccess_flags] = ...
    CU_MEM_ACCESS_FLAGS_PROT_READ: ClassVar[CUmemAccess_flags] = ...
    CU_MEM_ACCESS_FLAGS_PROT_READWRITE: ClassVar[CUmemAccess_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemAllocationCompType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_ALLOCATION_COMP_GENERIC: ClassVar[CUmemAllocationCompType] = ...
    CU_MEM_ALLOCATION_COMP_NONE: ClassVar[CUmemAllocationCompType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemAllocationGranularity_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_ALLOC_GRANULARITY_MINIMUM: ClassVar[CUmemAllocationGranularity_flags] = ...
    CU_MEM_ALLOC_GRANULARITY_RECOMMENDED: ClassVar[CUmemAllocationGranularity_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemAllocationHandleType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_HANDLE_TYPE_FABRIC: ClassVar[CUmemAllocationHandleType] = ...
    CU_MEM_HANDLE_TYPE_MAX: ClassVar[CUmemAllocationHandleType] = ...
    CU_MEM_HANDLE_TYPE_NONE: ClassVar[CUmemAllocationHandleType] = ...
    CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR: ClassVar[CUmemAllocationHandleType] = ...
    CU_MEM_HANDLE_TYPE_WIN32: ClassVar[CUmemAllocationHandleType] = ...
    CU_MEM_HANDLE_TYPE_WIN32_KMT: ClassVar[CUmemAllocationHandleType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemAllocationProp(CUmemAllocationProp_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemAllocationProp_st:
    allocFlags: Incomplete
    location: Incomplete
    requestedHandleTypes: Incomplete
    type: Incomplete
    win32HandleMetaData: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemAllocationProp_st.getPtr(self)"""
    def __reduce__(self):
        """CUmemAllocationProp_st.__reduce_cython__(self)"""

class CUmemAllocationProp_v1(CUmemAllocationProp_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemAllocationType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_ALLOCATION_TYPE_INVALID: ClassVar[CUmemAllocationType] = ...
    CU_MEM_ALLOCATION_TYPE_MAX: ClassVar[CUmemAllocationType] = ...
    CU_MEM_ALLOCATION_TYPE_PINNED: ClassVar[CUmemAllocationType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemAttach_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_ATTACH_GLOBAL: ClassVar[CUmemAttach_flags] = ...
    CU_MEM_ATTACH_HOST: ClassVar[CUmemAttach_flags] = ...
    CU_MEM_ATTACH_SINGLE: ClassVar[CUmemAttach_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemDecompressAlgorithm(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_DECOMPRESS_ALGORITHM_DEFLATE: ClassVar[CUmemDecompressAlgorithm] = ...
    CU_MEM_DECOMPRESS_ALGORITHM_SNAPPY: ClassVar[CUmemDecompressAlgorithm] = ...
    CU_MEM_DECOMPRESS_UNSUPPORTED: ClassVar[CUmemDecompressAlgorithm] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemDecompressParams(CUmemDecompressParams_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemDecompressParams_st:
    algo: Incomplete
    dst: Incomplete
    dstActBytes: Incomplete
    dstNumBytes: Incomplete
    padding: Incomplete
    src: Incomplete
    srcNumBytes: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemDecompressParams_st.getPtr(self)"""
    def __reduce__(self):
        """CUmemDecompressParams_st.__reduce_cython__(self)"""

class CUmemFabricHandle(CUmemFabricHandle_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemFabricHandle_st:
    data: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemFabricHandle_st.getPtr(self)"""
    def __reduce__(self):
        """CUmemFabricHandle_st.__reduce_cython__(self)"""

class CUmemFabricHandle_v1(CUmemFabricHandle_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemGenericAllocationHandle:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemGenericAllocationHandle.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUmemGenericAllocationHandle.__reduce_cython__(self)"""

class CUmemGenericAllocationHandle_v1:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemGenericAllocationHandle_v1.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUmemGenericAllocationHandle_v1.__reduce_cython__(self)"""

class CUmemHandleType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_HANDLE_TYPE_GENERIC: ClassVar[CUmemHandleType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemLocation(CUmemLocation_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemLocationType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_LOCATION_TYPE_DEVICE: ClassVar[CUmemLocationType] = ...
    CU_MEM_LOCATION_TYPE_HOST: ClassVar[CUmemLocationType] = ...
    CU_MEM_LOCATION_TYPE_HOST_NUMA: ClassVar[CUmemLocationType] = ...
    CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT: ClassVar[CUmemLocationType] = ...
    CU_MEM_LOCATION_TYPE_INVALID: ClassVar[CUmemLocationType] = ...
    CU_MEM_LOCATION_TYPE_MAX: ClassVar[CUmemLocationType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemLocation_st:
    id: Incomplete
    type: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemLocation_st.getPtr(self)"""
    def __reduce__(self):
        """CUmemLocation_st.__reduce_cython__(self)"""

class CUmemLocation_v1(CUmemLocation_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemOperationType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_OPERATION_TYPE_MAP: ClassVar[CUmemOperationType] = ...
    CU_MEM_OPERATION_TYPE_UNMAP: ClassVar[CUmemOperationType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemPoolProps(CUmemPoolProps_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemPoolProps_st:
    allocType: Incomplete
    handleTypes: Incomplete
    location: Incomplete
    maxSize: Incomplete
    reserved: Incomplete
    usage: Incomplete
    win32SecurityAttributes: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemPoolProps_st.getPtr(self)"""
    def __reduce__(self):
        """CUmemPoolProps_st.__reduce_cython__(self)"""

class CUmemPoolProps_v1(CUmemPoolProps_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemPoolPtrExportData(CUmemPoolPtrExportData_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemPoolPtrExportData_st:
    reserved: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemPoolPtrExportData_st.getPtr(self)"""
    def __reduce__(self):
        """CUmemPoolPtrExportData_st.__reduce_cython__(self)"""

class CUmemPoolPtrExportData_v1(CUmemPoolPtrExportData_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemPool_attribute(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEMPOOL_ATTR_RELEASE_THRESHOLD: ClassVar[CUmemPool_attribute] = ...
    CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT: ClassVar[CUmemPool_attribute] = ...
    CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH: ClassVar[CUmemPool_attribute] = ...
    CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES: ClassVar[CUmemPool_attribute] = ...
    CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC: ClassVar[CUmemPool_attribute] = ...
    CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES: ClassVar[CUmemPool_attribute] = ...
    CU_MEMPOOL_ATTR_USED_MEM_CURRENT: ClassVar[CUmemPool_attribute] = ...
    CU_MEMPOOL_ATTR_USED_MEM_HIGH: ClassVar[CUmemPool_attribute] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemRangeFlags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE: ClassVar[CUmemRangeFlags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemRangeHandleType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD: ClassVar[CUmemRangeHandleType] = ...
    CU_MEM_RANGE_HANDLE_TYPE_MAX: ClassVar[CUmemRangeHandleType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmem_advise(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_ADVISE_SET_ACCESSED_BY: ClassVar[CUmem_advise] = ...
    CU_MEM_ADVISE_SET_PREFERRED_LOCATION: ClassVar[CUmem_advise] = ...
    CU_MEM_ADVISE_SET_READ_MOSTLY: ClassVar[CUmem_advise] = ...
    CU_MEM_ADVISE_UNSET_ACCESSED_BY: ClassVar[CUmem_advise] = ...
    CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION: ClassVar[CUmem_advise] = ...
    CU_MEM_ADVISE_UNSET_READ_MOSTLY: ClassVar[CUmem_advise] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmem_range_attribute(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY: ClassVar[CUmem_range_attribute] = ...
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION: ClassVar[CUmem_range_attribute] = ...
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID: ClassVar[CUmem_range_attribute] = ...
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE: ClassVar[CUmem_range_attribute] = ...
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION: ClassVar[CUmem_range_attribute] = ...
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID: ClassVar[CUmem_range_attribute] = ...
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE: ClassVar[CUmem_range_attribute] = ...
    CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY: ClassVar[CUmem_range_attribute] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemcpy3DOperand(CUmemcpy3DOperand_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemcpy3DOperandType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEMCPY_OPERAND_TYPE_ARRAY: ClassVar[CUmemcpy3DOperandType] = ...
    CU_MEMCPY_OPERAND_TYPE_MAX: ClassVar[CUmemcpy3DOperandType] = ...
    CU_MEMCPY_OPERAND_TYPE_POINTER: ClassVar[CUmemcpy3DOperandType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemcpy3DOperand_st:
    op: Incomplete
    type: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemcpy3DOperand_st.getPtr(self)"""
    def __reduce__(self):
        """CUmemcpy3DOperand_st.__reduce_cython__(self)"""

class CUmemcpy3DOperand_v1(CUmemcpy3DOperand_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemcpyAttributes(CUmemcpyAttributes_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemcpyAttributes_st:
    dstLocHint: Incomplete
    flags: Incomplete
    srcAccessOrder: Incomplete
    srcLocHint: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemcpyAttributes_st.getPtr(self)"""
    def __reduce__(self):
        """CUmemcpyAttributes_st.__reduce_cython__(self)"""

class CUmemcpyAttributes_v1(CUmemcpyAttributes_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmemcpyFlags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEMCPY_FLAG_DEFAULT: ClassVar[CUmemcpyFlags] = ...
    CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE: ClassVar[CUmemcpyFlags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemcpySrcAccessOrder(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEMCPY_SRC_ACCESS_ORDER_ANY: ClassVar[CUmemcpySrcAccessOrder] = ...
    CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL: ClassVar[CUmemcpySrcAccessOrder] = ...
    CU_MEMCPY_SRC_ACCESS_ORDER_INVALID: ClassVar[CUmemcpySrcAccessOrder] = ...
    CU_MEMCPY_SRC_ACCESS_ORDER_MAX: ClassVar[CUmemcpySrcAccessOrder] = ...
    CU_MEMCPY_SRC_ACCESS_ORDER_STREAM: ClassVar[CUmemcpySrcAccessOrder] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmemoryPool:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmemoryPool.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUmemoryPool.__reduce_cython__(self)"""

class CUmemorytype(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MEMORYTYPE_ARRAY: ClassVar[CUmemorytype] = ...
    CU_MEMORYTYPE_DEVICE: ClassVar[CUmemorytype] = ...
    CU_MEMORYTYPE_HOST: ClassVar[CUmemorytype] = ...
    CU_MEMORYTYPE_UNIFIED: ClassVar[CUmemorytype] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmipmappedArray:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmipmappedArray.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUmipmappedArray.__reduce_cython__(self)"""

class CUmodule:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmodule.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUmodule.__reduce_cython__(self)"""

class CUmoduleLoadingMode(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MODULE_EAGER_LOADING: ClassVar[CUmoduleLoadingMode] = ...
    CU_MODULE_LAZY_LOADING: ClassVar[CUmoduleLoadingMode] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmulticastGranularity_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_MULTICAST_GRANULARITY_MINIMUM: ClassVar[CUmulticastGranularity_flags] = ...
    CU_MULTICAST_GRANULARITY_RECOMMENDED: ClassVar[CUmulticastGranularity_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUmulticastObjectProp(CUmulticastObjectProp_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUmulticastObjectProp_st:
    flags: Incomplete
    handleTypes: Incomplete
    numDevices: Incomplete
    size: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUmulticastObjectProp_st.getPtr(self)"""
    def __reduce__(self):
        """CUmulticastObjectProp_st.__reduce_cython__(self)"""

class CUmulticastObjectProp_v1(CUmulticastObjectProp_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUoccupancyB2DSize:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUoccupancyB2DSize.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUoccupancyB2DSize.__reduce_cython__(self)"""

class CUoccupancy_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_OCCUPANCY_DEFAULT: ClassVar[CUoccupancy_flags] = ...
    CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE: ClassVar[CUoccupancy_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUoffset3D(CUoffset3D_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUoffset3D_st:
    x: Incomplete
    y: Incomplete
    z: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUoffset3D_st.getPtr(self)"""
    def __reduce__(self):
        """CUoffset3D_st.__reduce_cython__(self)"""

class CUoffset3D_v1(CUoffset3D_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUoutput_mode(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_OUT_CSV: ClassVar[CUoutput_mode] = ...
    CU_OUT_KEY_VALUE_PAIR: ClassVar[CUoutput_mode] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUpointer_attribute(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_POINTER_ATTRIBUTE_ACCESS_FLAGS: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_BUFFER_ID: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_CONTEXT: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_HOST_POINTER: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_IS_MANAGED: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_MAPPED: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_MAPPING_SIZE: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_P2P_TOKENS: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_RANGE_SIZE: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_RANGE_START_ADDR: ClassVar[CUpointer_attribute] = ...
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS: ClassVar[CUpointer_attribute] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUprocessState(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_PROCESS_STATE_CHECKPOINTED: ClassVar[CUprocessState] = ...
    CU_PROCESS_STATE_FAILED: ClassVar[CUprocessState] = ...
    CU_PROCESS_STATE_LOCKED: ClassVar[CUprocessState] = ...
    CU_PROCESS_STATE_RUNNING: ClassVar[CUprocessState] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUresourceViewFormat(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_RES_VIEW_FORMAT_FLOAT_1X16: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_FLOAT_1X32: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_FLOAT_2X16: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_FLOAT_2X32: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_FLOAT_4X16: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_FLOAT_4X32: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_NONE: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SIGNED_BC4: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SIGNED_BC5: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SIGNED_BC6H: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SINT_1X16: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SINT_1X32: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SINT_1X8: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SINT_2X16: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SINT_2X32: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SINT_2X8: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SINT_4X16: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SINT_4X32: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_SINT_4X8: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UINT_1X16: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UINT_1X32: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UINT_1X8: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UINT_2X16: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UINT_2X32: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UINT_2X8: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UINT_4X16: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UINT_4X32: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UINT_4X8: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H: ClassVar[CUresourceViewFormat] = ...
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7: ClassVar[CUresourceViewFormat] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUresourcetype(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_RESOURCE_TYPE_ARRAY: ClassVar[CUresourcetype] = ...
    CU_RESOURCE_TYPE_LINEAR: ClassVar[CUresourcetype] = ...
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY: ClassVar[CUresourcetype] = ...
    CU_RESOURCE_TYPE_PITCH2D: ClassVar[CUresourcetype] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUresult(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CUDA_ERROR_ALREADY_ACQUIRED: ClassVar[CUresult] = ...
    CUDA_ERROR_ALREADY_MAPPED: ClassVar[CUresult] = ...
    CUDA_ERROR_ARRAY_IS_MAPPED: ClassVar[CUresult] = ...
    CUDA_ERROR_ASSERT: ClassVar[CUresult] = ...
    CUDA_ERROR_CAPTURED_EVENT: ClassVar[CUresult] = ...
    CUDA_ERROR_CDP_NOT_SUPPORTED: ClassVar[CUresult] = ...
    CUDA_ERROR_CDP_VERSION_MISMATCH: ClassVar[CUresult] = ...
    CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE: ClassVar[CUresult] = ...
    CUDA_ERROR_CONTAINED: ClassVar[CUresult] = ...
    CUDA_ERROR_CONTEXT_ALREADY_CURRENT: ClassVar[CUresult] = ...
    CUDA_ERROR_CONTEXT_ALREADY_IN_USE: ClassVar[CUresult] = ...
    CUDA_ERROR_CONTEXT_IS_DESTROYED: ClassVar[CUresult] = ...
    CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE: ClassVar[CUresult] = ...
    CUDA_ERROR_DEINITIALIZED: ClassVar[CUresult] = ...
    CUDA_ERROR_DEVICE_NOT_LICENSED: ClassVar[CUresult] = ...
    CUDA_ERROR_DEVICE_UNAVAILABLE: ClassVar[CUresult] = ...
    CUDA_ERROR_ECC_UNCORRECTABLE: ClassVar[CUresult] = ...
    CUDA_ERROR_EXTERNAL_DEVICE: ClassVar[CUresult] = ...
    CUDA_ERROR_FILE_NOT_FOUND: ClassVar[CUresult] = ...
    CUDA_ERROR_FUNCTION_NOT_LOADED: ClassVar[CUresult] = ...
    CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE: ClassVar[CUresult] = ...
    CUDA_ERROR_HARDWARE_STACK_ERROR: ClassVar[CUresult] = ...
    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED: ClassVar[CUresult] = ...
    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED: ClassVar[CUresult] = ...
    CUDA_ERROR_ILLEGAL_ADDRESS: ClassVar[CUresult] = ...
    CUDA_ERROR_ILLEGAL_INSTRUCTION: ClassVar[CUresult] = ...
    CUDA_ERROR_ILLEGAL_STATE: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_ADDRESS_SPACE: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_CLUSTER_SIZE: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_CONTEXT: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_DEVICE: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_HANDLE: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_IMAGE: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_PC: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_PTX: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_RESOURCE_TYPE: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_SOURCE: ClassVar[CUresult] = ...
    CUDA_ERROR_INVALID_VALUE: ClassVar[CUresult] = ...
    CUDA_ERROR_JIT_COMPILATION_DISABLED: ClassVar[CUresult] = ...
    CUDA_ERROR_JIT_COMPILER_NOT_FOUND: ClassVar[CUresult] = ...
    CUDA_ERROR_KEY_ROTATION: ClassVar[CUresult] = ...
    CUDA_ERROR_LAUNCH_FAILED: ClassVar[CUresult] = ...
    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING: ClassVar[CUresult] = ...
    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES: ClassVar[CUresult] = ...
    CUDA_ERROR_LAUNCH_TIMEOUT: ClassVar[CUresult] = ...
    CUDA_ERROR_LOSSY_QUERY: ClassVar[CUresult] = ...
    CUDA_ERROR_MAP_FAILED: ClassVar[CUresult] = ...
    CUDA_ERROR_MISALIGNED_ADDRESS: ClassVar[CUresult] = ...
    CUDA_ERROR_MPS_CLIENT_TERMINATED: ClassVar[CUresult] = ...
    CUDA_ERROR_MPS_CONNECTION_FAILED: ClassVar[CUresult] = ...
    CUDA_ERROR_MPS_MAX_CLIENTS_REACHED: ClassVar[CUresult] = ...
    CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED: ClassVar[CUresult] = ...
    CUDA_ERROR_MPS_RPC_FAILURE: ClassVar[CUresult] = ...
    CUDA_ERROR_MPS_SERVER_NOT_READY: ClassVar[CUresult] = ...
    CUDA_ERROR_NOT_FOUND: ClassVar[CUresult] = ...
    CUDA_ERROR_NOT_INITIALIZED: ClassVar[CUresult] = ...
    CUDA_ERROR_NOT_MAPPED: ClassVar[CUresult] = ...
    CUDA_ERROR_NOT_MAPPED_AS_ARRAY: ClassVar[CUresult] = ...
    CUDA_ERROR_NOT_MAPPED_AS_POINTER: ClassVar[CUresult] = ...
    CUDA_ERROR_NOT_PERMITTED: ClassVar[CUresult] = ...
    CUDA_ERROR_NOT_READY: ClassVar[CUresult] = ...
    CUDA_ERROR_NOT_SUPPORTED: ClassVar[CUresult] = ...
    CUDA_ERROR_NO_BINARY_FOR_GPU: ClassVar[CUresult] = ...
    CUDA_ERROR_NO_DEVICE: ClassVar[CUresult] = ...
    CUDA_ERROR_NVLINK_UNCORRECTABLE: ClassVar[CUresult] = ...
    CUDA_ERROR_OPERATING_SYSTEM: ClassVar[CUresult] = ...
    CUDA_ERROR_OUT_OF_MEMORY: ClassVar[CUresult] = ...
    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED: ClassVar[CUresult] = ...
    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED: ClassVar[CUresult] = ...
    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED: ClassVar[CUresult] = ...
    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE: ClassVar[CUresult] = ...
    CUDA_ERROR_PROFILER_ALREADY_STARTED: ClassVar[CUresult] = ...
    CUDA_ERROR_PROFILER_ALREADY_STOPPED: ClassVar[CUresult] = ...
    CUDA_ERROR_PROFILER_DISABLED: ClassVar[CUresult] = ...
    CUDA_ERROR_PROFILER_NOT_INITIALIZED: ClassVar[CUresult] = ...
    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED: ClassVar[CUresult] = ...
    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND: ClassVar[CUresult] = ...
    CUDA_ERROR_STREAM_CAPTURE_IMPLICIT: ClassVar[CUresult] = ...
    CUDA_ERROR_STREAM_CAPTURE_INVALIDATED: ClassVar[CUresult] = ...
    CUDA_ERROR_STREAM_CAPTURE_ISOLATION: ClassVar[CUresult] = ...
    CUDA_ERROR_STREAM_CAPTURE_MERGE: ClassVar[CUresult] = ...
    CUDA_ERROR_STREAM_CAPTURE_UNJOINED: ClassVar[CUresult] = ...
    CUDA_ERROR_STREAM_CAPTURE_UNMATCHED: ClassVar[CUresult] = ...
    CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED: ClassVar[CUresult] = ...
    CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD: ClassVar[CUresult] = ...
    CUDA_ERROR_STUB_LIBRARY: ClassVar[CUresult] = ...
    CUDA_ERROR_SYSTEM_DRIVER_MISMATCH: ClassVar[CUresult] = ...
    CUDA_ERROR_SYSTEM_NOT_READY: ClassVar[CUresult] = ...
    CUDA_ERROR_TENSOR_MEMORY_LEAK: ClassVar[CUresult] = ...
    CUDA_ERROR_TIMEOUT: ClassVar[CUresult] = ...
    CUDA_ERROR_TOO_MANY_PEERS: ClassVar[CUresult] = ...
    CUDA_ERROR_UNKNOWN: ClassVar[CUresult] = ...
    CUDA_ERROR_UNMAP_FAILED: ClassVar[CUresult] = ...
    CUDA_ERROR_UNSUPPORTED_DEVSIDE_SYNC: ClassVar[CUresult] = ...
    CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY: ClassVar[CUresult] = ...
    CUDA_ERROR_UNSUPPORTED_LIMIT: ClassVar[CUresult] = ...
    CUDA_ERROR_UNSUPPORTED_PTX_VERSION: ClassVar[CUresult] = ...
    CUDA_SUCCESS: ClassVar[CUresult] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUshared_carveout(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_SHAREDMEM_CARVEOUT_DEFAULT: ClassVar[CUshared_carveout] = ...
    CU_SHAREDMEM_CARVEOUT_MAX_L1: ClassVar[CUshared_carveout] = ...
    CU_SHAREDMEM_CARVEOUT_MAX_SHARED: ClassVar[CUshared_carveout] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUsharedconfig(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE: ClassVar[CUsharedconfig] = ...
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: ClassVar[CUsharedconfig] = ...
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE: ClassVar[CUsharedconfig] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUstream:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUstream.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUstream.__reduce_cython__(self)"""

class CUstreamAttrID(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_COOPERATIVE: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_IGNORE: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_PRIORITY: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION: ClassVar[CUstreamAttrID] = ...
    CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY: ClassVar[CUstreamAttrID] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUstreamAttrValue(CUstreamAttrValue_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUstreamAttrValue_v1(CUlaunchAttributeValue):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUstreamBatchMemOpParams(CUstreamBatchMemOpParams_v1):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUstreamBatchMemOpParams_union:
    flushRemoteWrites: Incomplete
    memoryBarrier: Incomplete
    operation: Incomplete
    pad: Incomplete
    waitValue: Incomplete
    writeValue: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUstreamBatchMemOpParams_union.getPtr(self)"""
    def __reduce__(self):
        """CUstreamBatchMemOpParams_union.__reduce_cython__(self)"""

class CUstreamBatchMemOpParams_v1(CUstreamBatchMemOpParams_union):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUstreamBatchMemOpType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_STREAM_MEM_OP_BARRIER: ClassVar[CUstreamBatchMemOpType] = ...
    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES: ClassVar[CUstreamBatchMemOpType] = ...
    CU_STREAM_MEM_OP_WAIT_VALUE_32: ClassVar[CUstreamBatchMemOpType] = ...
    CU_STREAM_MEM_OP_WAIT_VALUE_64: ClassVar[CUstreamBatchMemOpType] = ...
    CU_STREAM_MEM_OP_WRITE_VALUE_32: ClassVar[CUstreamBatchMemOpType] = ...
    CU_STREAM_MEM_OP_WRITE_VALUE_64: ClassVar[CUstreamBatchMemOpType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUstreamCallback:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUstreamCallback.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUstreamCallback.__reduce_cython__(self)"""

class CUstreamCaptureMode(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_STREAM_CAPTURE_MODE_GLOBAL: ClassVar[CUstreamCaptureMode] = ...
    CU_STREAM_CAPTURE_MODE_RELAXED: ClassVar[CUstreamCaptureMode] = ...
    CU_STREAM_CAPTURE_MODE_THREAD_LOCAL: ClassVar[CUstreamCaptureMode] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUstreamCaptureStatus(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_STREAM_CAPTURE_STATUS_ACTIVE: ClassVar[CUstreamCaptureStatus] = ...
    CU_STREAM_CAPTURE_STATUS_INVALIDATED: ClassVar[CUstreamCaptureStatus] = ...
    CU_STREAM_CAPTURE_STATUS_NONE: ClassVar[CUstreamCaptureStatus] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUstreamMemOpFlushRemoteWritesParams_st:
    flags: Incomplete
    operation: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUstreamMemOpFlushRemoteWritesParams_st.getPtr(self)"""
    def __reduce__(self):
        """CUstreamMemOpFlushRemoteWritesParams_st.__reduce_cython__(self)"""

class CUstreamMemOpMemoryBarrierParams_st:
    flags: Incomplete
    operation: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUstreamMemOpMemoryBarrierParams_st.getPtr(self)"""
    def __reduce__(self):
        """CUstreamMemOpMemoryBarrierParams_st.__reduce_cython__(self)"""

class CUstreamMemOpWaitValueParams_st:
    address: Incomplete
    alias: Incomplete
    flags: Incomplete
    operation: Incomplete
    value: Incomplete
    value64: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUstreamMemOpWaitValueParams_st.getPtr(self)"""
    def __reduce__(self):
        """CUstreamMemOpWaitValueParams_st.__reduce_cython__(self)"""

class CUstreamMemOpWriteValueParams_st:
    address: Incomplete
    alias: Incomplete
    flags: Incomplete
    operation: Incomplete
    value: Incomplete
    value64: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUstreamMemOpWriteValueParams_st.getPtr(self)"""
    def __reduce__(self):
        """CUstreamMemOpWriteValueParams_st.__reduce_cython__(self)"""

class CUstreamMemoryBarrier_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_STREAM_MEMORY_BARRIER_TYPE_GPU: ClassVar[CUstreamMemoryBarrier_flags] = ...
    CU_STREAM_MEMORY_BARRIER_TYPE_SYS: ClassVar[CUstreamMemoryBarrier_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUstreamUpdateCaptureDependencies_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_STREAM_ADD_CAPTURE_DEPENDENCIES: ClassVar[CUstreamUpdateCaptureDependencies_flags] = ...
    CU_STREAM_SET_CAPTURE_DEPENDENCIES: ClassVar[CUstreamUpdateCaptureDependencies_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUstreamWaitValue_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_STREAM_WAIT_VALUE_AND: ClassVar[CUstreamWaitValue_flags] = ...
    CU_STREAM_WAIT_VALUE_EQ: ClassVar[CUstreamWaitValue_flags] = ...
    CU_STREAM_WAIT_VALUE_FLUSH: ClassVar[CUstreamWaitValue_flags] = ...
    CU_STREAM_WAIT_VALUE_GEQ: ClassVar[CUstreamWaitValue_flags] = ...
    CU_STREAM_WAIT_VALUE_NOR: ClassVar[CUstreamWaitValue_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUstreamWriteValue_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_STREAM_WRITE_VALUE_DEFAULT: ClassVar[CUstreamWriteValue_flags] = ...
    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER: ClassVar[CUstreamWriteValue_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUstream_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_STREAM_DEFAULT: ClassVar[CUstream_flags] = ...
    CU_STREAM_NON_BLOCKING: ClassVar[CUstream_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUsurfObject:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """CUsurfObject.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUsurfObject.__reduce_cython__(self)"""

class CUsurfObject_v1:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """CUsurfObject_v1.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUsurfObject_v1.__reduce_cython__(self)"""

class CUsurfref:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUsurfref.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUsurfref.__reduce_cython__(self)"""

class CUsynchronizationPolicy(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_SYNC_POLICY_AUTO: ClassVar[CUsynchronizationPolicy] = ...
    CU_SYNC_POLICY_BLOCKING_SYNC: ClassVar[CUsynchronizationPolicy] = ...
    CU_SYNC_POLICY_SPIN: ClassVar[CUsynchronizationPolicy] = ...
    CU_SYNC_POLICY_YIELD: ClassVar[CUsynchronizationPolicy] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUtensorMap(CUtensorMap_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUtensorMapDataType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_BFLOAT16: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_FLOAT16: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_FLOAT32: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_FLOAT64: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_INT32: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_INT64: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_TFLOAT32: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_UINT16: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_UINT32: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_UINT64: ClassVar[CUtensorMapDataType] = ...
    CU_TENSOR_MAP_DATA_TYPE_UINT8: ClassVar[CUtensorMapDataType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUtensorMapFloatOOBfill(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA: ClassVar[CUtensorMapFloatOOBfill] = ...
    CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE: ClassVar[CUtensorMapFloatOOBfill] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUtensorMapIm2ColWideMode(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_TENSOR_MAP_IM2COL_WIDE_MODE_W: ClassVar[CUtensorMapIm2ColWideMode] = ...
    CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128: ClassVar[CUtensorMapIm2ColWideMode] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUtensorMapInterleave(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_TENSOR_MAP_INTERLEAVE_16B: ClassVar[CUtensorMapInterleave] = ...
    CU_TENSOR_MAP_INTERLEAVE_32B: ClassVar[CUtensorMapInterleave] = ...
    CU_TENSOR_MAP_INTERLEAVE_NONE: ClassVar[CUtensorMapInterleave] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUtensorMapL2promotion(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_TENSOR_MAP_L2_PROMOTION_L2_128B: ClassVar[CUtensorMapL2promotion] = ...
    CU_TENSOR_MAP_L2_PROMOTION_L2_256B: ClassVar[CUtensorMapL2promotion] = ...
    CU_TENSOR_MAP_L2_PROMOTION_L2_64B: ClassVar[CUtensorMapL2promotion] = ...
    CU_TENSOR_MAP_L2_PROMOTION_NONE: ClassVar[CUtensorMapL2promotion] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUtensorMapSwizzle(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_TENSOR_MAP_SWIZZLE_128B: ClassVar[CUtensorMapSwizzle] = ...
    CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B: ClassVar[CUtensorMapSwizzle] = ...
    CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B_FLIP_8B: ClassVar[CUtensorMapSwizzle] = ...
    CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B: ClassVar[CUtensorMapSwizzle] = ...
    CU_TENSOR_MAP_SWIZZLE_32B: ClassVar[CUtensorMapSwizzle] = ...
    CU_TENSOR_MAP_SWIZZLE_64B: ClassVar[CUtensorMapSwizzle] = ...
    CU_TENSOR_MAP_SWIZZLE_NONE: ClassVar[CUtensorMapSwizzle] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUtensorMap_st:
    opaque: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUtensorMap_st.getPtr(self)"""
    def __reduce__(self):
        """CUtensorMap_st.__reduce_cython__(self)"""

class CUtexObject:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """CUtexObject.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUtexObject.__reduce_cython__(self)"""

class CUtexObject_v1:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """CUtexObject_v1.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUtexObject_v1.__reduce_cython__(self)"""

class CUtexref:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUtexref.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUtexref.__reduce_cython__(self)"""

class CUuserObject:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUuserObject.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """CUuserObject.__reduce_cython__(self)"""

class CUuserObjectRetain_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_GRAPH_USER_OBJECT_MOVE: ClassVar[CUuserObjectRetain_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUuserObject_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CU_USER_OBJECT_NO_DESTRUCTOR_SYNC: ClassVar[CUuserObject_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class CUuuid(CUuuid_st):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""

class CUuuid_st:
    bytes: Incomplete
    def __init__(self, void_ptr_ptr=...) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """CUuuid_st.getPtr(self)"""
    def __reduce__(self):
        """CUuuid_st.__reduce_cython__(self)"""

class EGLImageKHR:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """EGLImageKHR.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """EGLImageKHR.__reduce_cython__(self)"""

class EGLStreamKHR:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """EGLStreamKHR.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """EGLStreamKHR.__reduce_cython__(self)"""

class EGLSyncKHR:
    def __init__(self, *args, **kwargs) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """EGLSyncKHR.getPtr(self)"""
    def __index__(self) -> int:
        """Return self converted to an integer, if self is suitable for use as an index into a list."""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """EGLSyncKHR.__reduce_cython__(self)"""

class EGLint:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """EGLint.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """EGLint.__reduce_cython__(self)"""

class GLenum:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """GLenum.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """GLenum.__reduce_cython__(self)"""

class GLuint:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """GLuint.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """GLuint.__reduce_cython__(self)"""

class VdpDevice:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """VdpDevice.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """VdpDevice.__reduce_cython__(self)"""

class VdpGetProcAddress:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """VdpGetProcAddress.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """VdpGetProcAddress.__reduce_cython__(self)"""

class VdpOutputSurface:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """VdpOutputSurface.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """VdpOutputSurface.__reduce_cython__(self)"""

class VdpVideoSurface:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """VdpVideoSurface.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """VdpVideoSurface.__reduce_cython__(self)"""

class anon_struct0:
    bytesOverBudget: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct0.getPtr(self)"""
    def __reduce__(self):
        """anon_struct0.__reduce_cython__(self)"""

class anon_struct1:
    x: Incomplete
    y: Incomplete
    z: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct1.getPtr(self)"""
    def __reduce__(self):
        """anon_struct1.__reduce_cython__(self)"""

class anon_struct10:
    devPtr: Incomplete
    format: Incomplete
    height: Incomplete
    numChannels: Incomplete
    pitchInBytes: Incomplete
    width: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct10.getPtr(self)"""
    def __reduce__(self):
        """anon_struct10.__reduce_cython__(self)"""

class anon_struct11:
    reserved: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct11.getPtr(self)"""
    def __reduce__(self):
        """anon_struct11.__reduce_cython__(self)"""

class anon_struct12:
    handle: Incomplete
    name: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct12.getPtr(self)"""
    def __reduce__(self):
        """anon_struct12.__reduce_cython__(self)"""

class anon_struct13:
    handle: Incomplete
    name: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct13.getPtr(self)"""
    def __reduce__(self):
        """anon_struct13.__reduce_cython__(self)"""

class anon_struct14:
    value: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct14.getPtr(self)"""
    def __reduce__(self):
        """anon_struct14.__reduce_cython__(self)"""

class anon_struct15:
    key: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct15.getPtr(self)"""
    def __reduce__(self):
        """anon_struct15.__reduce_cython__(self)"""

class anon_struct16:
    fence: Incomplete
    keyedMutex: Incomplete
    nvSciSync: Incomplete
    reserved: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct16.getPtr(self)"""
    def __reduce__(self):
        """anon_struct16.__reduce_cython__(self)"""

class anon_struct17:
    value: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct17.getPtr(self)"""
    def __reduce__(self):
        """anon_struct17.__reduce_cython__(self)"""

class anon_struct18:
    key: Incomplete
    timeoutMs: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct18.getPtr(self)"""
    def __reduce__(self):
        """anon_struct18.__reduce_cython__(self)"""

class anon_struct19:
    fence: Incomplete
    keyedMutex: Incomplete
    nvSciSync: Incomplete
    reserved: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct19.getPtr(self)"""
    def __reduce__(self):
        """anon_struct19.__reduce_cython__(self)"""

class anon_struct2:
    event: Incomplete
    flags: Incomplete
    triggerAtBlockStart: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct2.getPtr(self)"""
    def __reduce__(self):
        """anon_struct2.__reduce_cython__(self)"""

class anon_struct20:
    extentDepth: Incomplete
    extentHeight: Incomplete
    extentWidth: Incomplete
    layer: Incomplete
    level: Incomplete
    offsetX: Incomplete
    offsetY: Incomplete
    offsetZ: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct20.getPtr(self)"""
    def __reduce__(self):
        """anon_struct20.__reduce_cython__(self)"""

class anon_struct21:
    layer: Incomplete
    offset: Incomplete
    size: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct21.getPtr(self)"""
    def __reduce__(self):
        """anon_struct21.__reduce_cython__(self)"""

class anon_struct22:
    compressionType: Incomplete
    gpuDirectRDMACapable: Incomplete
    reserved: Incomplete
    usage: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct22.getPtr(self)"""
    def __reduce__(self):
        """anon_struct22.__reduce_cython__(self)"""

class anon_struct23:
    layerHeight: Incomplete
    locHint: Incomplete
    ptr: Incomplete
    rowLength: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct23.getPtr(self)"""
    def __reduce__(self):
        """anon_struct23.__reduce_cython__(self)"""

class anon_struct24:
    array: Incomplete
    offset: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct24.getPtr(self)"""
    def __reduce__(self):
        """anon_struct24.__reduce_cython__(self)"""

class anon_struct3:
    event: Incomplete
    flags: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct3.getPtr(self)"""
    def __reduce__(self):
        """anon_struct3.__reduce_cython__(self)"""

class anon_struct4:
    x: Incomplete
    y: Incomplete
    z: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct4.getPtr(self)"""
    def __reduce__(self):
        """anon_struct4.__reduce_cython__(self)"""

class anon_struct5:
    devNode: Incomplete
    deviceUpdatable: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct5.getPtr(self)"""
    def __reduce__(self):
        """anon_struct5.__reduce_cython__(self)"""

class anon_struct6:
    depth: Incomplete
    height: Incomplete
    width: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct6.getPtr(self)"""
    def __reduce__(self):
        """anon_struct6.__reduce_cython__(self)"""

class anon_struct7:
    hArray: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct7.getPtr(self)"""
    def __reduce__(self):
        """anon_struct7.__reduce_cython__(self)"""

class anon_struct8:
    hMipmappedArray: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct8.getPtr(self)"""
    def __reduce__(self):
        """anon_struct8.__reduce_cython__(self)"""

class anon_struct9:
    devPtr: Incomplete
    format: Incomplete
    numChannels: Incomplete
    sizeInBytes: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_struct9.getPtr(self)"""
    def __reduce__(self):
        """anon_struct9.__reduce_cython__(self)"""

class anon_union10:
    miptail: Incomplete
    sparseLevel: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union10.getPtr(self)"""
    def __reduce__(self):
        """anon_union10.__reduce_cython__(self)"""

class anon_union11:
    memHandle: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union11.getPtr(self)"""
    def __reduce__(self):
        """anon_union11.__reduce_cython__(self)"""

class anon_union13:
    array: Incomplete
    ptr: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union13.getPtr(self)"""
    def __reduce__(self):
        """anon_union13.__reduce_cython__(self)"""

class anon_union15:
    pArray: Incomplete
    pPitch: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union15.getPtr(self)"""
    def __reduce__(self):
        """anon_union15.__reduce_cython__(self)"""

class anon_union2:
    overBudget: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union2.getPtr(self)"""
    def __reduce__(self):
        """anon_union2.__reduce_cython__(self)"""

class anon_union3:
    smCount: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union3.getPtr(self)"""
    def __reduce__(self):
        """anon_union3.__reduce_cython__(self)"""

class anon_union4:
    array: Incomplete
    linear: Incomplete
    mipmap: Incomplete
    pitch2D: Incomplete
    reserved: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union4.getPtr(self)"""
    def __reduce__(self):
        """anon_union4.__reduce_cython__(self)"""

class anon_union5:
    fd: Incomplete
    nvSciBufObject: Incomplete
    win32: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union5.getPtr(self)"""
    def __reduce__(self):
        """anon_union5.__reduce_cython__(self)"""

class anon_union6:
    fd: Incomplete
    nvSciSyncObj: Incomplete
    win32: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union6.getPtr(self)"""
    def __reduce__(self):
        """anon_union6.__reduce_cython__(self)"""

class anon_union7:
    fence: Incomplete
    reserved: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union7.getPtr(self)"""
    def __reduce__(self):
        """anon_union7.__reduce_cython__(self)"""

class anon_union8:
    fence: Incomplete
    reserved: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union8.getPtr(self)"""
    def __reduce__(self):
        """anon_union8.__reduce_cython__(self)"""

class anon_union9:
    array: Incomplete
    mipmap: Incomplete
    def __init__(self, void_ptr_ptr) -> Any:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def getPtr(self) -> Any:
        """anon_union9.getPtr(self)"""
    def __reduce__(self):
        """anon_union9.__reduce_cython__(self)"""

class cl_context_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    NVCL_CTX_SCHED_AUTO: ClassVar[cl_context_flags] = ...
    NVCL_CTX_SCHED_BLOCKING_SYNC: ClassVar[cl_context_flags] = ...
    NVCL_CTX_SCHED_SPIN: ClassVar[cl_context_flags] = ...
    NVCL_CTX_SCHED_YIELD: ClassVar[cl_context_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class cl_event_flags(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    NVCL_EVENT_SCHED_AUTO: ClassVar[cl_event_flags] = ...
    NVCL_EVENT_SCHED_BLOCKING_SYNC: ClassVar[cl_event_flags] = ...
    NVCL_EVENT_SCHED_SPIN: ClassVar[cl_event_flags] = ...
    NVCL_EVENT_SCHED_YIELD: ClassVar[cl_event_flags] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class cuuint32_t:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """cuuint32_t.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """cuuint32_t.__reduce_cython__(self)"""

class cuuint64_t:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None:
        """Create and return a new object.  See help(type) for accurate signature."""
    def getPtr(self) -> Any:
        """cuuint64_t.getPtr(self)"""
    def __int__(self) -> int:
        """int(self)"""
    def __reduce__(self):
        """cuuint64_t.__reduce_cython__(self)"""